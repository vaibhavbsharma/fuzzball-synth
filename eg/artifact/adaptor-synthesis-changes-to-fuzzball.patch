diff --git a/README.md b/README.md
index d4d336f..42be386 100644
--- a/README.md
+++ b/README.md
@@ -1,36 +1,3 @@
-This xxxxx/tools/fuzzball subdirectory of the xxxxx repository is a
-a branch of the upstream Git repository at:
-
-https://github.com/bitblaze-fuzzball/fuzzball
-
-It's probably best to use this directory just for changes to FuzzBALL
-itself, or code that works closely enough with the existing FuzzBALL
-code that it needs to be linked together.
-
-We created this branch using the "git subtree" command which exists in
-recent versions of Git. A suggested configuration is to have a remote
-named fuzzball-upstream pointing at the GitHub version, which you can
-create with:
-
-git remote add fuzzball-upstream https://github.com/bitblaze-fuzzball/fuzzball.git
-
-The command that created this subtree was:
-
-git subtree add --prefix tools/fuzzball fuzzball-upstream master
-
-From the web resources I was consulting, I'm guessing that the command
-for merging the most recent changes from upstream into this branch
-will be:
-
-git fetch fuzzball-upstream master
-git subtree pull --prefix tools/fuzzball fuzzball-upstream master
-
-But I haven't yet tested this commands with any updates.
-
-The rest of this file is the upstream README.md, which may still be
-useful:
-
-
 FuzzBALL is a symbolic execution tool for x86 (and a little ARM)
 binary code, based on the BitBlaze Vine library. (The name comes from
 the phrase "FUZZing Binaries with A Little Language", where "fuzzing"
diff --git a/execution/Makefile b/execution/Makefile
index da1f582..213e286 100644
--- a/execution/Makefile
+++ b/execution/Makefile
@@ -35,7 +35,6 @@ export SOURCES = \
 	smtlib_batch_engine.mli smtlib_batch_engine.ml \
 	concrete_memory.mli concrete_memory.ml \
 	granular_memory.mli granular_memory.ml \
-	adaptor_synthesis.mli adaptor_synthesis.ml \
 	fragment_machine.mli fragment_machine.ml \
 	decision_tree.mli decision_tree.ml \
 	linear_decision_tree.mli linear_decision_tree.ml \
diff --git a/execution/adaptor_synthesis.ml b/execution/adaptor_synthesis.ml
deleted file mode 100644
index 58d0684..0000000
--- a/execution/adaptor_synthesis.ml
+++ /dev/null
@@ -1,1653 +0,0 @@
-(* Extra file with helper code for adaptor synthesis. The functions 
-   defined here are used in exec_fuzzloop.ml and exec_runloop.ml *)
-
-module V = Vine;;
-
-open Fragment_machine;;
-open Exec_options;;
-open Exec_exceptions;;
-open Exec_utils;;
-
-
-let adaptor_vals = Hashtbl.create 10
- 
-(*** general helper code used in multiple adaptors ***)
-
-let get_ite_expr arg op const_type const then_val else_val = 
-  V.Ite(V.BinOp(op, arg, V.Constant(V.Int(const_type, const))),
-        then_val,
-        else_val)
-
-let rec get_ite_arg_expr fm arg_idx idx_type regs n =
-  if n = 1L
-  then fm#get_reg_symbolic (List.nth regs 0) 
-  else get_ite_expr arg_idx V.EQ idx_type (Int64.sub n 1L) 
-         (fm#get_reg_symbolic (List.nth regs ((Int64.to_int n) - 1)))
-         (get_ite_arg_expr fm arg_idx idx_type regs (Int64.sub n 1L))
-
-
-(* build an expression that restricts v to be in a certain range; the lower 
-   and upper bounds are inclusive *)
-let restrict_range v v_type lower upper =
-  V.BinOp(V.BITAND, 
-          V.UnOp(
-            V.NOT, 
-            V.BinOp(V.SLT, v, V.Constant(V.Int(v_type, lower)))),
-          V.BinOp(V.SLE, v, V.Constant(V.Int(v_type, upper))))
-
-(* build an expression that restricts v to be one of a specified list *)
-let rec specify_vals v v_type vals =
-match vals with
-| [] -> failwith "Bad value list for arithmetic adaptor"
-| v'::[] -> V.BinOp(V.EQ, v, V.Constant(V.Int(v_type, v')))
-| v'::t -> 
-    V.BinOp(V.BITOR, 
-            V.BinOp(V.EQ, v, V.Constant(V.Int(v_type, v'))),
-            specify_vals v v_type t)
-
-(* restrict the value of expr to be in a specified range or one of a 
-   specified value *)
-let restrict expr expr_type restricted_range restricted_list =
-  match restricted_range with
-  | None -> 
-      (match restricted_list with
-       | None -> V.exp_true
-       | Some l -> specify_vals expr expr_type l)
-  | Some (lower, upper) -> restrict_range expr expr_type lower upper
-
-(* build an arithmetic expression tree; this function is a little messy because 
-   it takes so many arguments, but it's useful to reuse code between the integer 
-   and floating point adaptor code
-   
-   type = 0 ----> constant value
-   type = 1 ----> argument at the position val
-   type = 2 ----> operator at position val (in int_binops @ int_unops) applied
-                  to the left and right subtrees *)
-let get_arithmetic_expr fm var arg_regs val_type out_nargs get_oper_expr depth
-      apply_special_conditions =
-  let rec build_tree d base =
-    if d <= 0 then failwith "Bad tree depth for arithmetic adaptor"
-    else 
-      let node_type = fm#get_fresh_symbolic (var ^ "_type_" ^ base) 8 in
-      let node_val = fm#get_fresh_symbolic (var ^ "_val_" ^ base) 
-                       (if val_type = V.REG_32 then 32 else 64) in
-      if d = 1 
-      then if out_nargs = 0L
-           then node_val
-           else 
-             get_ite_expr node_type V.EQ V.REG_8 0L 
-               node_val 
-               (let reg_expr = get_ite_arg_expr fm node_val val_type arg_regs out_nargs in
-                if val_type = V.REG_32 
-                then V.Cast(V.CAST_LOW, V.REG_32, reg_expr)
-                else reg_expr)
-      else
-        let left_expr = build_tree (d-1) (base ^ "0") in
-        let right_expr = build_tree (d-1) (base ^ "1") in
-        (* TODO:: in progress
-        let left_expr_sym = fm#get_fresh_symbolic (var ^ "_subtree_" ^ base ^ "0") 
-                              (if val_type = V.REG_32 then 32 else 64) in
-        let right_expr_sym = fm#get_fresh_symbolic (var ^ "_subtree_" ^ base ^ "1") 
-                              (if val_type = V.REG_32 then 32 else 64) in
-        let _ = fm#check_adaptor_condition 
-                  (V.BinOp(V.EQ, left_expr_sym, left_expr)) in
-        let _ = fm#check_adaptor_condition 
-                  (V.BinOp(V.EQ, right_expr_sym, right_expr)) in*)
-        let _ = match apply_special_conditions with
-                | None -> ()
-                | Some f -> f node_type node_val left_expr right_expr in
-        if out_nargs = 0L
-        then
-          get_ite_expr node_type V.EQ V.REG_8 0L
-            node_val
-            (get_oper_expr node_val left_expr right_expr)
-        else
-          get_ite_expr node_type V.EQ V.REG_8 0L 
-            node_val 
-            (get_ite_expr node_type V.EQ V.REG_8 1L
-               (let reg_expr = get_ite_arg_expr fm node_val val_type arg_regs out_nargs in
-                if val_type = V.REG_32 
-                then V.Cast(V.CAST_LOW, V.REG_32, reg_expr)
-                else reg_expr) 
-               (get_oper_expr node_val left_expr right_expr)) in
-  build_tree depth "R"
-
-(* add extra conditions on the structure of the int/float arithmetic adaptors' 
-   expression trees; there are a lot of arguments here too, but this saves
-   some copying & pasting later *)
-let add_arithmetic_tree_conditions fm var_name val_type out_nargs 
-      restrict_const_node binops unops depth =
-  (* zeros-out nodes in an arithmetic expression subtree *)
-  let rec zero_lower d base =
-    let node_type = fm#get_fresh_symbolic (var_name ^ "_type_" ^ base) 8 in
-    let node_val = fm#get_fresh_symbolic (var_name ^ "_val_" ^ base)
-                     (if val_type = V.REG_32 then 32 else 64) in
-    if d = 1 
-    then 
-      V.BinOp(V.BITAND, 
-              V.BinOp(V.EQ, node_type, V.Constant(V.Int(V.REG_8, 0L))), 
-              V.BinOp(V.EQ, node_val, V.Constant(V.Int(val_type, 0L))))
-    else
-      V.BinOp(V.BITAND, 
-              V.BinOp(
-                V.BITAND, 
-                V.BinOp(V.EQ, node_type, V.Constant(V.Int(V.REG_8, 0L))), 
-                V.BinOp(V.EQ, node_val, V.Constant(V.Int(val_type, 0L)))),
-              V.BinOp(
-                V.BITAND, 
-                zero_lower (d-1) (base ^ "0"),
-                zero_lower (d-1) (base ^ "1"))) in
-  (* adds various conditions for every node in a tree *)
-  let rec traverse_tree d base = 
-    if d <= 0 then failwith "Bad tree depth for arithmetic adaptor"
-    else 
-      let node_type = fm#get_fresh_symbolic (var_name ^ "_type_" ^ base) 8 in
-      let node_val = fm#get_fresh_symbolic (var_name ^ "_val_" ^ base)
-                       (if val_type = V.REG_32 then 32 else 64) in
-        if d = 1
-        then 
-          (* in this case we are at a leaf in the tree, we require:
-             - type <= 1
-             - if type = 1, then val < (# of arguments)
-             - if type = 0, then val must be in the specified range,
-               or be one of the specified values
-             - also, if out_nargs = 0 then we only want to allow constants *)
-          synth_extra_conditions := 
-            (V.BinOp(V.LE, node_type, V.Constant(V.Int(V.REG_8, 1L)))) ::
-              (V.BinOp(
-                 V.BITOR,
-                 V.BinOp(V.NEQ, node_type, V.Constant(V.Int(V.REG_8, 1L))),
-                 V.BinOp(V.LT, node_val, V.Constant(V.Int(val_type, out_nargs))))) :: 
-            (restrict_const_node node_type node_val) ::
-            (if out_nargs = 0L 
-             then (V.BinOp(V.EQ, node_type, V.Constant(V.Int(V.REG_8, 0L)))) :: !synth_extra_conditions 
-             else !synth_extra_conditions)
-        else
-          (* in this case we are at a non-leaf node, we require:
-             - type <= 2
-             - if type = 1, then val < (# of arguments)
-             - if type = 2, then val < (# of operators)
-             - if type = 0, then val must be in the specified range,
-               or be one of the specified values
-             - if the type is 0 or 1 (constant or variable) then the nodes in
-               the left and right subtrees must be zero
-             - if type = 2 and val corresponds to a unary operator, then nodes
-               in the right subtree must be zero
-             - also, if out_nargs = 0 then we only want to allow constants & operators *)
-          (synth_extra_conditions := 
-            (V.BinOp(V.LE, node_type, V.Constant(V.Int(V.REG_8, 2L)))) ::
-            (V.BinOp(
-               V.BITOR,
-               V.BinOp(V.NEQ, node_type, V.Constant(V.Int(V.REG_8, 1L))),
-               V.BinOp(V.LT, node_val, V.Constant(V.Int(val_type, out_nargs))))) :: 
-            (V.BinOp(
-               V.BITOR,
-               V.BinOp(V.NEQ, node_type, V.Constant(V.Int(V.REG_8, 2L))),
-               V.BinOp(
-                 V.LT, 
-                 node_val, 
-                 V.Constant
-                 (V.Int(
-                    val_type, 
-                    Int64.of_int ((List.length binops) + (List.length unops))))))) ::
-            (restrict_const_node node_type node_val) ::
-            (V.BinOp(
-               V.BITOR,
-               V.BinOp(V.EQ, node_type, V.Constant(V.Int(V.REG_8, 2L))),
-               V.BinOp(V.BITAND, 
-                       zero_lower (d-1) (base ^ "0"), 
-                       zero_lower (d-1) (base ^ "1")))) ::
-            (V.BinOp(
-               V.BITOR,
-               V.BinOp(
-                 V.BITOR, 
-                 V.BinOp(V.NEQ, node_type, V.Constant(V.Int(V.REG_8, 2L))), 
-                 V.BinOp(V.LT, node_val, 
-                         V.Constant(
-                           V.Int(
-                             val_type, 
-                             Int64.of_int (List.length binops))))),
-               zero_lower (d-1) (base ^ "1"))) ::
-            (if out_nargs = 0L
-             then (V.BinOp(V.BITOR,
-                           V.BinOp(V.EQ, node_type, V.Constant(V.Int(V.REG_8, 0L))),
-                           V.BinOp(V.EQ, node_type, V.Constant(V.Int(V.REG_8, 2L))))) ::
-                  !synth_extra_conditions 
-             else !synth_extra_conditions);
-            traverse_tree (d-1) (base ^ "0");
-            traverse_tree (d-1) (base ^ "1")) in
-  traverse_tree depth "R"
-
-(*** integer arithmetic adaptor ***)
-
-(* use the variables below to specify the kinds of adaptors and 
-   counterexamples that can be synthesized; these variables will be used
-   in arithmetic_int_adaptor and arithmetic_int_extra_conditions *)
-(* tree depth *)
-let int_arith_depth = 3
-(* 32 or 64-bit values (int vs. long int) *)
-let int_val_type = V.REG_32
-(* binary and unary operators; all possible operators:
-   V.PLUS; V.MINUS; V.TIMES; V.BITAND; V.BITOR; V.XOR; V.DIVIDE; 
-   V.SDIVIDE;V.MOD; V.SMOD; V.LSHIFT; V.RSHIFT; V.ARSHIFT;
-   V.NEG; V.NOT 
-   
-   if shift operations are included in the list, put them all next to each 
-   other (consecutive); do the smae if mod or division operations are included
-   in the list; this makes placing restrictions on the operands to these
-   operators a little easier *)
-let int_binops = [V.PLUS; V.MINUS; V.BITAND; V.BITOR; V.XOR; V.LSHIFT; V.RSHIFT; V.ARSHIFT]
-let int_unops = [V.NEG; V.NOT]
-(* restrict the constant values generated; int_restrict_constant_range
-   should be 'None' or 'Some (lower, upper)' and int_restrict_constant_list 
-   should be 'None' or 'Some [v1; v2; ...; vn]' (NOTE: this list must contain
-   zero if used) *)
-let int_restrict_constant_range = None
-let int_restrict_constant_list = None
-(* restrict the input and output of the adaptor (input restrictions reflect
-   f1 preconditions and output restrictions reflect f2 preconditions)
-   int_restrict_X_range should be 'None' or 'Some (lower, upper)' and 
-   int_restrict_X_list should be 'None' or 'Some [v1; v2; ...; vn]' (NOTE:
-   this list must contain zero if used) *)
-let int_restrict_input_range = None
-let int_restrict_input_list = None
-let int_restrict_output_range = None
-let int_restrict_output_list = None
-
-(* creates symbolic variables representing the adaptor function and encodes
-   the rules for applying the adaptor function; this function is called in 
-   exec_runloop *)
-let arithmetic_int_adaptor fm out_nargs in_nargs =
-  (* argument registers -- assumes x86-64 *)
-  let arg_regs = [R_RDI;R_RSI;R_RDX;R_RCX;R_R8;R_R9] in
-  (* operators that require special handling *)
-  let div_ops = [V.DIVIDE; V.SDIVIDE; V.MOD; V.SMOD] in
-  let shift_ops = [V.LSHIFT; V.RSHIFT; V.ARSHIFT] in
-  (* builds an expression that applies some operator to apply to l and r *)
-  let get_oper_expr node_value l r =
-    let rec unop_expr ops n =
-      match ops with 
-      | [] -> failwith "Missing operators for the arithmetic adaptor"
-      | unop::[] -> V.UnOp(unop, l)
-      | unop::tl -> 
-          get_ite_expr node_value V.EQ int_val_type n
-            (V.UnOp(unop, l))
-            (unop_expr tl (Int64.add n 1L)) in
-    let rec binop_expr ops n =
-      match ops with 
-      | [] -> unop_expr int_unops n
-      | binop::tl -> 
-          let expr = 
-            if (List.mem binop div_ops)
-            then (* accounts for div. by zero *)
-              V.BinOp(
-                binop, l, 
-                get_ite_expr r V.EQ int_val_type 0L 
-                  (V.Constant(V.Int(int_val_type, 1L))) r)
-            else 
-              if (List.mem binop shift_ops)
-              then (* forces shifts by valid values *)
-                V.BinOp(
-                  binop, l, 
-                  V.BinOp(
-                    V.BITAND, r, 
-                    if int_val_type = V.REG_32
-                    then V.Constant(V.Int(int_val_type, 31L))
-                    else V.Constant(V.Int(int_val_type, 63L))))
-              else (* standard binary operator application *)
-                V.BinOp(binop, l, r) in
-          if (tl = [] && int_unops = [])
-          then expr
-          else get_ite_expr node_value V.EQ int_val_type n
-                 expr (binop_expr tl (Int64.add n 1L)) in
-    binop_expr int_binops 0L in
-  (* build a function that restricts the operands of shift, mod, and division
-     to be 'good'; this function will be run in get_arithmetic_expr *)
-  (* TODO: in progress
-    let other_restrictions node_type node_val left_expr right_expr = 
-    let get_op_indices l = 
-      List.filter (fun el -> el <> (-1L)) 
-                  (List.mapi 
-                     (fun idx el -> if (List.mem el l) 
-                                    then Int64.of_int idx else -1L) 
-                  int_binops) in
-    let shift_indices = get_op_indices shift_ops in
-    let div_indices = get_op_indices div_ops in
-    (match shift_indices with
-     | [] -> ()
-     | l -> (* if the current node corresponds to a shift operation, force the 
-               right operand to be <= 32 or <=64 *)
-         let expr =
-           V.BinOp(
-             V.BITOR,
-             V.UnOp(
-               V.NOT, 
-               V.BinOp(
-                 V.BITAND,
-                 V.BinOp(V.EQ, node_type, V.Constant(V.Int(V.REG_8, 2L))),
-                 specify_vals node_val int_val_type shift_indices)),
-             V.BinOp(
-               V.BITAND,
-               V.UnOp(
-                 V.NOT, 
-                 V.BinOp(V.LT, right_expr, V.Constant(V.Int(int_val_type, 0L)))),
-               V.BinOp(
-                 V.LE, 
-                 right_expr, 
-                 V.Constant(
-                   V.Int(int_val_type, 
-                         if int_val_type = V.REG_32 then 32L else 64L))))) in
-         fm#check_adaptor_condition expr;
-     match div_indices with
-     | [] -> ()
-     | l -> (* if the current node corresponds to a division/mod operation, 
-               force the right operand to be <> 0 *)
-         let expr =
-           V.BinOp(
-             V.BITOR,
-             V.UnOp(
-               V.NOT, 
-               V.BinOp(
-                 V.BITAND,
-                 V.BinOp(V.EQ, node_type, V.Constant(V.Int(V.REG_8, 2L))),
-                 specify_vals node_val int_val_type div_indices)),
-             V.BinOp(
-               V.NEQ,
-               right_expr,
-               V.Constant(V.Int(int_val_type, 0L)))) in
-         fm#check_adaptor_condition expr) in*)
-  (* we store symbolic expressions representing adaptors in a list and then 
-     later call set_reg_symbolic on each expression in that list *)
-  let symbolic_exprs = ref [] in
-  let rec get_exprs n =
-    let var_name = String.make 1 (Char.chr ((Char.code 'a') + n)) in
-    symbolic_exprs :=
-      (get_arithmetic_expr fm var_name arg_regs int_val_type out_nargs 
-         get_oper_expr int_arith_depth None) 
-      :: !symbolic_exprs;
-    if n > 0 then get_exprs (n-1) else () in
-  if in_nargs > 0L
-  then
-    (get_exprs ((Int64.to_int in_nargs) - 1);
-     List.iteri
-       (fun idx expr ->
-          (*let var_name = String.make 1 (Char.chr ((Char.code 'a') + idx)) in 
-          let root_sym = fm#get_fresh_symbolic (var_name ^ "_subtree_R") 
-                           (if int_val_type = V.REG_32 then 32 else 64) in
-          fm#check_adaptor_condition (V.BinOp(V.EQ, root_sym, expr));
-          fm#set_reg_symbolic (List.nth arg_regs idx) root_sym;
-          fm#check_adaptor_condition 
-            (restrict root_sym int_val_type int_restrict_output_range 
-               int_restrict_output_list)*)
-          fm#set_reg_symbolic (List.nth arg_regs idx) expr;
-          fm#check_adaptor_condition 
-            (restrict expr int_val_type int_restrict_output_range 
-               int_restrict_output_list))
-       !symbolic_exprs)
-  else ()
-    
-(* adds extra conditions on the input variables and associated 
-   adaptor variables; this function is called in exec_fuzzloop *)
-let rec arithmetic_int_extra_conditions fm out_nargs n = 
-  let var_name = String.make 1 (Char.chr ((Char.code 'a') + n)) in
-  let var = fm#get_fresh_symbolic var_name 
-              (if int_val_type = V.REG_32 then 32 else 64) in
-  (* restrict the value of a constant node to be in a specified range or 
-     one of a specified value *)
-  let restrict_const_node node_type node_val =
-    match int_restrict_constant_range with
-    | None -> 
-        (match int_restrict_constant_list with
-         | None -> V.exp_true
-         | Some l -> 
-             V.BinOp(
-               V.BITOR,
-               V.BinOp(V.NEQ, node_type, V.Constant(V.Int(V.REG_8, 0L))),
-               specify_vals node_val int_val_type l))
-    | Some (lower, upper) ->
-        V.BinOp(
-          V.BITOR,
-          V.BinOp(V.NEQ, node_type, V.Constant(V.Int(V.REG_8, 0L))),
-          restrict_range node_val int_val_type lower upper) in
-  (* restrict the generated counterexamples *)
-  let _ = synth_extra_conditions := 
-    (restrict var int_val_type int_restrict_input_range int_restrict_input_list) 
-      :: !synth_extra_conditions in
-  add_arithmetic_tree_conditions fm var_name int_val_type out_nargs 
-    restrict_const_node int_binops int_unops int_arith_depth;
-  if n > 0 then arithmetic_int_extra_conditions fm out_nargs (n-1) else ()
-
-(*** floating point arithmetic adaptor ***)
-
-(* use the variables below to specify the kinds of adaptors and 
-   counterexamples that can be synthesized; these variables will be used
-   in arithmetic_float_adaptor and arithmetic_float_extra_conditions *)
-(* tree depth *)
-let float_arith_depth = 2
-(* 32 or 64-bit values (float vs. double) *)
-let float_val_type = V.REG_32
-(* binary and unary operators; all possible operators:
-   V.FPLUS; V.FMINUS; V.FTIMES; V.FDIVIDE; V.FNEG *)
-let float_binops = [V.FPLUS; V.FMINUS; V.FTIMES]
-let float_unops = [V.FNEG]
-let float_rm = Vine_util.ROUND_NEAREST
-(* restrict the constant values generated; float_restrict_constant_range
-   should be 'None' or 'Some (lower, upper)' and float_restrict_constant_list 
-   should be 'None' or 'Some [v1; v2; ...; vn]'; these may not actually
-   be useful because e.g. the restricting range has to be very narrow to 
-   noticeably reduce the search space *)
-let float_restrict_constant_range = None
-let float_restrict_constant_list = None
-(* restrict the counterexamples generated; float_restrict_counterexample_range
-   should be 'None' or 'Some (lower, upper)' and float_restrict_counterexample_list 
-   should be 'None' or 'Some [v1; v2; ...; vn]'; same note as above: these may
-   not be very useful *)
-let float_restrict_counterexample_range = Some (0.0, 0.5)
-let float_restrict_counterexample_list = None
-
-(* creates symbolic variables representing the adaptor function and encodes
-   the rules for applying the adaptor function; this function is called in 
-   exec_runloop *)
-let arithmetic_float_adaptor fm out_nargs in_nargs =
-  (* argument registers -- assumes SSE floating point *)
-  let arg_regs = [R_YMM0_0; R_YMM1_0; R_YMM2_0; R_YMM3_0; R_YMM4_0; R_YMM5_0] in
-  (* operators that require special handling *)
-  let special_type = [V.FDIVIDE] in
-  (* builds an expression that applies some operator to apply to l and r *)
-  let get_oper_expr node_value l r =
-    let rec unop_expr ops n =
-      match ops with 
-      | [] -> failwith "Missing operators for the arithmetic adaptor"
-      | unop::[] -> V.FUnOp(unop, float_rm, l)
-      | unop::tl -> 
-          get_ite_expr node_value V.EQ float_val_type n
-            (V.FUnOp(unop, float_rm, l))
-            (unop_expr tl (Int64.add n 1L)) in
-    let rec binop_expr ops n =
-      match ops with 
-      | [] -> unop_expr float_unops n
-      | binop::tl -> 
-          let expr = 
-            if (List.mem binop special_type)
-            then (* accounts for div. by zero *)
-              V.FBinOp(
-                binop, float_rm, l, 
-                get_ite_expr r V.EQ V.REG_32 0L 
-                  (V.Constant(V.Int(V.REG_32, 1L))) r) 
-            else (* standard binary operator application *)
-              V.FBinOp(binop, float_rm, l, r) in
-          if (tl = [] && float_unops = [])
-          then expr
-          else get_ite_expr node_value V.EQ float_val_type n
-                 expr (binop_expr tl (Int64.add n 1L)) in
-    binop_expr float_binops 0L in
-  (* we store symbolic expressions representing adaptors in a list and then 
-     later call set_reg_symbolic on each expression in that list *)
-  let symbolic_exprs = ref [] in
-  let rec get_exprs n =
-    let var_name = String.make 1 (Char.chr ((Char.code 'a') + n)) in
-    symbolic_exprs :=
-      (get_arithmetic_expr fm var_name arg_regs float_val_type out_nargs 
-         get_oper_expr float_arith_depth None) :: !symbolic_exprs;
-    if n > 0 then get_exprs (n-1) else () in
-  (get_exprs ((Int64.to_int in_nargs) - 1);
-   List.iteri 
-     (fun idx expr ->
-        fm#set_reg_symbolic (List.nth arg_regs idx) expr) !symbolic_exprs)
-  
-(* adds extra conditions on the input variables and associated adaptor 
-   variables; this function is called in exec_fuzzloop; note that we use 
-   integer comparisons (instead of floating point comparisons) in some of 
-   our extra conditions, we can do this because the symbolic variables 
-   just correspond to (kind of) typeless sequences of bits  *)
-let rec arithmetic_float_extra_conditions fm out_nargs n = 
-  let var_name = String.make 1 (Char.chr ((Char.code 'a') + n)) in
-  let var = fm#get_fresh_symbolic var_name 
-              (if float_val_type = V.REG_32 then 32 else 64) in
-  let get_bits v = 
-    if float_val_type = V.REG_32
-    then Int64.of_int32 (Int32.bits_of_float v)
-    else Int64.bits_of_float v in
-  (* restrict a value to be in a certain range; the lower and upper bounds 
-     are inclusive *)
-  let restrict_range v lower upper =
-    V.BinOp(V.BITAND, 
-            V.UnOp(
-              V.NOT, 
-              V.FBinOp(V.FLT, float_rm, v, 
-                       V.Constant(V.Int(float_val_type, get_bits lower)))),
-            V.FBinOp(V.FLE, float_rm, v, 
-                     V.Constant(V.Int(float_val_type, get_bits upper)))) in
-  (* restrict a value to be one of a specified list
-     NOTE: for implementation reasons, we always add 0L to the list of 
-           possible values *)
-  let rec specify_vals v vals =
-    match vals with
-    | [] -> failwith "Bad value list for arithmetic adaptor"
-    | v'::[] -> 
-        V.BinOp(V.BITOR, 
-                V.BinOp(V.EQ, v, V.Constant(V.Int(float_val_type, get_bits v'))),
-                V.BinOp(V.EQ, v, V.Constant(V.Int(float_val_type, 0L))))
-    | v'::t -> 
-        V.BinOp(V.BITOR, 
-                V.BinOp(V.EQ, v, V.Constant(V.Int(float_val_type, get_bits v'))),
-                specify_vals v t) in
-  (* restrict the value of a constant node to be in a specified range or 
-     one of a specified value *)
-  let restrict_const_node node_type node_val =
-    match float_restrict_constant_range with
-    | None -> 
-        (match float_restrict_constant_list with
-         | None -> V.exp_true
-         | Some l -> 
-             V.BinOp(
-               V.BITOR,
-               V.BinOp(V.NEQ, node_type, V.Constant(V.Int(V.REG_8, 0L))),
-               specify_vals node_val l))
-    | Some (lower, upper) ->
-        V.BinOp(
-          V.BITOR,
-          V.BinOp(V.NEQ, node_type, V.Constant(V.Int(V.REG_8, 0L))),
-          restrict_range node_val lower upper) in
-  (* restrict the value of the input variable to be in a specified range 
-     or one of a specified value *)
-  let restrict_input input =
-    match float_restrict_counterexample_range with
-    | None -> 
-        (match float_restrict_counterexample_list with
-         | None -> V.exp_true
-         | Some l -> specify_vals input l)
-    | Some (lower, upper) -> restrict_range input lower upper in
-  (* restrict the generated counterexamples *)
-  let _ = synth_extra_conditions := 
-            (restrict_input var) ::
-            !synth_extra_conditions in
-  add_arithmetic_tree_conditions fm var_name float_val_type out_nargs 
-    restrict_const_node float_binops float_unops float_arith_depth;
-  if n > 0 then arithmetic_float_extra_conditions fm out_nargs (n-1) else ()  
-  
-(*** simple adaptor ***)
-
-let simple_adaptor fm out_nargs in_nargs =
-  Printf.printf "Starting simple adaptor\n";
-  let arg_regs = [R_RDI;R_RSI;R_RDX;R_RCX;R_R8;R_R9] in
-  let symbolic_args = ref [] in
-  let rec main_loop n =
-    let var_name = String.make 1 (Char.chr ((Char.code 'a') + n)) in
-    let var_val = fm#get_fresh_symbolic (var_name^"_val") 64 in
-    let var_is_const = fm#get_fresh_symbolic (var_name^"_is_const") 1 in
-    let arg =  
-      (if out_nargs = 0L then (
-	(* These extra conditions should be getting added in exec_fuzzloop 
-	   to make them get added at the beginning of each iteration *)
-	(*opt_extra_conditions :=  
-          V.BinOp(V.EQ,var_is_const,V.Constant(V.Int(V.REG_1,1L)))
-	  :: !opt_extra_conditions;*)
-	var_val
-       ) 
-       else ( 
-	 (* Assuming adaptor_vals maps strings to Vine expressions
-	    where each string is the name of an adaptor variable *)
-	 if not !opt_adaptor_search_mode then (
-	   let var_is_const_val = Hashtbl.find adaptor_vals (var_name^"_is_const") in
-	   let var_val_val = Hashtbl.find adaptor_vals (var_name^"_val") in
-	   if var_is_const_val = V.Constant(V.Int(V.REG_1, 0L)) then (
-	     match var_val_val with
-	     | V.Constant(V.Int(V.REG_64, n)) ->
-	       let r = if n >= out_nargs then (Int64.pred out_nargs) else n in
-	       (fm#get_reg_symbolic (List.nth arg_regs (Int64.to_int r) ))
-	     | _ -> failwith (Printf.sprintf "failed to get value of %s_val" var_name)
-	   ) else var_val_val
-	 ) else 
-	   get_ite_expr var_is_const V.NEQ V.REG_1 0L  
-	     var_val (get_ite_arg_expr fm var_val V.REG_64 arg_regs out_nargs) 
-	 (*opt_extra_conditions :=  
-	   V.BinOp(
-           V.BITOR,
-           V.BinOp(V.EQ,var_is_const,V.Constant(V.Int(V.REG_1,1L))),
-           V.BinOp(V.LT,var_val,V.Constant(V.Int(V.REG_64,out_nargs))))
-	   :: !opt_extra_conditions;*)
-	     
-       )) 
-    in
-    let arg' =
-      (match arg with 
-      | V.Lval(V.Temp((_, s, _))) -> 
-	if Hashtbl.mem adaptor_vals s then
-	  Hashtbl.find adaptor_vals s
-	else arg
-      | _ -> arg)
-    in
-    Printf.printf "setting arg=%s\n" (V.exp_to_string arg');
-    symbolic_args := arg' :: !symbolic_args;
-    if n > 0 then main_loop (n-1); 
-  in
-  if in_nargs > 0L then  (
-    main_loop ((Int64.to_int in_nargs)-1);
-    List.iteri (fun index _expr ->
-      let expr =  
-	if (not !opt_adaptor_ivc) || !opt_adaptor_search_mode then 
-	  _expr
-	else (
-	  match fm#query_unique_value _expr V.REG_64 with
-	  | Some v ->
-	    Printf.printf "%s has unique value %Lx\n" 
-	      (V.exp_to_string _expr) v;
-	    (V.Constant(V.Int(V.REG_64, v)))
-	  | None -> 
-	    Printf.printf "%s does not have unique value\n" 
-	      (V.exp_to_string _expr);
-	    _expr
-	)
-      in
-      fm#set_reg_symbolic (List.nth arg_regs index) expr;
-    ) !symbolic_args;
-  )
-
-(* Simple adaptor code ends here *)
-
-
-(* Type conversion adaptor *)
-
-let get_ite_typeconv_expr fm arg_idx idx_type regs n =
-  V.Cast(V.CAST_SIGNED, V.REG_64, 
-	 V.Cast(V.CAST_LOW, V.REG_32, 
-		(get_ite_arg_expr fm arg_idx idx_type regs n)
-	 )
-  ) 
-
-let get_typeconv_expr src_operand src_type extend_op =
-  V.Cast(extend_op, V.REG_64, 
-	 (V.Cast(V.CAST_LOW, src_type, src_operand))
-  )
-
-(* 
-   type = 0 -> use the outer function argument in var_val
-   type = 1 -> constant in var_val
-   type = 11 -> 32-to-64 bit sign extension on outer function arg in var_val
-   type = 12 -> 32-to-64 bit zero extension on outer function arg in var_val
-   type = 21 -> 16-to-64 bit sign extension on outer function arg in var_val
-   type = 22 -> 16-to-64 bit zero extension on outer function arg in var_val
-   type = 31 -> 8-to-64 bit sign extension on outer function arg in var_val
-   type = 32 -> 8-to-64 bit zero extension on outer function arg in var_val
-   type = 41 -> 1-to-64 bit sign extension on outer function arg in var_val
-   type = 42 -> 1-to-64 bit zero extension on outer function arg in var_val
-   type = 43 -> 64-to-1 bit ITE operation on outer function arg in var_val
-*)
-
-let typeconv_adaptor fm out_nargs in_nargs =
-  Printf.printf "Starting typeconv adaptor\n";
-  let arg_regs = [R_RDI;R_RSI;R_RDX;R_RCX;R_R8;R_R9] in
-  (* argument registers -- assumes SSE floating point *)
-  (*let f_arg_regs = [R_YMM0_0; R_YMM1_0; R_YMM2_0; R_YMM3_0] in*)
-  let symbolic_args = ref [] in
-    let rec main_loop n =
-    let var_name = String.make 1 (Char.chr ((Char.code 'a') + n)) in
-    let var_val = fm#get_fresh_symbolic (var_name^"_val") 64 in
-    let var_type = fm#get_fresh_symbolic (var_name^"_type") 8 in
-    let arg =  
-      (if out_nargs = 0L then (
-	(* These extra conditions should be getting added in exec_fuzzloop 
-	   to make them get added at the beginning of each iteration *)
-	(*opt_extra_conditions :=  
-          V.BinOp(V.EQ,var_type,V.Constant(V.Int(V.REG_8,1L)))
-			      :: !opt_extra_conditions;*)
-	var_val
-       ) 
-       else ( 
-	 let ite_arg_expr = (get_ite_arg_expr fm var_val V.REG_64 arg_regs out_nargs) in
-	 let type_11_expr = (get_typeconv_expr ite_arg_expr V.REG_32 V.CAST_SIGNED) in
-	 let type_12_expr = (get_typeconv_expr ite_arg_expr V.REG_32 V.CAST_UNSIGNED) in
-	 let type_21_expr = (get_typeconv_expr ite_arg_expr V.REG_16 V.CAST_SIGNED) in
-	 let type_22_expr = (get_typeconv_expr ite_arg_expr V.REG_16 V.CAST_UNSIGNED) in
-	 let type_31_expr = (get_typeconv_expr ite_arg_expr V.REG_8 V.CAST_SIGNED) in
-	 let type_32_expr = (get_typeconv_expr ite_arg_expr V.REG_8 V.CAST_UNSIGNED) in
-	 let type_41_expr = (get_typeconv_expr ite_arg_expr V.REG_1 V.CAST_SIGNED) in
-	 let type_42_expr = (get_typeconv_expr ite_arg_expr V.REG_1 V.CAST_UNSIGNED) in
-	 let type_43_expr = 
-	   (get_ite_expr ite_arg_expr V.EQ V.REG_64 0L 
-	      (V.Constant(V.Int(V.REG_64,0L))) 
-	      (V.Constant(V.Int(V.REG_64,1L)))) in
-	 (*opt_extra_conditions :=  
-	   V.BinOp(
-             V.BITOR,
-             V.BinOp(V.EQ,var_type,V.Constant(V.Int(V.REG_8,1L))),
-             V.BinOp(V.LT,var_val,V.Constant(V.Int(V.REG_64,out_nargs))))
-			       :: !opt_extra_conditions;*)
-
-
-	 get_ite_expr var_type V.EQ V.REG_8 1L var_val 
-	   (get_ite_expr var_type V.EQ V.REG_8 0L ite_arg_expr
-	    (get_ite_expr var_type V.EQ V.REG_8 11L type_11_expr
-             (get_ite_expr var_type V.EQ V.REG_8 12L type_12_expr
-	      (get_ite_expr var_type V.EQ V.REG_8 21L type_21_expr
-               (get_ite_expr var_type V.EQ V.REG_8 22L type_22_expr
-	        (get_ite_expr var_type V.EQ V.REG_8 31L type_31_expr
-                 (get_ite_expr var_type V.EQ V.REG_8 32L type_32_expr
-	          (get_ite_expr var_type V.EQ V.REG_8 41L type_41_expr
-                   (get_ite_expr var_type V.EQ V.REG_8 42L type_42_expr
-		      type_43_expr)
-		  ))))))))
-       )
-      )
-    in
-    (*Printf.printf "setting arg=%s\n" (V.exp_to_string arg);*)
-    symbolic_args := arg :: !symbolic_args;
-    if n > 0 then main_loop (n-1); 
-  in
-  if in_nargs > 0L then  (
-    main_loop ((Int64.to_int in_nargs)-1);
-    List.iteri (fun index expr ->
-	fm#set_reg_symbolic (List.nth arg_regs index) expr;) !symbolic_args;
-  )
-
-(* Type conversion adaptor code ends here *)
-
-
-(* Floating point type conversion adaptor code starts here *)
-
-let get_ite_ftypeconv_expr ite_arg_expr =
-  V.FCast(V.CAST_FWIDEN, Vine_util.ROUND_NEAREST, V.REG_64, 
-	 V.Cast(V.CAST_LOW, V.REG_32, ite_arg_expr) ) 
-
-let float_typeconv_adaptor fm out_nargs_1 in_nargs_1 =
-  Printf.printf "Starting float-typeconv adaptor\n";
-  let out_nargs = (if out_nargs_1 > 4L then 4L else out_nargs_1) in
-  let in_nargs = (if in_nargs_1 > 4L then 4L else in_nargs_1) in
-  (* argument registers -- assumes SSE floating point *)
-  let arg_regs = [R_YMM0_0; R_YMM1_0; R_YMM2_0; R_YMM3_0] in
-  let symbolic_args = ref [] in
-    let rec main_loop n =
-    let var_name = String.make 1 (Char.chr ((Char.code 'a') + n)) in
-    let var_val = fm#get_fresh_symbolic (var_name^"_f_val") 64 in
-    let var_type = fm#get_fresh_symbolic (var_name^"_f_type") 8 in
-    let arg =  
-      (if out_nargs = 0L then (
-	opt_extra_conditions :=  
-          V.BinOp(V.EQ,var_type,V.Constant(V.Int(V.REG_8,1L)))
-			      :: !opt_extra_conditions;
-	var_val
-       ) 
-       else ( 
-	 let ite_arg_expr = (get_ite_arg_expr fm var_val V.REG_64 arg_regs out_nargs) in
-	 opt_extra_conditions :=  
-	   V.BinOp(
-             V.BITOR,
-             V.BinOp(V.EQ,var_type,V.Constant(V.Int(V.REG_8,1L))),
-             V.BinOp(V.LT,var_val,V.Constant(V.Int(V.REG_64,out_nargs))))
-			       :: !opt_extra_conditions;
-
-
-	 get_ite_expr var_type V.EQ V.REG_8 1L var_val 
-	   (get_ite_expr var_type V.EQ V.REG_8 0L ite_arg_expr
-	    ( (* Float widening cast operation on ite_arg_expr *)
-	      get_ite_ftypeconv_expr ite_arg_expr
-	    )
-	   )
-       )
-      )
-    in
-    (*Printf.printf "setting arg=%s\n" (V.exp_to_string arg);*)
-    symbolic_args := arg :: !symbolic_args;
-    if n > 0 then main_loop (n-1); 
-  in
-  if in_nargs > 0L then  (
-    main_loop ((Int64.to_int in_nargs)-1);
-    List.iteri (fun index expr ->
-	fm#set_reg_symbolic (List.nth arg_regs index) expr;) !symbolic_args;
-  )
-
-(* Floating point type conversion adaptor code ends here *)
-
-
-
-(* Return value type conversion adaptor *)
-
-let rec get_len_expr fm base_addr pos max_depth =
-  (*Printf.printf 
-    "get_len_expr pos = %Ld base_addr = %Lx\n" 
-    pos base_addr;*)
-  let b = (fm#load_byte_symbolic (Int64.add base_addr pos)) in
-  if pos < max_depth then
-    get_ite_expr b V.EQ V.REG_8 0L 
-      (V.Constant(V.Int(V.REG_64,0L)))
-      (V.BinOp(V.PLUS,V.Constant(V.Int(V.REG_64,1L)),
-	       (get_len_expr fm base_addr (Int64.succ pos) max_depth)))
-  else
-    get_ite_expr b V.EQ V.REG_8 0L
-      (V.Constant(V.Int(V.REG_64,0L)))
-      (V.Constant(V.Int(V.REG_64,1L)))
-
-let rec get_ite_saved_arg_expr fm arg_idx idx_type saved_args_list n =
-  if n = 1L
-  then (List.nth saved_args_list 0) 
-  else get_ite_expr arg_idx V.EQ idx_type (Int64.sub n 1L) 
-         (List.nth saved_args_list ((Int64.to_int n) - 1))
-         (get_ite_saved_arg_expr fm arg_idx idx_type saved_args_list (Int64.sub n 1L))
-
-(* 
-   type = 0 -> leave the return value unchanged, ret_val ignored
-   type = 1 -> constant in ret_val
-   type = 11 -> 32-to-64 bit sign extension on inner function arg in ret_val
-   type = 12 -> 32-to-64 bit zero extension on inner function arg in ret_val
-   type = 21 -> 16-to-64 bit sign extension on inner function arg in ret_val
-   type = 22 -> 16-to-64 bit zero extension on inner function arg in ret_val
-   type = 31 -> 8-to-64 bit sign extension on inner function arg in ret_val
-   type = 32 -> 8-to-64 bit zero extension on inner function arg in ret_val
-   type = 41 -> 1-to-64 bit sign extension on inner function arg in ret_val
-   type = 42 -> 1-to-64 bit zero extension on inner function arg in ret_val
-   type = 51 -> 32-to-64 bit sign extension on return_arg, ret_val ignored
-   type = 52 -> 32-to-64 bit zero extension on return_arg, ret_val ignored
-   type = 53 -> 64-to-1 bit ITE operation on return_arg, ret_val ignored
-   type = 61 -> 16-to-64 bit sign extension on return_arg, ret_val ignored
-   type = 62 -> 16-to-64 bit zero extension on return_arg, ret_val ignored
-   type = 71 -> 8-to-64 bit sign extension on return_arg, ret_val ignored
-   type = 72 -> 8-to-64 bit zero extension on return_arg, ret_val ignored
-   type = 81 -> 1-to-64 bit sign extension on return_arg, ret_val ignored
-   type = 82 -> 1-to-64 bit zero extension on return_arg, ret_val ignored
-*)
-
-let ret_typeconv_adaptor fm in_nargs =
-  Printf.printf "Starting return-typeconv adaptor\n";
-  let saved_args_list = fm#get_saved_arg_regs () in
-  assert((List.length saved_args_list) = (Int64.to_int in_nargs));
-  let ret_val = (fm#get_fresh_symbolic ("ret_val") 64) in
-  let ret_type = (fm#get_fresh_symbolic ("ret_type") 8) in
-  (* TODO: try using other return argument registers like XMM0 *)
-  let return_arg = fm#get_reg_symbolic R_RAX in
-  let type_51_expr = (get_typeconv_expr return_arg V.REG_32 V.CAST_SIGNED) in
-  let type_52_expr = (get_typeconv_expr return_arg V.REG_32 V.CAST_UNSIGNED) in
-  let type_53_expr = (get_ite_expr return_arg V.EQ V.REG_64 0L 
-			       (V.Constant(V.Int(V.REG_64,0L))) 
-			       (V.Constant(V.Int(V.REG_64,1L)))) in
-  let type_61_expr = (get_typeconv_expr return_arg V.REG_16 V.CAST_SIGNED) in
-  let type_62_expr = (get_typeconv_expr return_arg V.REG_16 V.CAST_UNSIGNED) in
-  let type_71_expr = (get_typeconv_expr return_arg V.REG_8 V.CAST_SIGNED) in
-  let type_72_expr = (get_typeconv_expr return_arg V.REG_8 V.CAST_UNSIGNED) in
-  let type_81_expr = (get_typeconv_expr return_arg V.REG_1 V.CAST_SIGNED) in
-  let type_82_expr = (get_typeconv_expr return_arg V.REG_1 V.CAST_UNSIGNED) in
-    
-  let arg =  
-    (if in_nargs = 0L then (
-      (*opt_extra_conditions := 
-	V.BinOp(V.BITOR, 
-		V.BinOp(V.LE,ret_type,V.Constant(V.Int(V.REG_8,1L))),
-		V.BinOp(V.GE,ret_type,V.Constant(V.Int(V.REG_8,51L))))
-			    :: !opt_extra_conditions;*)
-      get_ite_expr ret_type V.EQ V.REG_8 0L return_arg 
-       (get_ite_expr ret_type V.EQ V.REG_8 1L ret_val
-        (get_ite_expr ret_type V.EQ V.REG_8 51L type_51_expr
-         (get_ite_expr ret_type V.EQ V.REG_8 52L type_52_expr
-          (get_ite_expr ret_type V.EQ V.REG_8 53L type_53_expr
-           (get_ite_expr ret_type V.EQ V.REG_8 61L type_61_expr
-            (get_ite_expr ret_type V.EQ V.REG_8 62L type_62_expr
-             (get_ite_expr ret_type V.EQ V.REG_8 71L type_71_expr
-              (get_ite_expr ret_type V.EQ V.REG_8 72L type_72_expr
-               (get_ite_expr ret_type V.EQ V.REG_8 81L type_81_expr 
-                 type_82_expr)
-	      ))))))))
-    ) 
-    else ( 
-      let ite_saved_arg_expr = 
-	(get_ite_saved_arg_expr fm ret_val V.REG_64 saved_args_list in_nargs) in
-      let type_11_expr = (get_typeconv_expr ite_saved_arg_expr V.REG_32 V.CAST_SIGNED) in
-      let type_12_expr = (get_typeconv_expr ite_saved_arg_expr V.REG_32 V.CAST_UNSIGNED) in
-      let type_21_expr = (get_typeconv_expr ite_saved_arg_expr V.REG_16 V.CAST_SIGNED) in
-      let type_22_expr = (get_typeconv_expr ite_saved_arg_expr V.REG_16 V.CAST_UNSIGNED) in
-      let type_31_expr = (get_typeconv_expr ite_saved_arg_expr V.REG_8 V.CAST_SIGNED) in
-      let type_32_expr = (get_typeconv_expr ite_saved_arg_expr V.REG_8 V.CAST_UNSIGNED) in
-      let type_41_expr = (get_typeconv_expr ite_saved_arg_expr V.REG_1 V.CAST_SIGNED) in
-      let type_42_expr = (get_typeconv_expr ite_saved_arg_expr V.REG_1 V.CAST_UNSIGNED) in
-      (* these conditions should be getting added in exec_fuzzloop before symbolic_init 
-	opt_extra_conditions :=  
-	V.BinOp(
-          V.BITOR,
-          V.BinOp(V.EQ,ret_type,V.Constant(V.Int(V.REG_8,1L))),
-          V.BinOp(V.LT,ret_val,V.Constant(V.Int(V.REG_64,in_nargs))))
-			    :: !opt_extra_conditions; *)
-      get_ite_expr ret_type V.EQ V.REG_8 0L return_arg 
-	(get_ite_expr ret_type V.EQ V.REG_8 1L ret_val
-	 (get_ite_expr ret_type V.EQ V.REG_8 11L type_11_expr
-	  (get_ite_expr ret_type V.EQ V.REG_8 12L type_12_expr
-           (get_ite_expr ret_type V.EQ V.REG_8 21L type_21_expr
-            (get_ite_expr ret_type V.EQ V.REG_8 22L type_22_expr
-             (get_ite_expr ret_type V.EQ V.REG_8 31L type_31_expr
-              (get_ite_expr ret_type V.EQ V.REG_8 32L type_32_expr
-               (get_ite_expr ret_type V.EQ V.REG_8 41L type_41_expr
-                (get_ite_expr ret_type V.EQ V.REG_8 42L type_42_expr
-                 (get_ite_expr ret_type V.EQ V.REG_8 51L type_51_expr
-                  (get_ite_expr ret_type V.EQ V.REG_8 52L type_52_expr
-                   (get_ite_expr ret_type V.EQ V.REG_8 53L type_53_expr
-                    (get_ite_expr ret_type V.EQ V.REG_8 61L type_61_expr
-                     (get_ite_expr ret_type V.EQ V.REG_8 62L type_62_expr
-                      (get_ite_expr ret_type V.EQ V.REG_8 71L type_71_expr
-                       (get_ite_expr ret_type V.EQ V.REG_8 72L type_72_expr
-                        (get_ite_expr ret_type V.EQ V.REG_8 81L type_81_expr 
-                          type_82_expr)
-			  ))))))))))))))))
-	)
-    )
-  in
-  (*Printf.printf "setting return arg=%s\n" (V.exp_to_string arg);*)
-  fm#reset_saved_arg_regs;
-  fm#set_reg_symbolic R_RAX arg
-  
-(* Return value type conversion adaptor code ends here *)
-
-
-(*
-   type = 0 -> leave the return value unchanged, ret_val ignored
-   type = 1 -> constant in ret_val
-   type = 2 -> length of normal return value
-   type = 3 -> copy of an argument, ret_val counts args from zero
-   type = 4 -> length of an argument, ret_val counts args from zero TODO
-*)
-
-let ret_simplelen_adaptor fm in_nargs =
-  (*Printf.printf "Starting return-simplelen adaptor\n";*)
-  assert(in_nargs <> 0L);
-  let saved_args_list = fm#get_saved_arg_regs () in
-    assert((List.length saved_args_list) = (Int64.to_int in_nargs));
-    let ret_val = fm#get_fresh_symbolic "ret_val" 64 in
-    let ret_type = fm#get_fresh_symbolic "ret_type" 8 in
-    let return_arg = fm#get_reg_symbolic R_RAX in
-    let ite_saved_arg_expr =
-      get_ite_saved_arg_expr fm ret_val V.REG_64 saved_args_list in_nargs in
-    let return_base_addr =
-      try
-	fm#get_long_var R_RAX
-      with NotConcrete(_) -> 0L
-    in
-    let max_depth = 100L in
-    let ret_len_expr =
-      (if return_base_addr <> 0L then
-	 get_len_expr fm return_base_addr 0L max_depth
-       else
-	 V.Constant(V.Int(V.REG_64, 0L))) in
-    let arg =
-      (get_ite_expr ret_type V.EQ V.REG_8 0L return_arg
-	 (get_ite_expr ret_type V.EQ V.REG_8 1L ret_val
-	    (get_ite_expr ret_type V.EQ V.REG_8 2L ret_len_expr
-	       (* get_ite_expr ret_type V.EQ V.REG_8 3L*) ite_saved_arg_expr
-	    )))
-    in
-    opt_extra_conditions :=
-      V.BinOp(
-	V.BITOR,
-	V.BinOp(V.EQ,ret_type,V.Constant(V.Int(V.REG_8,1L))),
-	V.BinOp(V.LT,ret_val,V.Constant(V.Int(V.REG_64,in_nargs))))
-    :: !opt_extra_conditions;
-    fm#reset_saved_arg_regs;
-    (*Printf.printf "setting return arg=%s\n" (V.exp_to_string arg);*)
-    fm#set_reg_symbolic R_RAX arg
-
-(* structure adaptor for concretely-addressed memory, 
-   similar implementaton in SRFM for symbolic regions *) 
-
-(*
-  target structure field key for 2 fields
-  f_type = 0x011 -> 0 to 1 of concretely-addressed/symbolically-addressed memory, sign-extend to 32 bit
-  f_type = 0x010 -> 0 to 1 of concretely-addressed/symbolically-addressed memory, zero-extend to 32 bit
-  f_type = 0x021 -> 0 to 2 sign-extend to 32 bit
-  f_type = 0x020 -> 0 to 2 zero-extend to 32 bit
-  f_type = 0x041 -> 0 to 4 sign-extend to 32 bit
-  f_type = 0x040 -> 0 to 4 zero-extend to 32 bit
-  f_type = 0x081 -> 0 to 8 low 32 bits of 64-bit value
-  
-  f_type = 0x121 -> 1 to 2 sign-extend to 32 bit
-  f_type = 0x120 -> 1 to 2 zero-extend to 32 bit
-
-  f_type = 0x231 -> 2 to 3 sign-extend to 32 bit
-  f_type = 0x230 -> 2 to 3 zero-extend to 32 bit
-  f_type = 0x241 -> 2 to 4 sign-extend to 32 bit
-  f_type = 0x240 -> 2 to 4 zero-extend to 32 bit
-
-  f_type = 0x451 -> 4 to 5 sign-extend to 32 bit
-  f_type = 0x450 -> 4 to 5 zero-extend to 32 bit
-  f_type = 0x461 -> 4 to 6 sign-extend to 32 bit
-  f_type = 0x460 -> 4 to 6 zero-extend to 32 bit
-  f_type = 0x481 -> 4 to 8 sign-extend to 32 bit
-  f_type = 0x480 -> 4 to 8 zero-extend to 32 bit
-
-  f_type = 0x891 -> 8 to 9 sign-extend to 32 bit
-  f_type = 0x890 -> 8 to 9 zero-extend to 32 bit
-  f_type = 0x8a1 -> 8 to 10 sign-extend to 32 bit
-  f_type = 0x8a0 -> 8 to 10 zero-extend to 32 bit
-  f_type = 0x8c1 -> 8 to 12 sign-extend to 32 bit
-  f_type = 0x8c0 -> 8 to 12 zero-extend to 32 bit
-  f_type = none-of-the-above -> 8 to 16 low 32 bits of 64-bit value
-
-*)
-
-let upcast expr _extend_op end_sz =
-  match _extend_op with 
-  | (Some extend_op) ->  
-    (match end_sz with
-    | 8  -> V.Cast(extend_op, V.REG_8 , expr)
-    | 16 -> V.Cast(extend_op, V.REG_16, expr)
-    | 32 -> V.Cast(extend_op, V.REG_32, expr)
-    | 64 -> V.Cast(extend_op, V.REG_64, expr)
-    | _ -> failwith "unsupported upcast end size")
-  | None -> expr
-
-let from_concrete v sz = 
-  match sz with 
-  | 8 -> assert(v >= -128 && v <= 0xff);
-    V.Constant(V.Int(V.REG_8,  (Int64.of_int (v land 0xff))))
-  | 16 -> assert(v >= -65536 && v <= 0xffff);
-    V.Constant(V.Int(V.REG_16, (Int64.of_int (v land 0xffff))))
-  | 32 -> V.Constant(V.Int(V.REG_32, (Int64.logand (Int64.of_int v) 0xffffffffL)))
-  | 64 -> V.Constant(V.Int(V.REG_64, (Int64.of_int v)))
-  | _ -> failwith "unsupported size passed to SRFM#from_concrete"
-
-(*
-  - f1_tot_sz = f1_n * f1_sz
-  - f2_tot_sz = f2_n * f2_sz
-  - f3_tot_sz = f3_n * f3_sz
-  - f1_p  = (- f1_tot_sz) BITAND (f2_sz-1)
-  - f2_p = (- f2_tot_sz) BITAND (f3_sz-1)
-  - f3_p = 0
-  - f1_start = 0
-  - f2_start = f1_start + f1_tot_sz + f1_p
-  - f3_start = f2_start + f2_tot_sz + f2_p
-*)
-let t_array_field_ranges_l' = ref []
-let i_array_field_ranges_l' = ref []
-let i_byte_arr' = ref (Array.make 0 (ref [])) 
-let i_n_arr' = ref (Array.make 0 (ref [])) 
-let ranges_by_field_num = ref (Array.make 0 (ref []))
-let create_field_ranges_l fm =
-  (* Since we number fields from 1, 
-     start array_offsets_l_h with a null entry *)
-  let simplify e = 
-    if !opt_split_target_formulas = true then fm#simplify_exp e else e in
-  let (t_n_fields, i_n_fields, max_size) = !opt_struct_adaptor_params in
-  let array_offsets_l_h = ref [(Hashtbl.create 0)] in 
-  
-  (* for i = 1 to n_fields do
-    let f_sz_str = ("f"^(Printf.sprintf "%d" i)^"_size") in
-    let f_n_str  = ("f"^(Printf.sprintf "%d" i)^"_n") in 
-    let f_tot_sz_str = ("f"^(Printf.sprintf "%d" i)^"_tot_sz") in 
-    let f_p_str = ("f"^(Printf.sprintf "%d" i)^"_p") in 
-    let f_start_str  = ("f"^(Printf.sprintf "%d" i)^"_start") in 
-    let f_sz = fm#get_fresh_symbolic f_sz_str 16 in
-    let f_n  = fm#get_fresh_symbolic f_n_str 16 in
-    let f_start  = fm#get_fresh_symbolic f_start_str 16 in
-    let f_p = fm#get_fresh_symbolic f_p_str 16 in
-    let f_tot_sz = fm#get_fresh_symbolic f_tot_sz_str 16 in
-    
-    fm#add_to_path_cond (V.BinOp(V.EQ, f_tot_sz, V.BinOp(V.TIMES, f_sz, f_n)));
-    
-    (* f1_p  = (- f1_tot_sz) BITAND (f2_sz-1), except for last field *)
-    if i < n_fields then (
-      let f_sz_str' = ("f"^(Printf.sprintf "%d" (i+1))^"_size") in
-      let f_sz' = fm#get_fresh_symbolic f_sz_str' 16 in
-      fm#add_to_path_cond 
-	(V.BinOp(V.EQ, f_p, 
-		 V.BinOp(V.BITAND, 
-			 V.BinOp(V.MINUS, V.Constant(V.Int(V.REG_16, 0L)),
-				 f_tot_sz),
-			 V.BinOp(V.MINUS, f_sz', V.Constant(V.Int(V.REG_16, 1L)))
-		 )));
-    ) else (
-      fm#add_to_path_cond (V.BinOp(V.EQ, f_p, V.Constant(V.Int(V.REG_16, 0L))));
-    );
-
-    (* f2_start = f1_start + f1_tot_sz + f1_p, except for first field *)
-    if i > 1 then (
-      let f_tot_sz_str' = ("f"^(Printf.sprintf "%d" (i+1))^"_tot_sz") in 
-      let f_p_str' = ("f"^(Printf.sprintf "%d" (i+1))^"_p") in 
-      let f_start_str'  = ("f"^(Printf.sprintf "%d" (i+1))^"_start") in 
-      let f_start'  = fm#get_fresh_symbolic f_start_str' 16 in
-      let f_p' = fm#get_fresh_symbolic f_p_str' 16 in
-      let f_tot_sz' = fm#get_fresh_symbolic f_tot_sz_str' 16 in
-      fm#add_to_path_cond 
-	(V.BinOp(V.EQ, f_start, 
-		 V.BinOp(V.PLUS, f_start', 
-			 V.BinOp(V.PLUS, f_tot_sz', f_p'))));
-    ) else (
-      fm#add_to_path_cond 
-	(V.BinOp(V.EQ, f_start, V.Constant(V.Int(V.REG_16, 0L))));
-    );
-
-  done; (* end for i = 1 to n_fields *) *)
-  
-  let get_array_field_ranges_l field_num start_byte prev_cond n_fields =
-    let get_ent f_sz_t =
-      if n_fields = i_n_fields then (
-	let f_sz_str = ("f"^(Printf.sprintf "%d" field_num)^"_size") in
-	let f_n_str  = ("f"^(Printf.sprintf "%d" field_num)^"_n") in 
-	let field_sz = 
-	  if not !opt_adaptor_search_mode then 
-	    Hashtbl.find adaptor_vals f_sz_str
-	  else fm#get_fresh_symbolic f_sz_str 16 in
-	let field_n = 
-	  if not !opt_adaptor_search_mode then 
-	    Hashtbl.find adaptor_vals f_n_str
-	  else fm#get_fresh_symbolic f_n_str 16 in
-	let new_s_b = (((start_byte+f_sz_t-1)/f_sz_t)*f_sz_t) in
-	let num_bytes_remaining = 
-	  (max_size - new_s_b - (n_fields - field_num)) in
-	let max_n = (num_bytes_remaining/f_sz_t) in
-	(* considering number of array entries to be powers of 2 *)
-	let n = ref 1 in 
-	while !n <= max_n do
-	  let end_byte = new_s_b + (!n)*f_sz_t - 1 in
-	  let cond =
-	    V.BinOp(V.BITAND, prev_cond,
-		    V.BinOp(V.BITAND, 
-			    V.BinOp(V.EQ, field_sz, (from_concrete f_sz_t 16)),
-			    V.BinOp(V.EQ, field_n,  (from_concrete !n 16)))) in
-	  let cond' = simplify (
-	    if Hashtbl.mem (List.nth !array_offsets_l_h field_num) 
-	      (field_num, new_s_b, end_byte, !n, f_sz_t) = true then (
-		let this_cond = Hashtbl.find (List.nth !array_offsets_l_h field_num) 
-		  (field_num, new_s_b, end_byte, !n, f_sz_t) in
-		V.BinOp(V.BITOR, this_cond, cond)
-	       ) else cond ) 
-	  in
-	  Hashtbl.replace (List.nth !array_offsets_l_h field_num) 
-	    (field_num, new_s_b, end_byte, !n, f_sz_t) cond';
-	  n := !n lsl 1;
-	done;) 
-      else if n_fields = t_n_fields then (
-	let cond' = V.Constant(V.Int(V.REG_16, 1L)) in
-	let new_s_b = (((start_byte+f_sz_t-1)/f_sz_t)*f_sz_t) in
-	let num_bytes_remaining = 
-	  (max_size - new_s_b - (n_fields - field_num)) in
-	let max_n = (num_bytes_remaining/f_sz_t) in
-	(* considering number of array entries to be powers of 2 *)
-	let n = ref 1 in 
-	while !n <= max_n do
-	  let end_byte = new_s_b + (!n)*f_sz_t - 1 in
-	  Hashtbl.replace (List.nth !array_offsets_l_h field_num) 
-	    (field_num, new_s_b, end_byte, !n, f_sz_t) cond';
-	  n := !n lsl 1;
-	done;
-      ) else failwith "n_fields is not i_n_fields or t_n_fields"
-    in
-    get_ent 1; get_ent 2; get_ent 4; get_ent 8;
-  in
-  
-  let rec get_array_offsets_l field n_fields = 
-    match field with
-    | 1 -> 
-      get_array_field_ranges_l 1 0 (V.Constant(V.Int(V.REG_1, 1L))) n_fields;
-    | k -> 
-      get_array_offsets_l (k-1) n_fields;
-      let h = (List.nth !array_offsets_l_h (k-1)) in
-      Hashtbl.iter ( fun (field_num, _, end_byte, _, _) prev_cond  ->
-	assert(field_num = (k-1));
-	get_array_field_ranges_l k (end_byte+1) prev_cond n_fields; 
-	Printf.printf "SRFM#field=%d Hashtbl.len = %d\n" k
-	  (Hashtbl.length (List.nth !array_offsets_l_h k));
-      ) h;
-  in
-
-  let cmp_arr (field1, start1, end1, n1, f_sz1, _) (field2, start2, end2, n2, f_sz2, _) =
-    if field1 > field2 then 1 else if field1 < field2 then -1 else (
-      if start1 > start2 then 1 else if start1 < start2 then -1 else (
-	if end1 > end2 then 1 else if end1 < end2 then -1 else (
-	  if n1 > n2 then 1 else if n1 < n2 then -1 else (
-	    if f_sz1 > f_sz2 then 1 else if f_sz1 < f_sz2 then -1 else 0
-	  )
-	)
-      )
-    )
-  in
-  
-  let create_array_field_ranges_l n_fields = 
-    array_offsets_l_h := [];
-    for i = 1 to n_fields+1 do
-      array_offsets_l_h := (Hashtbl.create 1000) :: !array_offsets_l_h;
-    done;
-    get_array_offsets_l n_fields n_fields;
-    if !opt_time_stats then
-      (Printf.printf "get_array_offsets_l done...";
-       flush stdout);
-    let tmp_arr_off_l = ref [] in
-    for i = 1 to n_fields do
-      let h = (List.nth !array_offsets_l_h i) in
-      Hashtbl.iter (fun (f,s,e,n,sz) c -> 
-	tmp_arr_off_l := (f,s,e,n,sz,c) :: !tmp_arr_off_l;) h; 
-    done;
-    
-    if !opt_time_stats then
-      (Printf.printf "field ranges...";
-       flush stdout);
-    (List.sort cmp_arr !tmp_arr_off_l)
-  in
-  t_array_field_ranges_l' := create_array_field_ranges_l t_n_fields;
-  i_array_field_ranges_l' := create_array_field_ranges_l i_n_fields;
-  if !opt_trace_struct_adaptor = true then (
-    Printf.printf "SRFM#i_array_field_ranges_l'.length = %d\n" (List.length !i_array_field_ranges_l');
-  );
-  if !opt_trace_struct_adaptor = true then (
-    List.iteri ( fun ind (field_num, start_b, end_b, n, sz, cond) ->
-      Printf.printf "i_array_field_ranges_l'[%d]= (%d, %d, %d, %d, %d, %s)\n"
-	ind field_num start_b end_b n sz (V.exp_to_string cond);
-    ) !i_array_field_ranges_l';
-  );
-
-  (* Maintaining an index on field ranges by byte position *)
-  for i = 1 to max_size do
-    i_byte_arr' := Array.append !i_byte_arr' (Array.make 1 (ref []));
-  done;
-
-  let rec populate_i_byte l = 
-    match l with
-    | (_, s, e, _, _, _)::tail -> 
-      for i = s to e do
-	((!i_byte_arr').(i)) := (List.hd l) :: !((!i_byte_arr').(i));
-      done;
-      populate_i_byte tail
-    | [] -> ()
-  in
-  populate_i_byte !i_array_field_ranges_l';
-
-  let i_n_arr_h = ref (Array.make 0 (Hashtbl.create 0)) in
-  for i = 0 to max_size do
-    (* i_n_arr' := Array.append !i_n_arr' (Array.make 1 (ref [])); *)
-    i_n_arr_h := Array.append !i_n_arr_h (Array.make 1 (Hashtbl.create (max_size/2)));
-  done;
- 
-  let rec populate_i_n l =
-    match l with
-    | (_, s, e, n, sz, _)::tail ->
-      (* ((!i_n_arr').(n)) := (s,e,n,sz) :: !((!i_n_arr').(n)); *)
-      Hashtbl.replace ((!i_n_arr_h).(n)) (s,e,n,sz) ();
-      (* ((!i_n_arr').(n)) := (List.hd l) :: !((!i_n_arr').(n)); *)
-      populate_i_n tail
-    | [] -> ()
-  in 
-  populate_i_n !t_array_field_ranges_l';
-
-  if !opt_trace_struct_adaptor = true then (
-    for i=0 to max_size-1 do
-      Printf.printf "i_byte_arr': for byte %d: \n" i;
-      let l = !((!i_byte_arr').(i)) in
-      for j=0 to (List.length l)-1 do
-	let (_, s, e, _, _, _) = (List.nth l j) in
-	Printf.printf "(%d, %d), " s e;
-      done;
-      Printf.printf "\n";
-    done;
-  );
-  
-  Printf.printf "i_byte_arr list lengths = \n";
-  for i=0 to max_size-1 do
-    Printf.printf "%d "(List.length !((!i_byte_arr').(i)));
-  done;
-  Printf.printf "\n\n";
-
-  Printf.printf "i_n_arr_h Hashtbl lengths = \n";
-  for i=0 to max_size do
-    Printf.printf "%d "(Hashtbl.length ((!i_n_arr_h).(i))); 
-  done;
-  Printf.printf "\n\n";
- 
-  for i=0 to max_size do
-    let l = (Hashtbl.fold (fun k () ul -> k::ul) ((!i_n_arr_h).(i)) []) in 
-    i_n_arr' := Array.append !i_n_arr' (Array.make 1 (ref l));
-  done;
-
-  (* Creating an array of lists populated with ranges for each field 
-     to setup side-conditions in exec_fuzzloop *)
-  for i = 0 to t_n_fields do
-    ranges_by_field_num := Array.append !ranges_by_field_num (Array.make 1 (ref []));
-  done;
-  List.iter (
-    fun (f_num, s, e, _, sz, _) ->
-      (!ranges_by_field_num).(f_num) := (Int64.of_int ((s lsl 32)+(e lsl 16)+1)) 
-      :: !((!ranges_by_field_num).(f_num));
-      if sz != 8 then
-	(!ranges_by_field_num).(f_num) := (Int64.of_int ((s lsl 32)+(e lsl 16)+0)) 
-	:: !((!ranges_by_field_num).(f_num));
-  ) !i_array_field_ranges_l';
-
-  if !opt_trace_struct_adaptor = true then (
-    for i=0 to max_size do
-      Printf.printf "i_n_arr': for entries %d: \n" i;
-      let l = !((!i_n_arr').(i)) in
-      for j=0 to (List.length l)-1 do
-	let (s, e, n, sz) = (List.nth l j) in
-	Printf.printf "(%d, %d, %d, %d), " s e n sz;
-      done;
-      Printf.printf "\n";
-    done;
-  )
-
-
-let struct_adaptor (fm:fragment_machine) = 
-  let from_concrete v sz = 
-    match sz with 
-    | 8 -> assert(v >= -128 && v <= 0xff);
-      V.Constant(V.Int(V.REG_8,  (Int64.of_int (v land 0xff))))
-    | 16 -> assert(v >= -65536 && v <= 0xffff);
-      V.Constant(V.Int(V.REG_16, (Int64.of_int (v land 0xffff))))
-    | 32 -> V.Constant(V.Int(V.REG_32, (Int64.logand (Int64.of_int v) 0xffffffffL)))
-    | 64 -> V.Constant(V.Int(V.REG_64, (Int64.of_int v)))
-    | _ -> failwith "unsupported size passed to AS#from_concrete"
-  in
-  let get_byte expr pos =
-    V.Cast(V.CAST_LOW, V.REG_8, 
-	   V.BinOp(V.RSHIFT, expr, (from_concrete (pos*8) 8)))
-  in
-  (* This simplifies formulas and introduces t-variables for comple
-     sub-expressions. Doing this generally speeds things up, but it
-     may make debugging the formulas less convenient, so you can disable
-     it by make "simplify" be the identity function. *)
-  let simplify e = fm#simplify_exp e in
-  (* let simplify e = e in *)
-
-  let start_time = Sys.time () in
-  if (List.length !opt_synth_struct_adaptor) <> 0 then (
-    if !opt_trace_struct_adaptor = true then
-      Printf.printf "Starting structure adaptor\n";
-    if !opt_time_stats then
-      (Printf.printf "Generating structure adaptor formulas...";
-       flush stdout);
-    List.iteri ( fun addr_list_ind addr -> 
-      if !opt_time_stats then
-	(Printf.printf "(0x%08Lx)..." addr;
-	 flush stdout);
-      if (Int64.abs (fix_s32 addr)) > 4096L then (
-	let (t_n_fields, i_n_fields, max_size) = !opt_struct_adaptor_params in
-
-(* Commenting out for field_ranges_l starts here *)
-(*	let get_array_field_ranges_l field_num start_byte =
-	  let get_ent f_sz_t =
-	    let ret_offsets_l = ref [] in
-	    let f_sz_str = ("f"^(Printf.sprintf "%d" field_num)^"_size") in
-	    let f_n_str  = ("f"^(Printf.sprintf "%d" field_num)^"_n") in 
-	    let field_sz = fm#get_fresh_symbolic f_sz_str 16 in
-	    let field_n  = fm#get_fresh_symbolic f_n_str 16 in
-	    let new_s_b = (((start_byte+f_sz_t-1)/f_sz_t)*f_sz_t) in
-	    let num_bytes_remaining = 
-	      (max_size - new_s_b - (n_fields - field_num)) in
-	    let max_n = (num_bytes_remaining/f_sz_t) in
-	    for n = 1 to max_n do
-	      let end_byte = new_s_b + n*f_sz_t - 1 in
-	      let cond = 
-		V.BinOp(V.BITAND, 
-			V.BinOp(V.EQ, field_sz, (from_concrete f_sz_t 16)),
-			V.BinOp(V.EQ, field_n,  (from_concrete n 16))) in
-	      ret_offsets_l := (field_num, new_s_b, end_byte, n, f_sz_t, cond) 
-	      :: !ret_offsets_l; 
-	    done;
-	    !ret_offsets_l
-	  in
-	  (get_ent 1) @ (get_ent 2) @ (get_ent 4) @ (get_ent 8)
-	in
-	let rec get_array_offsets_l field = 
-	  match field with
-	  | 1 -> get_array_field_ranges_l 1 0 
-	  | k -> 
-	    let ret_offsets_l = ref [] in
-	    let offsets_l = get_array_offsets_l (k-1) in
-	    List.iter ( fun (field_num, _, end_byte, _, _, cond) ->
-	      if field_num = k-1 then (
-		List.iter ( fun (field_num, start_b, end_b, n, f_sz, this_field_cond) ->
-		  let cond' = V.BinOp(V.BITAND, cond, this_field_cond) in
-		  let cond' = simplify cond' in
-		  ret_offsets_l := (field_num, start_b, end_b, n, f_sz, cond') 
-		  :: !ret_offsets_l;
-		) (get_array_field_ranges_l k (end_byte+1)););
-	    ) offsets_l;
-	    Printf.printf "AS#ret_offsets_l.len = %d offsets_l.len = %d\n" 
-	      (List.length !ret_offsets_l) (List.length offsets_l);
-	    (* (!ret_offsets_l @ offsets_l) *)
-	    (List.rev_append !ret_offsets_l offsets_l)
-	in
-
-	let cmp_arr (field1,start1,end1, n1, f_sz1, _) (field2, start2, end2, n2, f_sz2, _) =
-	  if field1 > field2 then 1 else if field1 < field2 then -1 else (
-	    if start1 > start2 then 1 else if start1 < start2 then -1 else (
-	      if end1 > end2 then 1 else if end1 < end2 then -1 else (
-		if n1 > n2 then 1 else if n1 < n2 then -1 else (
-		  if f_sz1 > f_sz2 then 1 else if f_sz1 < f_sz2 then -1 else 0
-		)
-	      )
-	    )
-	  )
-	in
-	let tmp_l = ref [] in
-	let rec merge_same_field_ranges l =
-	  match l with
-	  | [] -> ()
-	  | [a] -> tmp_l := a :: !tmp_l;()
-	  | (field1, start1, end1, n1, f_sz1, cond1)::t ->
-	    let same_field_range = ref true in
-	    let cond = ref cond1 in
-	    let tail = ref t in
-	    while !same_field_range do
-	      match !tail with
-	      | [] -> same_field_range:= false;
-	      | (field2, start2, end2, n2, f_sz2, cond2)::t2 ->
-		if (field1=field2) && (start1=start2) && (end1=end2) && (n1=n2) 
-		  && (f_sz1=f_sz2) then (
-		    assert(cond1 <> cond2);
-		    cond := simplify (V.BinOp(V.BITOR, !cond, cond2));
-		    tail := t2;
-		  ) 
-		else 
-		  same_field_range := false; 
-	    done;
-	    tmp_l := (field1, start1, end1, n1, f_sz1, !cond) :: !tmp_l;
-	    (merge_same_field_ranges !tail)
-	in
-	let unique = Vine_util.list_unique in
-	if !opt_time_stats then
-	  (Printf.printf "field ranges...";
-	   flush stdout);
-	merge_same_field_ranges (List.sort cmp_arr 
-				   (unique (get_array_offsets_l n_fields)));
-	
-	let array_field_ranges_l = (List.rev !tmp_l) in *)
-(* Commenting out for field_ranges_l ends here *)
-
-(*	if !opt_trace_struct_adaptor = true then
-	  Printf.printf "AS#array_field_ranges_l.length = %d\n" (List.length array_field_ranges_l);
-	if !opt_trace_struct_adaptor = true then
-	  List.iteri ( fun ind (field_num, start_b, end_b, _, _, cond) ->
-	    Printf.printf "array_field_ranges_l[%d]= (%d, %x, %x, %s)\n"
-	      ind field_num start_b end_b (V.exp_to_string cond);
-	  ) array_field_ranges_l;
-
-	let i_byte_arr = ref (Array.make 0 (ref [])) in
-	for i = 1 to max_size do
-	  i_byte_arr := Array.append !i_byte_arr (Array.make 1 (ref []));
-	done;
-	
-	let rec populate_i_byte l = 
-	  match l with
-	  | (_, s, e, _, _, _)::tail -> 
-	    for i = s to e do
-	      ((!i_byte_arr).(i)) := (List.hd l) :: !((!i_byte_arr).(i));
-	    done;
-	    populate_i_byte tail
-	  | [] -> ()
-	in
-	populate_i_byte array_field_ranges_l;
-
-	let i_n_arr = ref (Array.make 0 (ref [])) in
-	for i = 0 to max_size do
-	  i_n_arr := Array.append !i_n_arr (Array.make 1 (ref []));
-	done;
-	let rec populate_i_n l =
-	  match l with
-	  | (_, _, _, n, sz, _)::tail ->
-	    ((!i_n_arr).(n)) := (List.hd l) :: !((!i_n_arr).(n));
-	      populate_i_n tail
-	  | [] -> ()
-	in 
-	populate_i_n array_field_ranges_l;
-	
-	if !opt_trace_struct_adaptor = true then (
-	  for i=0 to max_size-1 do
-	    Printf.printf "for byte %d: \n" i;
-	    let l = !((!i_byte_arr).(i)) in
-	    for j=0 to (List.length l)-1 do
-	      let (_, s, e, _, _, _) = (List.nth l j) in
-	      Printf.printf "(%d, %d), " s e;
-	    done;
-	    Printf.printf "\n";
-	  done;
-	);
-
-	if !opt_trace_struct_adaptor = true then (
-	  for i=0 to max_size do
-	    Printf.printf "i_n_arr: for entries %d: \n" i;
-	    let l = !((!i_n_arr).(i)) in
-	    for j=0 to (List.length l)-1 do
-	      let (_, s, e, _, _, _) = (List.nth l j) in
-	      Printf.printf "(%d, %d), " s e;
-	    done;
-	    Printf.printf "\n";
-	    done;
-	);
-*)
-	
-	let rec get_arr_t_field_expr field_num this_array_field_ranges_l 
-	    ai_byte ai_f_sz ai_n =
-	  (* Assume ai_n equals target_n for now *)
-	  let get_ai_byte_expr target_n target_sz start_addr ex_op =
-	    let cast_op =
-	      if target_sz < ai_f_sz then 
-		if ex_op = 1 then (Some V.CAST_SIGNED) 
-		else (Some V.CAST_UNSIGNED)
-	      else if target_sz > ai_f_sz then (Some V.CAST_LOW)
-	      else None
-	    in
-	    (* translate ai_byte to a t_byte by using ai_f_sz and t_sz *)
-	    let ai_q = ai_byte/ai_f_sz in
-	    let ai_r = ai_byte mod ai_f_sz in
-	    let tmp_addr = Int64.add start_addr (Int64.of_int (ai_q*target_sz)) in
-	    let ai_entry = 
-		upcast (fm#load_sym tmp_addr (target_sz*8)) cast_op (ai_f_sz*8) 
-	    in 
-	    get_byte ai_entry ai_r
-	  in
-	  match this_array_field_ranges_l with
-	  | [] -> failwith "AS#get_arr_t_field_expr ran out of this_array_field_ranges_l"
-	  | [(start_byte, end_byte, n, f_sz)] -> 
-	    assert(n = ai_n);
-	    let start_addr = (Int64.add addr (Int64.of_int start_byte)) in
-	    get_ai_byte_expr n f_sz start_addr 1
-	  | (start_byte, end_byte, n, f_sz)::tail ->
-	    assert(n = ai_n);
-	    let start_addr = (Int64.add addr (Int64.of_int start_byte)) in
-	    let is_extend_req = (f_sz - 8) in
-	    if is_extend_req <> 0 then (
-	      let sign_extend_val = Int64.of_int ((start_byte lsl 32)+(end_byte lsl 16)+1) in 
-	      let zero_extend_val = Int64.of_int ((start_byte lsl 32)+(end_byte lsl 16)+0) in 
-	      if (n = ai_n) then (
-		  let f_type_str = "f"^(Printf.sprintf "%d" field_num)^"_type" in
-		  let f_type = fm#get_fresh_symbolic f_type_str 64 in
-		  let sign_extend_expr = get_ai_byte_expr n f_sz start_addr 1 in
-		  let zero_extend_expr = get_ai_byte_expr n f_sz start_addr 0 in
-		  
-		  let else_expr =
-		    simplify
-		      (get_arr_t_field_expr field_num tail
-			 ai_byte ai_f_sz ai_n ) in
-		  
-		  get_ite_expr f_type V.EQ V.REG_64 sign_extend_val sign_extend_expr 
-		    (get_ite_expr f_type V.EQ V.REG_64 zero_extend_val zero_extend_expr
-		       else_expr )
-		  ) else (
-		  simplify (get_arr_t_field_expr field_num tail
-			      ai_byte ai_f_sz ai_n )
-		  )
-	    ) else (
-	      let sign_extend_val = Int64.of_int ((start_byte lsl 32)+(end_byte lsl 16)+1) in 
-	      if (ai_n = n) then (
-		let f_type_str = "f"^(Printf.sprintf "%d" field_num)^"_type" in
-		let f_type = fm#get_fresh_symbolic f_type_str 64 in
-		let sign_extend_expr = get_ai_byte_expr n f_sz start_addr 1 in
-
-		let else_expr =
-		  simplify
-		    (get_arr_t_field_expr field_num tail
-		       ai_byte ai_f_sz ai_n ) in
-		
-		get_ite_expr f_type V.EQ V.REG_64 sign_extend_val sign_extend_expr 
-		  else_expr
-	      ) else (
-		  simplify (get_arr_t_field_expr field_num tail
-			      ai_byte ai_f_sz ai_n )
-	      )
-	    )
-	in
-	let field_exprs = Hashtbl.create 1001 in
-	let t_field_h = Hashtbl.create 1000 in
-	let rec get_arr_ite_ai_byte_expr this_array_field_ranges_l i_byte = 
-	  (* i_byte = interesting_byte *)
-	  match this_array_field_ranges_l with
-	  | [] -> from_concrete 0 8
-	  | (field, start_byte, end_byte, ai_n, ai_f_sz, cond)::tail ->
-	    if (i_byte >= start_byte) && (i_byte <= end_byte) then (
-	      let field_size_temp_str = "arr_as_t_field_"^
-		(Printf.sprintf "%d_n%d_sz%d_b%d_%d" field ai_n ai_f_sz 
-		   (i_byte-start_byte) addr_list_ind)
-	      in
-	      let field_size_temp = fm#get_fresh_symbolic field_size_temp_str 8 in
-
-	      let q_exp = 
-		(try
-                   Hashtbl.find field_exprs field_size_temp_str
-                 with Not_found ->
-                   let new_q_exp =
-		     V.BinOp(V.EQ, field_size_temp,
-			     (get_arr_t_field_expr field 
-				(List.rev !((!i_n_arr').(ai_n))) (* array_field_ranges_l *)
-				(i_byte-start_byte) ai_f_sz ai_n )) in
-		     Hashtbl.replace field_exprs field_size_temp_str new_q_exp;
-		     fm#add_to_path_cond new_q_exp;
-		     new_q_exp)
-	      in
-
-	      if !opt_trace_struct_adaptor = true then
-		Hashtbl.replace t_field_h field_size_temp q_exp;
-	      
-	      V.Ite(cond, field_size_temp, 
-		    (get_arr_ite_ai_byte_expr tail i_byte ))
-	    ) else (
-	      get_arr_ite_ai_byte_expr tail i_byte 
-	    )
-	in
-	if !opt_time_stats then
-	  (Printf.printf "byte expressions...";
-	   flush stdout);
-	let byte_expr_l = ref [] in 
-	for i=0 to (max_size-1) do 
-	  let byte_expr = (get_arr_ite_ai_byte_expr (List.rev !((!i_byte_arr').(i))) i) in
-	  let byte_expr_sym_str = "arr_ai_byte_"^(Printf.sprintf "%d_%d" i addr_list_ind) in
-	  let byte_expr_sym = fm#get_fresh_symbolic byte_expr_sym_str 8 in
-	  let q_exp = V.BinOp(V.EQ, byte_expr_sym, byte_expr) in
-	  if !opt_trace_struct_adaptor = true then
-	    Printf.printf "AS#get_arr_ite_ai_byte_expr for byte %d: %s\n\n" i
-	      (V.exp_to_string q_exp);
-	  fm#add_to_path_cond q_exp; 
-	  byte_expr_l := byte_expr_sym :: !byte_expr_l;
-	done;
-	byte_expr_l := (List.rev !byte_expr_l);
-
-	if !opt_trace_struct_adaptor = true then
-	  Hashtbl.iter (fun key value ->
-	    Printf.printf "AS#apply_struct_adaptor t_field_h[%s] = %s\n" 
-	      (V.exp_to_string key) (V.exp_to_string value);
-	  ) t_field_h; 
-	
-	for i=0 to (max_size-1) do
-	  fm#store_sym (Int64.add addr (Int64.of_int i)) 8 (List.nth !byte_expr_l i);
-	done;
-	
-      );
-      
-    ) !opt_synth_struct_adaptor;
-  );
-  if !opt_time_stats then
-    (Printf.printf "AS#ready to apply (%f sec).\n" (Sys.time () -. start_time);
-     flush stdout);
-  fm#sym_region_struct_adaptor;
diff --git a/execution/adaptor_synthesis.mli b/execution/adaptor_synthesis.mli
deleted file mode 100644
index e3a2635..0000000
--- a/execution/adaptor_synthesis.mli
+++ /dev/null
@@ -1,28 +0,0 @@
-
-val arithmetic_int_adaptor : 
-  Fragment_machine.fragment_machine -> int64 -> int64 -> unit
-val arithmetic_int_extra_conditions :
-  Fragment_machine.fragment_machine -> int64 -> int -> unit
-val arithmetic_float_adaptor : 
-  Fragment_machine.fragment_machine -> int64 -> int64 -> unit
-val arithmetic_float_extra_conditions :
-  Fragment_machine.fragment_machine -> int64 -> int -> unit
-val simple_adaptor : 
-  Fragment_machine.fragment_machine -> int64 -> int64 -> unit
-val typeconv_adaptor : 
-  Fragment_machine.fragment_machine -> int64 -> int64 -> unit
-val float_typeconv_adaptor : 
-  Fragment_machine.fragment_machine -> int64 -> int64 -> unit
-val ret_typeconv_adaptor :
-  Fragment_machine.fragment_machine -> int64 -> unit
-val ret_simplelen_adaptor :
-  Fragment_machine.fragment_machine -> int64 -> unit
-val create_field_ranges_l : 
-  Fragment_machine.fragment_machine -> unit 
-val i_array_field_ranges_l' : (int * int * int * int * int * Vine.exp) list ref
-val i_byte_arr' :  (int * int * int * int * int * Vine.exp) list ref array ref
-val i_n_arr' : (int * int * int * int) list ref array ref
-val ranges_by_field_num : int64 list ref array ref
-val struct_adaptor: 
-  Fragment_machine.fragment_machine -> unit
-val adaptor_vals : ( string, Vine.exp ) Hashtbl.t
diff --git a/execution/binary_decision_tree.ml b/execution/binary_decision_tree.ml
index 77f7759..cdb2adf 100644
--- a/execution/binary_decision_tree.ml
+++ b/execution/binary_decision_tree.ml
@@ -649,7 +649,7 @@ class binary_decision_tree = object(self)
       (match get_f_child n with
 	 | Some(Some kid) ->
 	     if not kid.all_seen then
-	       (Printf.printf "all_seen invariant failure: parent %d is all seen, but not false child %d%!\n"
+	       (Printf.printf "all_seen invariant failure: parent %d is all seen, but not true child %d%!\n"
 		  n.ident kid.ident;
 		self#print_tree stdout;
 		assert(kid.all_seen));
diff --git a/execution/concrete_memory.ml b/execution/concrete_memory.ml
index 3242133..e465409 100644
--- a/execution/concrete_memory.ml
+++ b/execution/concrete_memory.ml
@@ -282,17 +282,12 @@ class string_maybe_memory = object(self)
 
   method private maybe_get_pages addr = 
     let page = Int64.to_int (Int64.shift_right addr 12) and
-	idx = Int64.to_int (Int64.logand addr 0xfffL) and
-	large_const = Int64.shift_left (Int64.sub (Int64.shift_left 1L 32) 1L) 32 in
-    (* We dont support 64-bit addresses yet *)
-    if (Int64.logand addr large_const) <> 0L then
-      (Printf.printf "page=%x idx=%x\n" page idx;
-       raise UnsupportedAddress;);
-    match (mem.(page), bitmaps.(page)) with
-    | (Some page_str, Some bitmap) -> Some (page_str, bitmap, idx)
-    | (None, None) -> None
-    | _ -> failwith "mem vs. bitmaps inconsistency in string_maybe_memory"
-      
+	idx = Int64.to_int (Int64.logand addr 0xfffL) in
+      match (mem.(page), bitmaps.(page)) with
+	| (Some page_str, Some bitmap) -> Some (page_str, bitmap, idx)
+	| (None, None) -> None
+	| _ -> failwith "mem vs. bitmaps inconsistency in string_maybe_memory"
+
   method private get_pages addr = 
     let page = Int64.to_int (Int64.shift_right addr 12) and
 	idx = Int64.to_int (Int64.logand addr 0xfffL) in
diff --git a/execution/exec_exceptions.ml b/execution/exec_exceptions.ml
index 75655d9..6b86cf7 100644
--- a/execution/exec_exceptions.ml
+++ b/execution/exec_exceptions.ml
@@ -13,7 +13,6 @@ exception KnownPath
 exception LastIteration
 exception NotConcrete of Vine.exp
 exception NullDereference
-exception UnsupportedAddress 
 exception ReachedInfluenceBound
 exception ReachedMeasurePoint
 exception Signal of string
diff --git a/execution/exec_exceptions.mli b/execution/exec_exceptions.mli
index 75655d9..6b86cf7 100644
--- a/execution/exec_exceptions.mli
+++ b/execution/exec_exceptions.mli
@@ -13,7 +13,6 @@ exception KnownPath
 exception LastIteration
 exception NotConcrete of Vine.exp
 exception NullDereference
-exception UnsupportedAddress 
 exception ReachedInfluenceBound
 exception ReachedMeasurePoint
 exception Signal of string
diff --git a/execution/exec_fuzzloop.ml b/execution/exec_fuzzloop.ml
index 680e470..24f0558 100644
--- a/execution/exec_fuzzloop.ml
+++ b/execution/exec_fuzzloop.ml
@@ -41,8 +41,6 @@ let loop_w_stats count fn =
 		     (ctime -. old_ctime) (ctime -. start_ctime));
 		(Printf.printf "Wall time %f sec, %f total\n"
 		   (wtime -. old_wtime) (wtime -. start_wtime)));
-	     if !opt_trace_completed_iterations then
-	       Printf.printf "Iteration %Ld completed\n%!" !iter;
 	     flush stdout;
 	     (match !opt_total_timeout with
 		| None -> ()
@@ -102,166 +100,6 @@ let fuzz start_eip opt_fuzz_start_eip end_eips
 	    fuzz_start_eip := eip;
 	    extra_setup := setup);
      fm#start_symbolic;
-     
-     let rec simple_loop n out_nargs type_name type_size =
-       let var_name = String.make 1 (Char.chr ((Char.code 'a') + n)) in
-       ignore(fm#get_fresh_symbolic (var_name^"_f_val") 64);
-       ignore(fm#get_fresh_symbolic (var_name^"_f"^type_name) type_size);
-       let var_val = fm#get_fresh_symbolic (var_name^"_val") 64 in
-       let var_type = fm#get_fresh_symbolic (var_name^type_name) type_size in
-       (*ignore(fm#get_fresh_symbolic (var_name^"_val") 64);*)
-       (*ignore(fm#get_fresh_symbolic (var_name^type_name) type_size);*)
-       let var_type_type = 
-	 if type_size = 1 then V.REG_1 
-	 else if type_size = 8 then V.REG_8
-	 else failwith "unsupported type_size in exec_fuzzloop#simple_loop"
-       in
-       let tmp_cond = 
-	 (if out_nargs > 0L then 
-	   V.BinOp(
-	     V.BITOR,
-	     V.BinOp(V.EQ,var_type,V.Constant(V.Int(var_type_type,1L))),
-	     V.BinOp(V.LT,var_val,V.Constant(V.Int(V.REG_64,out_nargs))))
-	 else (
-           V.BinOp(V.EQ,var_type,V.Constant(V.Int(var_type_type,1L)))
-	 )) in
-       opt_extra_conditions := tmp_cond :: !opt_extra_conditions;
-       (*Printf.printf "opt_extra_condition.length = %d n=%d out_nargs=%Lx tmp_cond = %s\n" 
-	 (List.length !opt_extra_conditions) n out_nargs (V.exp_to_string tmp_cond);*)
-       if n > 0 then simple_loop (n-1) out_nargs type_name type_size; 
-     in
-     let _ = (if (List.length !opt_synth_simplelen_adaptor) <> 0 then
-      (let (_,out_nargs,_,in_nargs,_) = List.hd !opt_synth_simplelen_adaptor in
-      simple_loop ((Int64.to_int in_nargs)-1) out_nargs "_type" 8)) 
-     in
-     (if ((List.length !opt_synth_adaptor) <> 0) then
-	 let (mode, _, out_nargs, _, in_nargs) = List.hd !opt_synth_adaptor in 
-       let rec chartrans_loop n = 
-	 let var_name = "tableX" ^ (Printf.sprintf "%02x" n) in
-	 ignore(fm#get_fresh_symbolic var_name 8);
-	 if n > -1 then chartrans_loop (n-1); in
-       if mode = "simple" 
-       then simple_loop ((Int64.to_int in_nargs)-1) out_nargs "_is_const" 1
-       else if mode = "typeconv"
-       then simple_loop ((Int64.to_int in_nargs)-1) out_nargs "_type" 8
-       else if (mode = "arithmetic_int")   
-       then (
-	 if (in_nargs <> 0L) then
-	   Adaptor_synthesis.arithmetic_int_extra_conditions
-	     fm out_nargs ((Int64.to_int in_nargs)-1);)
-       else if mode = "arithmetic_float"
-       then Adaptor_synthesis.arithmetic_float_extra_conditions
-         fm out_nargs ((Int64.to_int in_nargs)-1)
-       else if mode = "chartrans"
-       then chartrans_loop 255
-       else (Printf.printf "Unsupported adaptor mode\n"; flush stdout));
-     
-     let (t_n_fields, _, _) = !opt_struct_adaptor_params in 
-     for i=1 to t_n_fields do 
-       let f_type_str = Printf.sprintf "f%d_type" i in
-       let field_size_str = Printf.sprintf "f%d_size" i in
-       let field_n_str = Printf.sprintf "f%d_n" i in
-       let field_n = fm#get_fresh_symbolic field_n_str 16 in
-       let field_sz_sym = fm#get_fresh_symbolic field_size_str 16 in
-       let tmp_cond = (* f1_size == (1 || 2 || 4 || 8) *)
-	 V.BinOp(V.BITOR, 
-		 V.BinOp(V.EQ,field_sz_sym,V.Constant(V.Int(V.REG_16,1L))),
-		 V.BinOp(V.BITOR,
-			 V.BinOp(V.EQ,field_sz_sym,V.Constant(V.Int(V.REG_16,2L))),
-			 V.BinOp(V.BITOR,
-				 V.BinOp(V.EQ,field_sz_sym,V.Constant(V.Int(V.REG_16,4L))),
-				 V.BinOp(V.EQ,field_sz_sym,V.Constant(V.Int(V.REG_16,8L)
-				 )))))
-       in
-       opt_extra_conditions := tmp_cond :: !opt_extra_conditions;
-      
-       (* this target field cannot overlap with another target field *)
-       let f_type_sym = fm#get_fresh_symbolic f_type_str 64 in
-       let i_start_b = V.BinOp(V.RSHIFT, f_type_sym, 
-			       V.Constant(V.Int(V.REG_8, 32L))) in
-       let i_end_b = V.BinOp(
-	 V.BITAND, 
-	 V.Constant(V.Int(V.REG_64, 65535L)), 
-	 V.BinOp(V.RSHIFT, f_type_sym, 
-		 V.Constant(V.Int(V.REG_8, 16L)))) in
-       for j=1 to t_n_fields do
-	 if i <> j then (
-	   let f2_type_sym = fm#get_fresh_symbolic (Printf.sprintf "f%d_type" j) 64 in
-	   let j_start_b = V.BinOp(V.RSHIFT, f2_type_sym, 
-				   V.Constant(V.Int(V.REG_8, 32L))) in
-	   let j_end_b = V.BinOp(
-	     V.BITAND, V.Constant(V.Int(V.REG_64, 65535L)), 
-	     V.BinOp(V.RSHIFT, f2_type_sym, 
-		     V.Constant(V.Int(V.REG_8, 16L)))) in
-	   let expr_s_b = V.BinOp(V.BITAND, 
-				  V.BinOp(V.LE, j_start_b, i_start_b), 
-				  V.BinOp(V.LE, i_start_b, j_end_b  )) in
-	   let expr_e_b = V.BinOp(V.BITAND, 
-				  V.BinOp(V.LE, j_start_b, i_end_b), 
-				  V.BinOp(V.LE, i_end_b,   j_end_b)) in
-	   let tmp_cond2 = V.UnOp(V.NOT, V.BinOp(V.BITOR, expr_s_b, expr_e_b)) in
-	   Printf.printf "exec_fuzzloop adding tmp_cond2 = %s\n"
-	     (V.exp_to_string tmp_cond2);
-	   opt_extra_conditions := tmp_cond2 :: !opt_extra_conditions; 
-	 );
-       done; (* end for j *)
-      
-       (* end_byte must be >= start_byte *)
-       opt_extra_conditions := V.BinOp(V.LE, i_start_b, i_end_b) :: !opt_extra_conditions;
-      
-       (* i_end_b - i_start_b + 1 should be divisible by field_n *)
-       let i_bytes = V.BinOp(V.MINUS, 
-			     V.BinOp(
-			       V.PLUS, i_end_b, V.Constant(V.Int(V.REG_64, 1L))),
-			     i_start_b) in
-       let tmp_cond3 = V.BinOp(V.EQ, 
-			       V.BinOp(V.MOD, i_bytes, 
-				       V.Cast(V.CAST_UNSIGNED, V.REG_64, field_n)), 
-			       V.Constant(V.Int(V.REG_64, 0L))) in
-       Printf.printf "exec_fuzzloop adding tmp_cond3 = %s\n"
-	 (V.exp_to_string tmp_cond3);
-       opt_extra_conditions := tmp_cond3 :: !opt_extra_conditions; 
-       
-       (* (end_byte-start_byte+1)/n == 1, 2, 4, or 8 *)
-       let size_cond1 = V.BinOp(V.EQ, V.Constant(V.Int(V.REG_64, 1L)), 
-				       V.BinOp(V.DIVIDE, i_bytes, 
-					       V.Cast(
-						 V.CAST_UNSIGNED, V.REG_64, field_n))) in
-       let size_cond2 = V.BinOp(V.EQ, V.Constant(V.Int(V.REG_64, 2L)), 
-				       V.BinOp(V.DIVIDE, i_bytes, 
-					       V.Cast(
-						 V.CAST_UNSIGNED, V.REG_64, field_n))) in
-       let size_cond3 = V.BinOp(V.EQ, V.Constant(V.Int(V.REG_64, 4L)), 
-				       V.BinOp(V.DIVIDE, i_bytes, 
-					       V.Cast(
-						 V.CAST_UNSIGNED, V.REG_64, field_n))) in 
-       let size_cond4 = V.BinOp(V.EQ, V.Constant(V.Int(V.REG_64, 8L)), 
-				       V.BinOp(V.DIVIDE, i_bytes, 
-					       V.Cast(
-						 V.CAST_UNSIGNED, V.REG_64, field_n))) in
-       opt_extra_conditions := V.BinOp(V.BITOR, size_cond1, 
-				       V.BinOp(V.BITOR, size_cond2, 
-					       V.BinOp(V.BITOR, size_cond3, size_cond4)))
-       :: !opt_extra_conditions;
-      
-     done; (* end for i *)
-     
-     if (List.length !opt_synth_ret_adaptor) <> 0 then (
-       let (_, _, _, in_nargs) = List.hd !opt_synth_ret_adaptor in
-       let var_type = (fm#get_fresh_symbolic ("ret_type") 8) in
-       let var_val = (fm#get_fresh_symbolic ("ret_val") 64) in
-       if in_nargs > 0L then
-	 ( let tmp_cond = 
-	     V.BinOp(
-	       V.BITOR,
-	       V.BinOp(V.EQ,var_type,V.Constant(V.Int(V.REG_8,1L))),
-	       V.BinOp(V.LT,var_val,V.Constant(V.Int(V.REG_64,in_nargs)))) in
-	   opt_extra_conditions := tmp_cond :: !opt_extra_conditions;
-	 (*Printf.printf "opt_extra_condition.length = %d in_nargs=%Lx tmp_cond = %s\n" 
-	   (List.length !opt_extra_conditions) in_nargs (V.exp_to_string tmp_cond);*)
-	 );
-     );
-
      if !opt_trace_setup then
        (Printf.printf "Setting up symbolic values:\n"; flush stdout);
      symbolic_init ();
@@ -269,48 +107,6 @@ let fuzz start_eip opt_fuzz_start_eip end_eips
      fm#make_snap ();
      if !opt_trace_setup then
        (Printf.printf "Took snapshot\n"; flush stdout);
-
-     (* Populate hashtable of adaptor vars *)
-     let _ =
-       if !opt_trace_struct_adaptor then
-	 Printf.printf "adaptor_vals: Iterating through %d extra conditions\n" 
-	   (List.length !opt_extra_conditions);
-       List.iter ( fun cond ->
-	 (match cond with
-	 | V.BinOp(V.EQ,V.Lval(V.Temp((_, s, _))),
-		   V.Constant(V.Int(ty,value))) 
-	 | V.BinOp(V.EQ,V.Constant(V.Int(ty,value)),
-		   V.Lval(V.Temp((_, s, _)))) ->
-	   if !opt_trace_struct_adaptor then (
-	     if Hashtbl.mem Adaptor_synthesis.adaptor_vals s then 
-	       Printf.printf "adaptor_vals already had value for %s, panic!\n" s
-	     else Printf.printf "adding %s to adaptor_vals\n" s;);
-	   Hashtbl.replace Adaptor_synthesis.adaptor_vals s
-	     (V.Constant(V.Int(ty,value)))
-	 | _ -> ());
-       ) !opt_extra_conditions; 
-     in
-     if t_n_fields <> 0 then 
-       Adaptor_synthesis.create_field_ranges_l fm;
-     let field_ranges = Adaptor_synthesis.ranges_by_field_num in
-     for i = 1 to t_n_fields do
-       let f_type_str = Printf.sprintf "f%d_type" i in
-       let f_type_sym = fm#get_fresh_symbolic f_type_str 64 in
-       (* f_type should equal only one of the valid values *)
-       let constify a = V.Constant(V.Int(V.REG_64, a)) in
-       let or_list l = 
-	 match l with 
-	 | [] -> constify 0L
-	 | [a] -> constify a
-	 | e :: r -> List.fold_left (
-	   fun a b -> V.BinOp(V.BITOR, a, 
-			      (V.BinOp(V.EQ, f_type_sym, (constify b))))
-	 ) (V.BinOp(V.EQ, f_type_sym, (constify e))) r
-       in
-       let ranges = !((!field_ranges).(i)) in
-       opt_extra_conditions := (or_list ranges) :: !opt_extra_conditions;
-     done;
-
      (try
 	loop_w_stats !opt_num_paths
 	  (fun iter ->
@@ -331,7 +127,6 @@ let fuzz start_eip opt_fuzz_start_eip end_eips
 		  | DeepPath -> stop "on too-deep path"
 		  | SymbolicJump -> stop "at symbolic jump"
 		  | NullDereference -> stop "at null deref"
-		  | UnsupportedAddress -> stop "at access to unsupported address"
 		  | JumpToNull -> stop "at jump to null"
 		  | DivideByZero -> stop "at division by zero"
 		  | TooManyIterations -> stop "after too many loop iterations"
@@ -351,21 +146,7 @@ let fuzz start_eip opt_fuzz_start_eip end_eips
 		  | Signal("USR1") -> stop "on SIGUSR1"
 		  (* | NotConcrete(_) -> () (* shouldn't happen *)
 		     | Simplify_failure(_) -> () (* shouldn't happen *)*)
-	       );
-	       if (List.length !opt_match_syscalls_addr_range) <> 0 then
-		 if ((fm#match_syscalls ()) <> true)  ||
-		   ( ((fm#match_writes ()) <> true) && 
-		       (!opt_dont_compare_mem_se = false))
-		 then
-		   ((* too late to raise DisqualifiedPath *)
-		   let stop_eip = fm#get_eip in
-		   Printf.printf "Disqualified path at 0x%08Lx\n" stop_eip;);
-	       if (List.length !opt_synth_struct_adaptor) <> 0 then
-		 fm#reset_struct_counts;
-	       if (List.length !opt_match_syscalls_addr_range) <> 0 then
-		 fm#reset_syscalls ;
-	       if (List.length !opt_synth_ret_adaptor) <> 0 then
-		 fm#reset_saved_arg_regs ;
+	       ); 
 	       if !opt_coverage_stats && 
 		 (Hashtbl.length trans_cache - old_tcs > 0) then
 		   Printf.printf "Coverage increased to %d on %Ld\n"
diff --git a/execution/exec_options.ml b/execution/exec_options.ml
index 1d718c9..5eec798 100644
--- a/execution/exec_options.ml
+++ b/execution/exec_options.ml
@@ -93,8 +93,6 @@ let opt_trace_callstack = ref false
 let opt_trace_sym_addrs = ref false
 let opt_trace_sym_addr_details = ref false
 let opt_trace_syscalls = ref false
-let opt_match_syscalls_addr_range = ref []
-let opt_ret_zero_missing_x64_syscalls = ref false
 let opt_trace_detailed_ranges = ref []
 let opt_extra_conditions = ref []
 let opt_tracepoints = ref []
@@ -104,11 +102,6 @@ let opt_concrete_path_simulate = ref false
 let opt_concolic_prob = ref None
 let opt_solve_path_conditions = ref false
 let opt_trace_regions = ref false
-let opt_trace_struct_adaptor = ref false
-let opt_trace_mem_snapshots = ref false
-let opt_check_store_sequence = ref false
-let opt_dont_compare_mem_se = ref false
-let opt_dont_compare_syscalls = ref false
 let opt_check_for_null = ref false
 let opt_offset_strategy = ref UniformStrat
 let opt_concretize_divisors = ref false
@@ -116,15 +109,6 @@ let opt_trace_stopping = ref false
 let opt_trace_setup = ref false
 let opt_extra_env = Hashtbl.create 10
 let opt_skip_call_addr = ref []
-let opt_synth_adaptor = ref []
-let opt_synth_ret_adaptor = ref []
-let opt_synth_struct_adaptor = ref []
-let opt_struct_adaptor_params = ref (0,0,0)
-let opt_adaptor_search_mode  = ref false
-let opt_adaptor_ivc = ref false
-let opt_split_target_formulas = ref false
-let opt_synth_simplelen_adaptor = ref []
-let synth_extra_conditions = ref []
 let opt_skip_func_addr = ref []
 let opt_skip_call_addr_symbol = ref []
 let opt_skip_func_addr_symbol = ref []
@@ -136,7 +120,6 @@ let opt_trace_unique_eips = ref false
 let opt_trace_ir = ref false
 let opt_trace_orig_ir = ref false
 let opt_trace_iterations = ref false
-let opt_trace_completed_iterations = ref false
 let opt_coverage_stats = ref false
 let opt_gc_stats = ref false
 let opt_solver_stats = ref false
@@ -187,7 +170,6 @@ let opt_t_expr_size = ref 10
 
 let opt_symbolic_memory = ref false
 let opt_zero_memory = ref false
-let opt_region_limit = ref None
 let opt_random_memory = ref false
 
 let opt_fuzz_start_addr_count = ref 1
@@ -208,7 +190,7 @@ let opt_skip_untainted = ref false
 let opt_arch = ref X86
 let opt_trace_stmts = ref false
 let opt_trace_eval = ref false
-let opt_track_sym_usage = ref false
+let opt_trace_client_reqs = ref false
 
 let asmir_arch () =
   asmir_arch_of_execution_arch !opt_arch
@@ -220,104 +202,6 @@ let split_string char s =
   in
     (s1, s2)
 
-let add_delimited_simplelen_info opt char s = 
-  let rec loop arg_str =
-    try 
-      let delim_loc = String.index arg_str char in
-      let str1 = String.sub arg_str 0 delim_loc in
-      let str2 = String.sub arg_str (delim_loc + 1) 
-                   ((String.length arg_str) - delim_loc - 1) in
-      [str1] @ (loop str2)
-    with Not_found -> [arg_str]
-  in
-  let list_str = loop s in
-  opt := ((Int64.of_string (List.hd list_str)),
-   (Int64.of_string (List.nth list_str 1)), 
-   (Int64.of_string (List.nth list_str 2)), 
-   (Int64.of_string (List.nth list_str 3)), 
-   (Int64.of_string (List.nth list_str 4))) :: !opt
-
-let add_delimited_info_10 opt char s =
-  let rec loop arg_str =
-    try 
-      let delim_loc = String.index arg_str char in
-      let str1 = String.sub arg_str 0 delim_loc in
-      let str2 = String.sub arg_str (delim_loc + 1) 
-                   ((String.length arg_str) - delim_loc - 1) in
-      [(Int64.of_string str1)] @ (loop str2)
-    with Not_found -> [(Int64.of_string arg_str)]
-  in
-  let list_str = loop s in
-  opt := ((List.nth list_str 0), (List.nth list_str 1), (List.nth list_str 2), 
-	  (List.nth list_str 3), (List.nth list_str 4), (List.nth list_str 5),
-	  (List.nth list_str 6), (List.nth list_str 7), (List.nth list_str 8),
-	  (List.nth list_str 9))
-  :: !opt
-  
-let add_delimited_info opt char s =
-  let rec loop arg_str =
-    try 
-      let delim_loc = String.index arg_str char in
-      let str1 = String.sub arg_str 0 delim_loc in
-      let str2 = String.sub arg_str (delim_loc + 1) 
-                   ((String.length arg_str) - delim_loc - 1) in
-      [str1] @ (loop str2)
-    with Not_found -> [arg_str]
-  in
-  let list_str = loop s in
-  opt := ((List.hd list_str),
-   (Int64.of_string (List.nth list_str 1)), 
-   (Int64.of_string (List.nth list_str 2)), 
-   (Int64.of_string (List.nth list_str 3)), 
-   (Int64.of_string (List.nth list_str 4))) :: !opt
-
-let add_delimited_info_4 opt char s =
-  let rec loop arg_str =
-    try 
-      let delim_loc = String.index arg_str char in
-      let str1 = String.sub arg_str 0 delim_loc in
-      let str2 = String.sub arg_str (delim_loc + 1) 
-                   ((String.length arg_str) - delim_loc - 1) in
-      [str1] @ (loop str2)
-    with Not_found -> [arg_str]
-  in
-  let list_str = loop s in
-  opt := ((Int64.of_string (List.nth list_str 0)), 
-   (Int64.of_string (List.nth list_str 1)), 
-   (Int64.of_string (List.nth list_str 2)), 
-   (Int64.of_string (List.nth list_str 3))) :: !opt
-
-let add_delimited_info_s_i_i_i opt char s =
-  let rec loop arg_str =
-    try 
-      let delim_loc = String.index arg_str char in
-      let str1 = String.sub arg_str 0 delim_loc in
-      let str2 = String.sub arg_str (delim_loc + 1) 
-                   ((String.length arg_str) - delim_loc - 1) in
-      [str1] @ (loop str2)
-    with Not_found -> [arg_str]
-  in
-  let list_str = loop s in
-  opt := ((List.nth list_str 0), 
-   (Int64.of_string (List.nth list_str 1)), 
-   (Int64.of_string (List.nth list_str 2)), 
-   (Int64.of_string (List.nth list_str 3))) :: !opt
-
-let add_delimited_info_3 opt char s =
-  let rec loop arg_str =
-    try 
-      let delim_loc = String.index arg_str char in
-      let str1 = String.sub arg_str 0 delim_loc in
-      let str2 = String.sub arg_str (delim_loc + 1) 
-        ((String.length arg_str) - delim_loc - 1) in
-      [str1] @ (loop str2)
-    with Not_found -> [arg_str]
-  in
-  let list_str = loop s in
-  opt := (List.nth list_str 0, 
-   (Int64.of_string (List.nth list_str 1)), 
-   (Int64.of_string (List.nth list_str 2))) :: !opt
-
 let add_delimited_pair opt char s =
   let (s1, s2) = split_string char s in
     opt := ((Int64.of_string s1), (Int64.of_string s2)) :: !opt
@@ -334,19 +218,6 @@ let add_delimited_str_num_pair opt char s =
   let (s1, s2) = split_string char s in
     opt := (s1, (Int64.of_string s2)) :: !opt
 
-let add_delimited_int64_int_pair opt char s= 
-  let (s1, s2) = split_string char s in
-    opt := ((Int64.of_string s1), (int_of_string s2)) :: !opt
-
-let add_delimited_int_int_pair opt char s= 
-  let (s1, s2) = split_string char s in
-  opt := ((int_of_string s1), (int_of_string s2))
-
-let add_delimited_int_triple opt char s= 
-  let (s1, s2') = split_string char s in
-  let (s2, s3) = split_string char s2' in
-  opt := ((int_of_string s1), (int_of_string s2), (int_of_string s3))
-
 let opt_program_name = ref None
 let opt_start_addr = ref None
 let opt_argv = ref []
diff --git a/execution/exec_options.mli b/execution/exec_options.mli
index ea12a06..962b474 100644
--- a/execution/exec_options.mli
+++ b/execution/exec_options.mli
@@ -71,8 +71,6 @@ val opt_trace_callstack : bool ref
 val opt_trace_sym_addrs : bool ref
 val opt_trace_sym_addr_details : bool ref
 val opt_trace_syscalls : bool ref
-val opt_match_syscalls_addr_range : (int64 * int64 * int64 * int64 ) list ref
-val opt_ret_zero_missing_x64_syscalls : bool ref
 val opt_trace_detailed_ranges : (int64 * int64) list ref
 val opt_extra_conditions : Vine.exp list ref
 val opt_tracepoints : (int64 * string * Vine.exp) list ref
@@ -82,11 +80,6 @@ val opt_concrete_path_simulate : bool ref
 val opt_concolic_prob : float option ref
 val opt_solve_path_conditions : bool ref
 val opt_trace_regions : bool ref
-val opt_trace_struct_adaptor : bool ref
-val opt_trace_mem_snapshots : bool ref
-val opt_dont_compare_mem_se : bool ref
-val opt_dont_compare_syscalls : bool ref
-val opt_check_store_sequence : bool ref
 val opt_check_for_null : bool ref
 val opt_offset_strategy : offset_strategy ref
 val opt_concretize_divisors : bool ref
@@ -94,15 +87,6 @@ val opt_trace_stopping : bool ref
 val opt_trace_setup : bool ref
 val opt_extra_env : (string, string) Hashtbl.t
 val opt_skip_call_addr : (int64 * int64) list ref
-val opt_synth_adaptor : (string * int64 * int64 * int64 * int64) list ref
-val opt_synth_ret_adaptor : (string * int64 * int64 * int64) list ref
-val opt_synth_struct_adaptor : int64 list ref
-val opt_struct_adaptor_params : (int * int * int) ref
-val opt_adaptor_search_mode : bool ref
-val opt_adaptor_ivc : bool ref
-val opt_split_target_formulas : bool ref
-val opt_synth_simplelen_adaptor : (int64 * int64 * int64 * int64 * int64) list ref
-val synth_extra_conditions : Vine.exp list ref
 val opt_skip_func_addr : (int64 * int64) list ref
 val opt_skip_call_addr_symbol : (int64 * string) list ref
 val opt_skip_func_addr_symbol : (int64 * string) list ref
@@ -114,7 +98,6 @@ val opt_trace_unique_eips : bool ref
 val opt_trace_ir : bool ref
 val opt_trace_orig_ir : bool ref
 val opt_trace_iterations : bool ref
-val opt_trace_completed_iterations : bool ref
 val opt_coverage_stats : bool ref
 val opt_gc_stats : bool ref
 val opt_solver_stats : bool ref
@@ -164,7 +147,6 @@ val opt_narrow_bitwidth_cutoff : int option ref
 val opt_t_expr_size : int ref
 
 val opt_symbolic_memory : bool ref
-val opt_region_limit : int64 option ref
 val opt_zero_memory : bool ref
 val opt_random_memory : bool ref
 
@@ -186,37 +168,19 @@ val opt_skip_untainted : bool ref
 val opt_arch : execution_arch ref
 val opt_trace_stmts : bool ref
 val opt_trace_eval : bool ref
-val opt_track_sym_usage : bool ref
+val opt_trace_client_reqs : bool ref
 
 val asmir_arch : unit -> Asmir.arch
 
 val split_string : char -> string -> (string * string)
 val add_delimited_pair :
   (int64 * int64) list ref -> char -> string -> unit
-val add_delimited_info :
-  (string * int64 * int64 * int64 * int64) list ref -> char -> string -> unit
-val add_delimited_info_10:
-  (int64 * int64 * int64 * int64 * int64 * int64 * int64 * int64 * int64 * int64) list ref -> char -> string -> unit
-val add_delimited_info_4 :
-  (int64 * int64 * int64 * int64) list ref -> char -> string -> unit
-val add_delimited_info_s_i_i_i :
-  (string * int64 * int64 * int64) list ref -> char -> string -> unit
-val add_delimited_info_3 :
-  (string * int64 * int64 ) list ref -> char -> string -> unit
-val add_delimited_simplelen_info :
-  (int64 * int64 * int64 * int64 * int64) list ref -> char -> string -> unit
 val add_delimited_num_str_pair :
   (int64 * string) list ref -> char -> string -> unit
 val add_delimited_num_escstr_pair :
   (int64 * string) list ref -> char -> string -> unit
 val add_delimited_str_num_pair :
   (string * int64) list ref -> char -> string -> unit
-val add_delimited_int64_int_pair :
-  (int64 * int) list ref -> char -> string -> unit
-val add_delimited_int_int_pair :
-  (int * int) ref -> char -> string -> unit
-val add_delimited_int_triple:
-  (int * int * int) ref -> char -> string -> unit
 
 val opt_program_name : string option ref
 val opt_start_addr : int64 option ref
diff --git a/execution/exec_runloop.ml b/execution/exec_runloop.ml
index 0f88740..3f3a92a 100644
--- a/execution/exec_runloop.ml
+++ b/execution/exec_runloop.ml
@@ -32,257 +32,29 @@ let call_replacements fm last_eip eip =
 	 if ((canon_eip addr) = (canon_eip targ)) then Some (retval) else ret)
       None l
   in
-  let lookup_info targ l =
-    List.fold_left
-      (fun ret (str, addr1, val1, addr2, val2) -> 
-	 if ((canon_eip addr1) = (canon_eip targ)) then 
-           Some (str,val1,addr2,val2) 
-         else ret)
-      None l
-  in
-  let lookup_simple_len_info targ l = 
-    List.fold_left
-      (fun ret (addr1, val1, addr2, val2, len) ->
-	if ((canon_eip addr1) = (canon_eip targ)) then
-	  Some (val1,addr2,val2,len) 
-	else ret)
-      None l
-  in
-  let lookup_ret_info targ l = 
-    List.fold_left
-      (fun ret (str, addr1, addr2, nargs) ->
-	if ((canon_eip addr1) = (canon_eip targ)) || 
-	  ((canon_eip addr2) = (canon_eip targ)) then
-	  Some (str,addr1,addr2,nargs) 
-	else ret)
-      None l
-  in
     match ((lookup eip      !opt_skip_func_addr),
 	   (lookup eip      !opt_skip_func_addr_symbol),
 	   (lookup eip      !opt_skip_func_addr_region),
 	   (lookup last_eip !opt_skip_call_addr),
 	   (lookup last_eip !opt_skip_call_addr_symbol),
 	   (lookup last_eip !opt_skip_call_addr_symbol_once),
-	   (lookup last_eip !opt_skip_call_addr_region),
-	   (lookup_info last_eip !opt_synth_adaptor),
-	   (lookup_ret_info eip !opt_synth_ret_adaptor),
-	   (lookup_simple_len_info last_eip !opt_synth_simplelen_adaptor))
+	   (lookup last_eip !opt_skip_call_addr_region))
     with
-      | (None, None, None, None, None, None, None, None, None, None) -> None
-      | (Some sfa_val, None, None, None, None, None, None, None, None, None) ->
-	  Some (fun () -> fm#set_word_var ret_reg sfa_val; None)
-      | (None, Some sfas_sym, None, None, None, None, None, None, None, None) ->
-	  Some (fun () -> ignore(fm#set_word_reg_fresh_symbolic ret_reg sfas_sym); None)
-      | (None, None, Some sfar_sym, None, None, None, None, None, None, None) ->
-	  Some (fun () -> fm#set_reg_fresh_region ret_reg sfar_sym; None)
-      | (None, None, None, Some cfa_val, None, None, None, None, None, None) ->
-	  Some (fun () -> fm#set_word_var ret_reg cfa_val; None)
-      | (None, None, None, None, Some cfas_sym, None, None, None, None, None) ->
-	  Some (fun () -> ignore(fm#set_word_reg_fresh_symbolic ret_reg cfas_sym); None)
-      | (None, None, None, None, None, Some cfaso_sym, None, None, None, None) ->
-	  Some (fun () -> fm#set_word_reg_symbolic ret_reg cfaso_sym; None)
-      | (None, None, None, None, None, None, Some cfar_sym, None, None, None) ->
-	  Some (fun () -> fm#set_reg_fresh_region ret_reg cfar_sym; None)
-      | (None, None, None, None, None, None, None, 
-          Some (adaptor_mode,out_nargs,in_addr,in_nargs), None, None) ->
-          (*** simple adaptor ***)
-          if adaptor_mode = "simple" 
-          then Some (fun () -> 
-	    Adaptor_synthesis.simple_adaptor fm out_nargs in_nargs;
-	    fm#conc_mem_struct_adaptor false;
-	    fm#sym_region_struct_adaptor;
-            (Some in_addr))
-	  else if adaptor_mode = "typeconv"
-	  then Some (fun () -> 
-	    Adaptor_synthesis.typeconv_adaptor fm out_nargs in_nargs;
-	    fm#conc_mem_struct_adaptor false;
-	    fm#sym_region_struct_adaptor;
-	    (*Adaptor_synthesis.float_typeconv_adaptor fm out_nargs in_nargs;*)
-            (Some in_addr))
-	  (*** adaptor using trees of arithmetic (integer) expressions ***)
-          else if adaptor_mode = "arithmetic_int" 
-            then Some (fun () -> 
-              Adaptor_synthesis.arithmetic_int_adaptor fm out_nargs in_nargs;
-	      Adaptor_synthesis.struct_adaptor fm;
-              (Some in_addr))
-          (*** adaptor using trees of arithmetic (SSE floating point) expressions ***)
-          else if adaptor_mode = "arithmetic_float" 
-            then Some (fun () -> 
-              Adaptor_synthesis.arithmetic_float_adaptor fm out_nargs in_nargs;
-	      Adaptor_synthesis.struct_adaptor fm;
-              (Some in_addr))
-          (*** character translation adaptor ***)
-          else if adaptor_mode = "chartrans"
-	  then Some (fun () ->
-	    Printf.printf "running adaptor chartrans\n";
-	    let map_n fn n =
-	      let l = ref [] in
-	      for i = (n-1) downto 0 do
-		l := (fn i) :: !l
-	      done;
-	      !l
-	    in
-	    let get_adaptor_var index = 
-              let var_name = "tableX" ^ (Printf.sprintf "%02x" index) in
-              fm#get_fresh_symbolic var_name 8
-	    in
-	    let table = map_n (fun i -> get_adaptor_var i) 256
-	    in
-	    Printf.printf "table length = %d\n" (List.length table);
-	    let rec translate_bytes base_addr index =
-              if index >= 0L then
-                let byte_symb = fm#load_byte_symbolic (Int64.add base_addr index) in
-                let byte_expr = fm#make_table_lookup table byte_symb 8 V.REG_8 in
-                fm#store_byte_symbolic (Int64.add base_addr index) 
-		  (V.BinOp(V.PLUS, byte_symb, byte_expr));
-                translate_bytes base_addr (Int64.pred index)
-            in
-            (* Assuming we are running on X86_64 *)
-            let base_addr = fm#get_long_var R_RDI in
-            translate_bytes base_addr (Int64.pred in_nargs);
-	    (Some in_addr))
-            (*** other adaptors ***)
-          else if adaptor_mode = "string" 
-          then Some (fun () ->
-            Printf.printf "string adaptor not supported yet";
-            (Some in_addr))
-	  else Some (fun () ->
-            Printf.printf "unsupported adaptor";
-            (Some in_addr))
-      | (None, None, None, None, None, None, None, None, 
-          Some (adaptor_mode, addr1, addr2, in_nargs), None) ->
-	if (adaptor_mode = "return-typeconv") && addr2 = eip then
-        Some (fun () -> 
-	  Adaptor_synthesis.ret_typeconv_adaptor fm in_nargs;
-          (Some addr2))
-	else if (adaptor_mode = "return-typeconv") && addr1 = eip then
-        Some (fun () -> 
-	  Printf.printf "exec_runloop#thunk() should save arg regs here\n";
-	  fm#save_arg_regs in_nargs;
-          (Some addr1))
-	else if (adaptor_mode = "return-simple+len") && addr2 = eip then
-          Some (fun () ->
-		  Adaptor_synthesis.ret_simplelen_adaptor fm in_nargs;
-		  (Some addr2))
-	else if (adaptor_mode = "return-simple+len") && addr1 = eip then
-          Some (fun () ->
-		  fm#save_arg_regs in_nargs;
-		  (Some addr1))
-	else Some (fun () ->
-          Printf.printf "unsupported adaptor\n";
-          (Some eip))
-      | (None, None, None, None, None, None, None, None, None,
-	 Some (out_nargs, in_addr, in_nargs, max_depth)) ->
-	  (* an adaptor that tries permutations of arguments as well as 
-	     permutations of length of other arguments
-	     var_type is used as follows:
-	     1: a constant value in var_val is used
-	     0: the argument corresponding to var_val is plugged in
-	     any other value: the length of the argument corresponding 
-	     to var_val is plugged in*)
-         Some (fun () -> 
-	   Printf.printf "Running simple+len adaptor in call_replacements\n";
-	   (* Assuming we are running on X86_64 *)
-           let arg_regs = [R_RDI;R_RSI;R_RDX;R_RCX;R_R8;R_R9] in
-	   (*let lower_bound = 0L in
-	     let upper_bound = (Int64.sub (Int64.shift_left 1L 31) 1L) in*)
-           let get_ite_expr if_arg if_op if_const_type if_const 
-               then_val else_val = 
-             V.Ite(
-               V.BinOp(if_op,if_arg,V.Constant(V.Int(if_const_type, if_const))),
-               then_val,
-               else_val)
-           in
-           let rec get_ite_arg_expr arg_val n_arg =
-             if n_arg <> 1L then
-               get_ite_expr arg_val V.EQ V.REG_64 (Int64.sub n_arg 1L) 
-                 (fm#get_reg_symbolic 
-                    (List.nth arg_regs ((Int64.to_int n_arg)-1)))
-                 (get_ite_arg_expr arg_val (Int64.sub n_arg 1L))
-             else
-               (fm#get_reg_symbolic (List.nth arg_regs 0))
-           in
-	   let rec get_len_expr n_arg pos =
-	     let base_addr = fm#get_long_var 
-	       (List.nth arg_regs (Int64.to_int n_arg)) in
-             (*Printf.printf 
-	       "get_len_expr n_arg = %Lx pos = %Ld base_addr = %Lx\n" 
-		n_arg pos base_addr;*)
-	     let b = (fm#load_byte_symbolic (Int64.add base_addr pos)) in
-	     if pos < max_depth then
-	       get_ite_expr b V.EQ V.REG_8 0L 
-		 (V.Constant(V.Int(V.REG_64,0L)))
-		 (V.BinOp(V.PLUS,V.Constant(V.Int(V.REG_64,1L)),
-			  (get_len_expr n_arg (Int64.succ pos))))
-	     else
-	       get_ite_expr b V.EQ V.REG_8 0L
-		 (V.Constant(V.Int(V.REG_64,0L)))
-		 (V.Constant(V.Int(V.REG_64,1L)))
-	   in
-	   let rec get_ite_len_expr arg_val n_arg =
-	     if n_arg <> 1L then
-	       get_ite_expr arg_val V.EQ V.REG_64 (Int64.sub n_arg 1L)
-		 (get_len_expr (Int64.sub n_arg 1L) 0L)
-		 (get_ite_len_expr arg_val (Int64.sub n_arg 1L))
-	     else 
-		(get_len_expr 0L 0L)
-	   in
-	   (*let restrict_range node_type node_val lower upper =
-             V.BinOp(
-             V.BITOR,
-             V.BinOp(V.NEQ, node_type, V.Constant(V.Int(V.REG_8, 1L))),
-             V.BinOp(
-             V.BITAND, 
-             V.UnOp(V.NOT, 
-             V.BinOp(V.LT, node_val, V.Constant(V.Int(V.REG_64, lower)))),
-             V.BinOp(V.LE, node_val, V.Constant(V.Int(V.REG_64, upper)))))
-	     in*)
-           let symbolic_args = ref [] in
-	   let rec loop n =
-             let var_name = String.make 1 (Char.chr ((Char.code 'a') + n)) in
-	     (*Printf.printf "loop var_name = %s\n" var_name;*)
-             let var_type = 
-               fm#get_fresh_symbolic (var_name^"_type") 8 in
-             let var_val = fm#get_fresh_symbolic (var_name^"_val") 64 in
-             let arg = get_ite_expr var_type V.EQ V.REG_8 1L var_val 
-	       (get_ite_expr var_type V.EQ V.REG_8 0L (get_ite_arg_expr var_val out_nargs)
-		  (get_ite_len_expr var_val out_nargs)) in
-	     (*Printf.printf "call_replacements thunk() exp=%s\n" (V.exp_to_string arg);*)
-             opt_extra_conditions :=
-               V.BinOp(
-                 V.BITOR,
-                 V.BinOp(V.EQ,var_type,V.Constant(V.Int(V.REG_8,1L))),
-                 V.BinOp(V.LT,var_val,V.Constant(V.Int(V.REG_64,out_nargs))))
-	     (*:: (restrict_range var_type var_val lower_bound upper_bound)*)
-             :: !opt_extra_conditions;
-	     symbolic_args := arg :: !symbolic_args;
-             if n > 0 then loop (n-1); 
-           in
-           loop ((Int64.to_int in_nargs)-1);
-	   (*Printf.printf "symbolic_args length=%d\n" (List.length !symbolic_args);*)
-	   List.iteri (fun index expr ->
-	     fm#set_reg_symbolic (List.nth arg_regs index) expr;) !symbolic_args;
-	   let rec decision_loop n = 
-             let var_name = String.make 1 (Char.chr ((Char.code 'a') + n)) in
-	     (*Printf.printf "decision_loop var_name = %s\n" var_name;*)
-             let var_type = 
-               fm#get_fresh_symbolic (var_name^"_type") 8 in
-	     let (b1,_) = fm#query_condition (V.BinOp(
-	       V.BITAND,
-	       V.BinOp(V.NEQ,var_type,V.Constant(V.Int(V.REG_8,0L))),
-	       V.BinOp(V.NEQ,var_type,V.Constant(V.Int(V.REG_8,1L))))) None (0x6c00+n*10+1) in
-	     (*Printf.printf "Chose b1 = %B\n" b1;*)
-	     if b1 <> true then
-	       ((*let b2 = *)
-		 ignore(fm#query_condition (
-		 V.BinOp(V.NEQ,var_type,V.Constant(V.Int(V.REG_8,1L)))) None (0x6c00+n*10))
-		(*in
-		  Printf.printf "Chose b2 = %B\n" b2;*));
-	     if n > 0 then decision_loop (n-1);
-	   in
-	   decision_loop ((Int64.to_int in_nargs)-1);
-	   Adaptor_synthesis.struct_adaptor fm;
-           (Some in_addr))
+      | (None, None, None, None, None, None, None) -> None
+      | (Some sfa_val, None, None, None, None, None, None) ->
+	  Some (fun () -> set_reg_conc ret_reg sfa_val)
+      | (None, Some sfas_sym, None, None, None, None, None) ->
+	  Some (fun () -> ignore(set_reg_fresh ret_reg sfas_sym))
+      | (None, None, Some sfar_sym, None, None, None, None) ->
+	  Some (fun () -> fm#set_reg_fresh_region ret_reg sfar_sym)
+      | (None, None, None, Some cfa_val, None, None, None) ->
+	  Some (fun () -> set_reg_conc ret_reg cfa_val)
+      | (None, None, None, None, Some cfas_sym, None, None) ->
+	  Some (fun () -> ignore(set_reg_fresh ret_reg cfas_sym))
+      | (None, None, None, None, None, Some cfaso_sym, None) ->
+	  Some (fun () -> set_reg_sym ret_reg cfaso_sym)
+      | (None, None, None, None, None, None, Some cfar_sym) ->
+	  Some (fun () -> fm#set_reg_fresh_region ret_reg cfar_sym)
       | _ -> failwith "Contradictory replacement options"
 
 let loop_detect = Hashtbl.create 1000
@@ -355,46 +127,15 @@ let rec runloop (fm : fragment_machine) eip asmir_gamma until =
       let prog' = match call_replacements fm last_eip eip with
 	| None -> prog
 	| Some thunk ->
-	  let fake_insn = match (!opt_arch, 
-                                 (Int64.logand eip 1L), thunk ()) with
-	    | (X86, _,_) -> [|'\xc3'|] (* ret *)
-	    | (X64, _,None) -> [|'\xc3'|] (* ret *)
-	    | (X64, _,Some addr) ->  (* Jump to the inner function *)
-	      if addr <> eip then (
-		let in_addr = addr in
-		let temp = (Int64.sub in_addr eip) in
-		let offset = (Int64.sub temp 5L) in
-		let offset_byte_0 = (Int64.logand offset 255L) in
-		let offset_byte_1 = 
-		  (Int64.shift_right_logical 
-		     (Int64.logand offset (Int64.shift_left 255L 8)) 8) in
-		let offset_byte_2 = 
-		  (Int64.shift_right_logical 
-		     (Int64.logand offset (Int64.shift_left 255L 16)) 16) in
-		let offset_byte_3 = 
-		  (Int64.shift_right_logical 
-		     (Int64.logand offset (Int64.shift_left 255L 24)) 24) in
-		let offset_char_arr = [|(char_of_int (Int64.to_int offset_byte_0));
-					(char_of_int (Int64.to_int offset_byte_1));
-					(char_of_int (Int64.to_int offset_byte_2));
-					(char_of_int (Int64.to_int offset_byte_3))|] in
-	      (*Printf.printf "eip %Lx:jumping to adapter %Lx using offset %Lx\n" 
-		eip in_addr offset;*)
-              (*Array.iter 
-                ( function ele -> Printf.printf "%Lx\n" (Int64.of_int (Char.code ele))) offset_char_arr;*)
-		Array.append [|'\xe9'|] offset_char_arr)
-	      else (* noop because this was a return value adaptor *)
-		(
-		  (* Printf.printf "nooping because no call replacement required\n"; *)
-		  [||]
-		)
-	    | (ARM, 0L,_) -> [|'\x1e'; '\xff'; '\x2f'; '\xe1'|] (* bx lr *)
-	    | (ARM, 1L,_) -> [|'\x70'; '\x47'|] (* bx lr (Thumb) *)
-	    | (ARM, _,_) -> failwith "Can't happen (logand with 1)"
-	  in
-	  if (Array.length fake_insn) <> 0 then
-	    decode_insn asmir_gamma eip fake_insn
-	  else prog
+	    thunk ();
+	    let fake_ret = match (!opt_arch, (Int64.logand eip 1L)) with
+	      | (X86, _) -> [|'\xc3'|] (* ret *)
+	      | (X64, _) -> [|'\xc3'|] (* ret *)
+	      | (ARM, 0L) -> [|'\x1e'; '\xff'; '\x2f'; '\xe1'|] (* bx lr *)
+	      | (ARM, 1L) -> [|'\x70'; '\x47'|] (* bx lr (Thumb) *)
+	      | (ARM, _) -> failwith "Can't happen (logand with 1)"
+	    in
+	      decode_insn asmir_gamma eip fake_ret
       in
 	if !opt_trace_insns then
 	  print_insns eip prog' None '\n';
@@ -414,6 +155,6 @@ let rec runloop (fm : fragment_machine) eip asmir_gamma until =
 	      | (e1, e2, _) when e2 e1 -> ()
 	      | (0L, _, _) -> raise JumpToNull
 	      | _ -> loop eip new_eip false (Int64.succ num_insns_executed)
-    in
+  in
     Hashtbl.clear loop_detect;
     loop (0L) eip false 1L
diff --git a/execution/exec_set_options.ml b/execution/exec_set_options.ml
index a27f056..d63f6be 100644
--- a/execution/exec_set_options.ml
+++ b/execution/exec_set_options.ml
@@ -162,12 +162,10 @@ let concrete_state_cmdline_opts =
      "addr=val Set 64-bit location to a concrete value");
     ("-skip-call-ret", Arg.String
        (add_delimited_pair opt_skip_call_addr '='),
-     "addr=retval Replace the call at address 'addr' with a nop, and "^
-     "return 'retval' in EAX");
+     "addr=retval Replace the call at address 'addr' with a nop, and return 'retval' in EAX");
     ("-skip-func-ret", Arg.String
        (add_delimited_pair opt_skip_func_addr '='),
-     "addr=retval Replace the function at address 'addr' with a nop, and "^
-     "return 'retval' in EAX");
+     "addr=retval Replace the function at address 'addr' with a nop, and return 'retval' in EAX");
   ]
 
 let symbolic_state_cmdline_opts =
@@ -219,32 +217,6 @@ let symbolic_state_cmdline_opts =
     ("-skip-call-ret-symbol-once", Arg.String
        (add_delimited_num_str_pair opt_skip_call_addr_symbol_once '='),
      "addr=symname Like -s-c-r-s, but always the same variable");
-    ("-synthesize-adaptor", Arg.String
-      (add_delimited_info opt_synth_adaptor ':'),
-     "string:addr1:nargs1:addr2:nargs2 Using adaptor of type 'string', "^
-       "replace the outer function call at 'addr1' "^
-       "which takes 'nargs1' arguments with a call to function at "^
-       "address 'addr2' which uses 'nargs2' arguments");
-    ("-synthesize-simple+len-adaptor", Arg.String 
-      (add_delimited_simplelen_info opt_synth_simplelen_adaptor ':'),
-     "addr1:nargs1:addr2:nargs2:length Using the simple+length adaptor, "^
-       "replace the outer function call at 'addr1' "^
-       "which takes 'nargs1' arguments with a call to function at "^
-       "address 'addr2' which users 'nargs2' arguments");
-    ("-synthesize-return-adaptor", Arg.String
-      (add_delimited_info_s_i_i_i opt_synth_ret_adaptor ':'),
-     "string:addr1:addr2:N Using adaptor of type 'string', "^
-       "save N argument registers at addr1, " ^
-       "replace the return value at instruction with address 'addr2' "^
-       "with an adaptor symbolic formula ");
-    ("-synthesize-struct-adaptor", Arg.String
-      (fun s -> opt_synth_struct_adaptor := !opt_synth_struct_adaptor @ [(Int64.of_string s)];),
-     "addr Using structure adaptor grammar, "^
-       "write formulae at upto size bytes at addr");
-    ("-struct-adaptor-params", Arg.String
-      (add_delimited_int_triple opt_struct_adaptor_params ':'),
-     "N1:N2:size  Structure adaptor will try to map upto N1 fields in target and "^
-       "N2 fields in inner structures at upto size bytes");
   ]
 
 let slurp_file fname =
@@ -311,13 +283,6 @@ let explore_cmdline_opts =
     ("-insn-limit", Arg.String
        (fun s -> opt_insn_limit := Int64.of_string s),
      "N Stop path after N instructions");
-    ("-region-limit", Arg.String 
-      (fun s -> opt_region_limit := Some (Int64.of_string s)),
-     "N Treat only the first N bytes in a region as symbolic " ^
-       "and everything else as containing zero");
-    ("-check-store-sequence", Arg.Set(opt_check_store_sequence),
-     " Track concrete addresses written to by f1, f2 and disqualify paths "^
-       "on which the sequence of concrete addresses diverge between f1 and f2");
     ("-path-depth-limit", Arg.String
        (fun s -> opt_path_depth_limit := Int64.of_string s),
      "N Stop path after N bits of symbolic branching");
@@ -340,8 +305,6 @@ let explore_cmdline_opts =
      " Print operation of PRNG 'random' choices");
     ("-trace-sym-addr-details", Arg.Set(opt_trace_sym_addr_details),
      " Print even more about symbolic address values");
-    ("-track-sym-usage", Arg.Set(opt_track_sym_usage),
-     " Print uses of symbolic registers");
     ("-coverage-stats", Arg.Set(opt_coverage_stats),
      " Print pseudo-BB coverage statistics");
     ("-offset-strategy", Arg.String
@@ -481,18 +444,12 @@ let cmdline_opts =
      " Enable several common trace and stats options");
     ("-trace-binary-paths", Arg.Set(opt_trace_binary_paths),
      " Print decision paths as bit strings");
+    ("-trace-client-reqs", Arg.Set(opt_trace_client_reqs),
+     " Print Valgrind-style client requests");
     ("-trace-conditions", Arg.Set(opt_trace_conditions),
      " Print branch conditions");
     ("-trace-decisions", Arg.Set(opt_trace_decisions),
      " Print symbolic branch choices");
-    ("-split-target-formulas", Arg.Set(opt_split_target_formulas),
-     " Split large formulas when generating formulas for target structure fields, "^
-       "will be false if left unspecified");
-    ("-adaptor-search-mode", Arg.Set(opt_adaptor_search_mode),
-     " Run in adaptor search mode, FuzzBALL will run in counter example mode"^
-       " if left unspecified");
-    ("-adaptor-ivc", Arg.Set(opt_adaptor_ivc),
-     " Run implied value concretization on adaptor formulas");
     ("-trace-detailed",
      (Arg.Unit
 	(fun () ->
@@ -524,8 +481,6 @@ let cmdline_opts =
      " Print Vine IR as produced by Asmir");
     ("-trace-iterations", Arg.Set(opt_trace_iterations),
      " Print iteration count");
-    ("-trace-completed-iterations", Arg.Set(opt_trace_completed_iterations),
-     " Print iteration count at completion");
     ("-trace-loads", Arg.Set(opt_trace_loads),
      " Print each memory load");
     ("-trace-stores", Arg.Set(opt_trace_stores),
@@ -534,14 +489,6 @@ let cmdline_opts =
      " Print calls and returns");
     ("-trace-regions", Arg.Set(opt_trace_regions),
      " Print symbolic memory regions");
-    ("-trace-struct-adaptor", Arg.Set(opt_trace_struct_adaptor),
-     " Print formulae created by the structure adaptor");
-    ("-trace-memory-snapshots", Arg.Set(opt_trace_mem_snapshots),
-     " Print memory snapshot/reset operations");
-    ("-dont-compare-memory-sideeffects", Arg.Set(opt_dont_compare_mem_se),
-     " Dont compare side-effects on concrete memory and symbolic regions");
-    ("-dont-compare-linux-syscalls", Arg.Set(opt_dont_compare_syscalls),
-     " Dont compare system call sequences of f1, f2 for equality");
     ("-trace-registers", Arg.Set(opt_trace_registers),
      " Print register contents");
     ("-trace-setup", Arg.Set(opt_trace_setup),
@@ -675,6 +622,9 @@ let apply_cmdline_opts_early (fm : Fragment_machine.fragment_machine) dl =
   else
     fm#make_regs_zero;
   fm#add_special_handler
+    ((new Special_handlers.vg_client_req_special_handler fm)
+     :> Fragment_machine.special_handler);
+  fm#add_special_handler
     ((new Special_handlers.trap_special_nonhandler fm)
      :> Fragment_machine.special_handler);
   fm#add_special_handler
@@ -750,9 +700,7 @@ let make_symbolic_init (fm:Fragment_machine.fragment_machine)
        max_input_string_length :=
 	 max (!max_input_string_length) (Int64.to_int i)
      in
-       (* Dont set opt_extra_conditions here because it may contain 
-	  adaptor conditions *)
-       (* opt_extra_conditions := []; *)
+       opt_extra_conditions := [];
        List.iter (fun (base, len) ->
 		    new_max len;
 		    fm#make_symbolic_region base (Int64.to_int len))
@@ -815,9 +763,7 @@ let make_symbolic_init (fm:Fragment_machine.fragment_machine)
 	   !opt_target_region_formula_strings;
        opt_extra_conditions := !opt_extra_conditions @ 
 	 List.map (fun s -> fm#parse_symbolic_expr s)
-	   !opt_extra_condition_strings;
-	 opt_extra_conditions := !opt_extra_conditions
-       @ !synth_extra_conditions)
+	   !opt_extra_condition_strings)
 
 let decide_start_addrs () =
   let (start_addr, fuzz_start) = match
diff --git a/execution/formula_manager.ml b/execution/formula_manager.ml
index b957756..3c6ce15 100644
--- a/execution/formula_manager.ml
+++ b/execution/formula_manager.ml
@@ -164,15 +164,6 @@ struct
 
     method get_input_vars = Hashtbl.fold (fun s v l -> v :: l) input_vars []
 
-    val special_ec_vars = V.VarHash.create 0
-    method add_special_ec_var var_name var_val_exp =
-      V.VarHash.replace special_ec_vars var_name 
-	(D.from_symbolic var_val_exp);
-      (*Printf.printf "add_special_ec_var added exp=%s\n"
-	(V.exp_to_string var_val_exp);
-      Printf.printf "add_special_ec_var special_ec_vars.length=%d\n"
-	(V.VarHash.length special_ec_vars);*)
-
     val region_base_vars = Hashtbl.create 30
 
     method fresh_region_base s =
@@ -388,49 +379,16 @@ struct
 	      V.Lval(V.Temp(self#mem_var region_str ty2 addr)))
 	| _ -> failwith "Bad expression in rewrite_mem_expr"
 
-    (* subexpression cache *)
-    val subexpr_to_temp_var_info = Hashtbl.create 1001
-    val temp_var_num_to_subexpr = Hashtbl.create 1001
-    val mutable temp_var_num = 0
-
-    val temp_var_num_evaled = Hashtbl.create 1001
-
-    method rewrite_special_ec_vars e =
-      (*Printf.printf "rewrite_special_ec_vars before loop=%s\n" (V.exp_to_string e);*)
-      let rec loop e =
-	(*Printf.printf "rewrite_special_ec_vars within loop=%s\n" (V.exp_to_string e);*)
-	match e with
-	  | V.BinOp(op, e1, e2) -> V.BinOp(op, (loop e1), (loop e2))
-	  | V.Lval(V.Temp(var)) when V.VarHash.mem special_ec_vars var -> 
-	    ((*Printf.printf "rewrite_special_ec_vars V.Lval(V.Temp(_)) \
-when special_ec_vars\n"; *)
-	     (D.to_symbolic_64 (V.VarHash.find special_ec_vars var)))
-	  | V.Ite(ce, te, fe) ->
-	      V.Ite((loop ce), (loop te), (loop fe))
-	  | _ -> e
-      in
-      let ret = loop e in
-      (*Printf.printf "rewrite_special_ec_vars after loop=%s\n" (V.exp_to_string ret);*)
-      ret
-
     method rewrite_for_solver e =
-      (*Printf.printf "rewrite_for_solver before loop=%s\n" (V.exp_to_string e);*)
       let rec loop e =
-	(*Printf.printf "rewrite_for_solver within loop=%s\n" (V.exp_to_string e);*)
 	match e with
 	  | V.BinOp(op, e1, e2) -> V.BinOp(op, (loop e1), (loop e2))
 	  | V.FBinOp(op, rm, e1, e2) -> V.FBinOp(op, rm, (loop e1), (loop e2))
 	  | V.UnOp(op, e1) -> V.UnOp(op, (loop e1))
 	  | V.FUnOp(op, rm, e1) -> V.FUnOp(op, rm, (loop e1))
-	  | V.Constant(_) -> 
-	    ((*Printf.printf "rewrite_for_solver V.Constant(_)\n";*)
-	     e)
-	  | V.Lval(V.Temp(_)) -> 
-	    ((*Printf.printf "rewrite_for_solver V.Lval(V.Temp(_))\n"; *)
-	     e)
-	  | V.Lval(V.Mem(_, _, _)) -> 
-	    ((*Printf.printf "rewrite_for_solver V.Lval(V.Mem(_,_,_))\n";*)
-	     self#rewrite_mem_expr e)
+	  | V.Constant(_) -> e
+	  | V.Lval(V.Temp(_)) -> e
+	  | V.Lval(V.Mem(_, _, _)) -> self#rewrite_mem_expr e
 	  | V.Name(_) -> e
 	  | V.Cast(kind, ty, e1) -> V.Cast(kind, ty, (loop e1))
 	  | V.FCast(kind, rm, ty, e1) -> V.FCast(kind, rm, ty, (loop e1))
@@ -442,9 +400,7 @@ when special_ec_vars\n"; *)
 	  | V.Ite(ce, te, fe) ->
 	      V.Ite((loop ce), (loop te), (loop fe))
       in
-      let ret = loop e in
-      (*Printf.printf "rewrite_for_solver after loop=%s\n" (V.exp_to_string ret);*)
-      ret
+	loop e
 
     method get_mem_axioms =
       let of_type ty ((n,s,ty'),e) = (ty = ty') in
@@ -533,6 +489,13 @@ when special_ec_vars\n"; *)
 
 	  | _ -> failwith "unexpected lval expr in eval_var"
 
+    (* subexpression cache *)
+    val subexpr_to_temp_var_info = Hashtbl.create 1001
+    val temp_var_num_to_subexpr = Hashtbl.create 1001
+    val mutable temp_var_num = 0
+
+    val temp_var_num_evaled = Hashtbl.create 1001
+
     method eval_expr e =
       let rec loop e =
 	match e with
@@ -725,8 +688,6 @@ when special_ec_vars\n"; *)
 	  Hashtbl.find temp_vars_unweak var
 
     method private make_temp_var e ty =
-      (*Printf.printf "formula_manager.ml#make_temp_var e=%s\n"
-	(V.exp_to_string e);*)
       let cleanup_temp_var (n, s, t) =
 	let (e_enc, _) = Hashtbl.find temp_var_num_to_subexpr n in
 	  Hashtbl.remove temp_var_num_to_subexpr n;
@@ -776,12 +737,12 @@ when special_ec_vars\n"; *)
 	       V.Lval(V.Temp(self#make_temp_var e' ty))
 	) v
 
-    method private tempify_e e ty =
-      let e' = simplify_fp e in
-	V.Lval(V.Temp(self#make_temp_var e' ty))
-
     method private tempify (v:D.t) ty =
-      D.inside_symbolic (fun e -> self#tempify_e e ty) v
+      D.inside_symbolic
+	(fun e ->
+	   let e' = simplify_fp e in
+	     V.Lval(V.Temp(self#make_temp_var e' ty))
+	) v
 
     method simplify1  e = self#simplify e V.REG_1
     method simplify8  e = self#simplify e V.REG_8
@@ -792,8 +753,7 @@ when special_ec_vars\n"; *)
     method simplify_with_callback f (v:D.t) ty =
       D.inside_symbolic
 	(fun e ->
-	  let e_replaced = e in (*self#rewrite_special_ec_vars e in*)
-	  let e2 = simplify_fp e_replaced in
+	   let e2 = simplify_fp e in
 	     match e2 with
 	       | V.Constant(_) -> e2
 	       | _ -> 
@@ -803,124 +763,9 @@ when special_ec_vars\n"; *)
 			  (if expr_size e2 < !opt_t_expr_size then
 			     e2
 			   else
-			      (V.Lval(V.Temp(self#make_temp_var e2 ty)))))
+			     V.Lval(V.Temp(self#make_temp_var e2 ty))))
 	) v
 
-    val usage_tracked_syms = V.VarHash.create 31
-
-    method fresh_symbolic_tracked_32 s =
-      let v = self#fresh_symbolic_var s V.REG_32 in
-	V.VarHash.replace usage_tracked_syms v v;
-	D.from_symbolic (V.Lval(V.Temp(v)))
-
-    method fresh_symbolic_tracked_64 s =
-      let v = self#fresh_symbolic_var s V.REG_64 in
-	V.VarHash.replace usage_tracked_syms v v;
-	D.from_symbolic (V.Lval(V.Temp(v)))
-
-    val cached_sym_usage = V.VarHash.create 1001
-
-    method private find_sym_usage e =
-      let union = Vine_util.list_union in
-      let rec loop e =
-	match e with
-	  | V.Lval(V.Temp(var)) ->
-	      (try
-		 V.VarHash.find cached_sym_usage var
-	       with Not_found ->
-		 let usage =
-		   try
-		     [V.VarHash.find usage_tracked_syms var]
-		   with Not_found ->
-		     if_expr_temp self var
-		       (fun e -> loop e) [] (fun _ -> ())
-		 in
-		   V.VarHash.replace cached_sym_usage var usage;
-		   usage)
-	  | V.BinOp(_, e1, e2) -> union (loop e1) (loop e2)
-	  | V.FBinOp(_, _, e1, e2) -> union (loop e1) (loop e2)
-	  | V.UnOp(_, e1) -> loop e1
-	  | V.FUnOp(_, _, e1) -> loop e1
-	  | V.Constant(_) -> []
-	  | V.Lval(V.Mem(_, e1, _)) -> loop e1
-	  | V.Name(_) -> []
-	  | V.Cast(_, _, e1) -> loop e1
-	  | V.FCast(_, _, _, e1) -> loop e1
-	  | V.Unknown(_) -> []
-	  | V.Let(_, e1, e2) -> union (loop e1) (loop e2)
-	  | V.Ite(e1, e2, e3) -> union (loop e1) (union (loop e2) (loop e3))
-      in
-	loop e
-
-    val usage_seen = V.VarHash.create 31
-
-    method check_sym_usage e str skip_if_simple query_cb =
-      match (skip_if_simple, e) with
-	| (true, V.Lval(V.Temp(var)))
-	    when V.VarHash.mem usage_tracked_syms var ->
-	    Printf.printf "Ignoring simple occurrence in %s\n" str
-	| _ ->
-	    let usage = self#find_sym_usage e in
-	      if usage <> [] then
-		let uses_str = (String.concat ", "
-				  (List.map V.var_to_string usage))
-		in
-		  Printf.printf "Occurrence of %s in %s\n" uses_str str;
-		  List.iter
-		    (fun v ->
-		       if not (V.VarHash.mem usage_seen v) then
-			 if query_cb v e then
-			   (Printf.printf "First use of %s\n"
-			      (V.var_to_string v);
-			    V.VarHash.replace usage_seen v true)
-		    ) usage
-
-    method check_sym_usage_d v ty str skip_if_simple query_cb =
-      let e = match ty with
-	| V.REG_1  -> D.to_symbolic_1  v
-	| V.REG_8  -> D.to_symbolic_8  v
-	| V.REG_16 -> D.to_symbolic_16 v
-	| V.REG_32 -> D.to_symbolic_32 v
-	| V.REG_64 -> D.to_symbolic_64 v
-	| _ -> failwith "Unexpected type in check_sym_usage_d"
-      in
-	self#check_sym_usage e str skip_if_simple query_cb
-
-    val primed_syms = V.VarHash.create 31
-
-    method private prime_var v =
-      try
-	V.VarHash.find primed_syms v
-      with Not_found ->
-	let (n, s, ty) = v in
-	let v' = V.newvar (s ^ "_prime") ty in
-	  V.VarHash.replace primed_syms v v';
-	  v'
-
-    method prime_var_in_exp v e =
-      let v' = self#prime_var v in
-      let rec loop e =
-	match e with
-	  | V.Lval(V.Temp(var)) when var = v ->
-	      V.Lval(V.Temp(v'))
-	  | V.Lval(V.Temp((_, _, vty) as var)) ->
-	      if_expr_temp self var
-		(fun e -> self#tempify_e (loop e) vty) e (fun _ -> ())
-	  | V.BinOp(op, e1, e2) -> V.BinOp(op, (loop e1), (loop e2))
-	  | V.FBinOp(op, rm, e1, e2) -> V.FBinOp(op, rm, (loop e1), (loop e2))
-	  | V.UnOp(op, e1) -> V.UnOp(op, (loop e1))
-	  | V.FUnOp(op, rm, e1) -> V.FUnOp(op, rm, (loop e1))
-	  | V.Constant(_) -> e
-	  | V.Lval(V.Mem(v, e1, t)) -> V.Lval(V.Mem(v, (loop e1), t))
-	  | V.Name(_) -> e
-	  | V.Cast(ct, ty, e1) -> V.Cast(ct, ty, (loop e1))
-	  | V.FCast(ct, ty, rm, e1) -> V.FCast(ct, ty, rm, (loop e1))
-	  | V.Unknown(_) -> e
-	  | V.Let(v, e1, e2) -> V.Let(v, (loop e1), (loop e2))
-	  | V.Ite(e1, e2, e3) -> V.Ite((loop e1), (loop e2), (loop e3))
-      in
-	loop e
-
     method make_ite cond_v ty v_true v_false =
       let cond_v'  = self#tempify  cond_v  V.REG_1 and
 	  v_true'  = self#simplify v_true  ty      and
@@ -950,8 +795,7 @@ when special_ec_vars\n"; *)
 	if bits = 0 then
 	  List.hd expr_list
 	else
-	  ((*Printf.printf "formula_manager#lookup_tree bits = %d" bits;*)
-	    let shift_amt = Int64.of_int (bits - 1) in
+	  let shift_amt = Int64.of_int (bits - 1) in
 	  let cond_e = V.Cast(V.CAST_LOW, V.REG_1,
 			      V.BinOp(V.RSHIFT, e,
 				      V.Constant(V.Int(V.REG_8, shift_amt))))
@@ -959,7 +803,7 @@ when special_ec_vars\n"; *)
 	  let half_two = nth_tail (1 lsl (bits - 1)) expr_list in
 	    self#make_ite (D.from_symbolic cond_e) ty
 	      (self#lookup_tree e (bits - 1) ty half_two)
-	      (self#lookup_tree e (bits - 1) ty expr_list))
+	      (self#lookup_tree e (bits - 1) ty expr_list)
 
 
     val table_trees_cache = Hashtbl.create 101
diff --git a/execution/formula_manager.mli b/execution/formula_manager.mli
index 9ee5c0c..aa299a2 100644
--- a/execution/formula_manager.mli
+++ b/execution/formula_manager.mli
@@ -18,8 +18,6 @@ sig
     method fresh_symbolic_32 : string -> D.t
     method fresh_symbolic_64 : string -> D.t
 
-    method add_special_ec_var : Vine.var -> Vine.exp -> unit
-    method rewrite_special_ec_vars: Vine.exp -> Vine.exp
     method get_input_vars : Vine.var list
 
     method fresh_region_base : string -> D.t
@@ -70,16 +68,6 @@ sig
     method simplify_with_callback :
       (Vine.exp -> Vine.typ -> Vine.exp option) -> D.t -> Vine.typ -> D.t
 
-    method fresh_symbolic_tracked_32 : string -> D.t
-    method fresh_symbolic_tracked_64 : string -> D.t
-
-    method check_sym_usage : Vine.exp -> string -> bool ->
-      (Vine.var -> Vine.exp -> bool) -> unit
-    method check_sym_usage_d : D.t -> Vine.typ -> string -> bool ->
-      (Vine.var -> Vine.exp -> bool) -> unit
-
-    method prime_var_in_exp : Vine.var -> Vine.exp -> Vine.exp
-
     method make_ite : D.t -> Vine.typ -> D.t -> D.t -> D.t
 
     method make_table_lookup : (D.t list) -> Vine.exp -> int -> Vine.typ -> D.t
diff --git a/execution/fragment_machine.ml b/execution/fragment_machine.ml
index f7f4c45..5436b52 100644
--- a/execution/fragment_machine.ml
+++ b/execution/fragment_machine.ml
@@ -65,10 +65,6 @@ class virtual special_handler = object(self)
   method virtual handle_special : string -> V.stmt list option
   method virtual make_snap : unit
   method virtual reset : unit
-  method virtual make_f1_snap : unit
-  method virtual reset_f1_snap : unit
-  method virtual make_f2_snap : unit
-  method virtual reset_f2_snap : unit
 end
 
 type register_name = 
@@ -334,7 +330,6 @@ class virtual fragment_machine = object
   method virtual make_regs_symbolic : unit
   method virtual load_x86_user_regs : Temu_state.userRegs -> unit
   method virtual print_regs : unit
-  method virtual print_syscall_regs : unit
   method virtual printable_word_reg : register_name -> string
   method virtual printable_long_reg : register_name -> string
 
@@ -343,9 +338,6 @@ class virtual fragment_machine = object
   method virtual store_word_conc  : int64 -> int64 -> unit
   method virtual store_long_conc  : int64 -> int64 -> unit
 
-  method virtual load_sym : int64 -> int -> Vine.exp
-  method virtual store_sym : int64 -> int -> Vine.exp -> unit
-  
   method virtual store_page_conc  : int64 -> string -> unit
 
   method virtual load_byte_conc  : int64 -> int
@@ -354,8 +346,6 @@ class virtual fragment_machine = object
   method virtual load_long_conc  : int64 -> int64
 
   method virtual load_byte_concolic  : int64 -> int
-  method virtual load_byte_symbolic  : int64 -> Vine.exp
-  method virtual store_byte_symbolic  : int64 -> Vine.exp -> unit
   method virtual load_short_concolic : int64 -> int
   method virtual load_word_concolic  : int64 -> int64
   method virtual load_long_concolic  : int64 -> int64
@@ -370,8 +360,6 @@ class virtual fragment_machine = object
 
   method virtual make_snap : unit -> unit
   method virtual reset : unit -> unit
-  method virtual conc_mem_struct_adaptor: bool -> unit
-  method virtual sym_region_struct_adaptor: unit
 
   method virtual add_special_handler : special_handler -> unit
 
@@ -404,32 +392,6 @@ class virtual fragment_machine = object
     -> string
   method virtual set_reg_fresh_region : register_name -> string -> unit
 
-  method virtual get_fresh_symbolic : string -> int -> Vine.exp
-  method virtual get_reg_symbolic : register_name -> Vine.exp
-  method virtual query_exp : Vine.exp -> Vine.exp -> unit
-  method virtual simplify_exp : Vine.exp -> Vine.exp
-  method virtual save_arg_regs : int64 -> unit
-  method virtual get_saved_arg_regs : unit -> Vine.exp list
-  method virtual reset_saved_arg_regs : unit
-  method virtual set_reg_symbolic : register_name -> Vine.exp -> unit
-  method virtual make_f1_sym_snap : unit 
-  method virtual make_f1_conc_snap : unit 
-  method virtual save_f1_sym_se : unit
-  method virtual save_f1_conc_se : unit
-  method virtual make_f2_sym_snap : unit
-  method virtual make_f2_conc_snap : unit
-  method virtual compare_sym_se : unit
-  method virtual compare_conc_se : unit
-  method virtual make_f1_special_handlers_snap : unit
-  method virtual reset_f1_special_handlers_snap : unit
-  method virtual make_f2_special_handlers_snap : unit
-  method virtual reset_f2_special_handlers_snap : unit
-  method virtual make_table_lookup : (Vine.exp list) -> Vine.exp -> int -> Vine.typ -> Vine.exp
- 
-  method virtual add_f1_store : int64 -> unit
-  method virtual add_f2_store : int64 -> unit
-  method virtual match_writes : unit -> bool
- 
   method virtual set_long_reg_symbolic : register_name -> string -> unit
   method virtual set_long_reg_fresh_symbolic : register_name -> string
     -> string
@@ -515,10 +477,6 @@ class virtual fragment_machine = object
   method virtual query_with_path_cond : Vine.exp -> bool
     -> (bool * Query_engine.sat_assign)
 
-  method virtual query_condition : Vine.exp -> bool option -> int -> (bool * bool option) 
-  method virtual query_unique_value : Vine.exp -> Vine.typ -> int64 option
-  method virtual add_to_path_cond : Vine.exp -> unit
-
   method virtual match_input_var : string -> int option
 
   method virtual print_tree : out_channel -> unit
@@ -545,21 +503,6 @@ class virtual fragment_machine = object
   method virtual load_long_concretize  : int64 -> bool -> string -> int64
 
   method virtual make_sink_region : string -> int64 -> unit
- 
-  method virtual get_in_f1_range: unit -> bool
-  method virtual get_in_f2_range: unit -> bool
-  method virtual add_f1_syscall_with_args: int -> Vine.exp list -> unit
-  method virtual check_f2_syscall: int -> bool
-  method virtual check_f2_syscall_args: Vine.exp list -> int -> bool
-  method virtual match_syscalls: unit -> bool
-  method virtual reset_syscalls: unit
-  method virtual reset_struct_counts: unit 
-
-  method virtual restrict_symbolic_expr : 
-    register_name list -> int -> (Vine.exp -> Vine.exp) -> unit
-  
-  method virtual check_adaptor_condition : Vine.exp -> unit
-
 end
 
 module FragmentMachineFunctor =
@@ -625,378 +568,23 @@ struct
 	   (D.reassemble32 (D.reassemble16 b4 b5) (D.reassemble16 b6 b7)))
 
   class frag_machine = object(self)
-      
     val mem = (new GM.granular_second_snapshot_memory
 		 (new GM.granular_snapshot_memory
 		    (new GM.concrete_maybe_adaptor_memory
 		       (new string_maybe_memory))
 		    (new GM.granular_hash_memory))
-		 (new GM.granular_snapshot_memory
-		    (new GM.granular_hash_memory)
-		    (new GM.granular_hash_memory)))
+		 (new GM.granular_hash_memory))
 
-    val reg_store = V.VarHash.create 100
-    val reg_to_var = Hashtbl.create 100
-    
     val form_man = new FormMan.formula_manager
     method get_form_man = form_man
-    
-    val mutable in_f1_range = false
-    val mutable in_f2_range = false
-    val mutable f1_syscalls:(int list) = []
-    val mutable f2_syscalls_num = 0
-    val mutable f1_syscalls_args:(Vine.exp list) = []
-    val mutable f2_syscalls_arg_num = 0
- 
-    val mutable saved_arg_regs:(Vine.exp list) = []
-
-    val mutable saved_f1_rsp = 0L
-    val mutable saved_f2_rsp = 0L
-    val mutable f1_write_addr_l:(int64 list) = []
-    val mutable f2_write_addr_l:(int64 list) = []
-
-    val mutable f1_se = new GM.granular_hash_memory 
-    val mutable f1_hash : ( (int64, GM.gran64) Hashtbl.t) = Hashtbl.create 0
-    val mutable f2_se = new GM.granular_hash_memory
-
-    val mutable e_o_f1_count = ref 0
-    val mutable f2_init_count = ref 0
-
-    method add_f1_store addr = 
-      if (self#is_nonlocal_addr saved_f1_rsp addr) = true then
-	( if !opt_trace_stores then
-	    Printf.printf "FM#add_f1_store: %08Lx outside local scope(%08Lx)\n" 
-	      addr saved_f1_rsp;
-	  f1_write_addr_l <- f1_write_addr_l @ [addr] ;
-	);
-      ()
-   
-    method private is_nonlocal_addr rsp addr =
-      if (rsp <= addr) || ((addr <= 0x60000000L) && (addr >= 0x00700000L)) then
-	true 
-      else false
-	
-    method add_f2_store addr = 
-      if (self#is_nonlocal_addr saved_f2_rsp addr) = true then
-	( if !opt_trace_stores then
-	    Printf.printf "FM#add_f2_store: %08Lx outside local scope(%08Lx)\n" 
-	      addr saved_f2_rsp;
-	 if ((List.length f1_write_addr_l) > (List.length f2_write_addr_l)) &&
-	   ((List.nth f1_write_addr_l (List.length f2_write_addr_l)) = addr) then
-	   (f2_write_addr_l <- f2_write_addr_l @ [addr] ;)
-	 else (
-	   raise DisqualifiedPath;
-	 )
-	);
-      ()
-	
-    method match_writes () = 
-      (List.length f1_write_addr_l) = (List.length f2_write_addr_l)
-
-    method save_arg_regs nargs = 
-      (* Only works for X64 *)
-      let arg_regs = [R_RDI;R_RSI;R_RDX;R_RCX;R_R8;R_R9] in
-      if (List.length saved_arg_regs) = 0 then (
-	for i = 0 to (Int64.to_int nargs)-1 do
-	  saved_arg_regs <- saved_arg_regs@
-	    [(self#get_reg_symbolic (List.nth arg_regs i))];
-	done
-      );
-   
-    method get_saved_arg_regs () = saved_arg_regs
-
-    method reset_saved_arg_regs = 
-      saved_arg_regs <- [];
-
-    method get_in_f1_range () = in_f1_range 
-    
-    method get_in_f2_range () = in_f2_range
-    
-    method add_f1_syscall_with_args syscall_num arg_list = 
-      f1_syscalls <- f1_syscalls@[syscall_num] ;
-      f1_syscalls_args <- f1_syscalls_args@arg_list;
-    
-    method check_f2_syscall syscall_num = 
-      f2_syscalls_num <- 1 + f2_syscalls_num;
-      if ((List.length f1_syscalls) >= f2_syscalls_num) &&
-	(List.nth f1_syscalls (f2_syscalls_num-1)) = syscall_num then
-	true
-      else false
-	
-    (* returns true if f2 syscall args diverge from f1 *)
-    method check_f2_syscall_args arg_list syscall_num=
-      let start_ind = f2_syscalls_arg_num in
-      let end_ind = (f2_syscalls_arg_num + (List.length arg_list)) in
-      let ret = 
-	if ((List.length f1_syscalls_args) >= end_ind) then
-	  (
-	    let is_diverge = ref false in
-	    for i = start_ind to (end_ind-1) do
-	      let arg1_exp = (D.to_symbolic_64 (
-		form_man#simplify64 (D.from_symbolic (
-		  List.nth f1_syscalls_args i)))) in
-	      let arg2_exp = (D.to_symbolic_64 (
-		form_man#simplify64 (D.from_symbolic (
-		  List.nth arg_list (i-start_ind))))) in
-	      if !opt_trace_syscalls then
-		Printf.printf "f1_arg_exp = %s f2_arg_exp = %s\n" 
-		  (V.exp_to_string arg1_exp)
-		  (V.exp_to_string arg2_exp);
-	      let exp = 
-		(* wait4 syscall uses only the low 32 bits of its 1st and 3rd argument*)
-		if (syscall_num = 61) && ((i = start_ind) || (i = start_ind+2))then (
-		  V.BinOp(V.NEQ, 
-			  V.Cast(V.CAST_SIGNED, V.REG_64, V.Cast(V.CAST_LOW, V.REG_32, arg1_exp)), 
-			  V.Cast(V.CAST_SIGNED, V.REG_64, V.Cast(V.CAST_LOW, V.REG_32, arg2_exp)))) 
-		else ( V.BinOp(V.NEQ, arg1_exp, arg2_exp))
-	      in
-	      let preferred_dir = not !opt_adaptor_search_mode in
-	      let (b,choices) = (self#query_condition exp (Some preferred_dir) (0x6d00+i*10)) in
-	      let choices_str = 
-		(match choices with
-		| Some true -> "is true"
-		| Some false -> "is false"
-		| None -> "can be true or false")
-	      in
-	      if !opt_trace_syscalls then
-		Printf.printf "chose branch %B with choices %s\n" b choices_str;
-	      if b = true then (
-		is_diverge := true;
-		Printf.printf "diverged on syscall(%d) arg%d %s vs %s\n" syscall_num i 
-		  (V.exp_to_string arg1_exp) 
-		  (V.exp_to_string arg2_exp);
-	      )
-	    done;
-	    !is_diverge
-	  )
-	else (
-	  false
-	) 
-      in
-      f2_syscalls_arg_num <- f2_syscalls_arg_num + (List.length arg_list);
-      ret
-
-    method match_syscalls () =
-      if !opt_dont_compare_syscalls then true else (
-	if ((List.length f1_syscalls) <> f2_syscalls_num) then
-	  false
-	else true)
-
-    method reset_syscalls = 
-      f1_syscalls <- [];
-      f2_syscalls_num <- 0;
-      in_f1_range <- false;
-      in_f2_range <- false;
-      f1_syscalls_args <- [];
-      f2_syscalls_arg_num <- 0;
-      f1_write_addr_l <- [];
-      f2_write_addr_l <- [];
- 
+
+    val reg_store = V.VarHash.create 100
+    val reg_to_var = Hashtbl.create 100
     val temps = V.VarHash.create 100
     val mutable mem_var = V.newvar "mem" (V.TMem(V.REG_32, V.Little))
     val mutable frag = ([], [])
     val mutable insns = []
 
-    method restrict_symbolic_expr arg_regs i restriction =
-      let expr = self#get_reg_symbolic (List.nth arg_regs i)
-                 (*D.to_symbolic_64 
-                   (form_man#simplify64 
-                     (D.from_symbolic (List.nth arg_regs i)))*) in
-      let (b, choices) = self#query_condition (restriction expr) (Some true) (0x6d00+i*10) in
-      (let str = match choices with
-		         | Some true -> "is true"
-		         | Some false -> "is false"
-		         | None -> "can be true or false"
-	   in Printf.printf "chose branch %B with choices %s\n" b str;
-       if b then () 
-       else (Printf.printf "fragment_machine: expression violates restriction, raising DisqualifiedPath\n";
-             raise DisqualifiedPath))
-	
-    method check_adaptor_condition expr =
-      (* TODO this function is still in progress *)
-      let (b, choices) = self#query_condition expr (Some true) (0x6d00) in 
-      ((*let str = match choices with
-		         | Some true -> "is true)"
-		         | Some false -> "is false)"
-		         | None -> "can be true or false)"
-	   in Printf.printf "chose branch %B (with choice: %s\n" b str;*)
-       if b then () 
-       else (Printf.printf "fragment_machine: adaptor violates restriction, raising DisqualifiedPath\n";
-             raise DisqualifiedPath)) 
-    
-    method set_reg_symbolic reg symb_var =
-      self#set_int_var (Hashtbl.find reg_to_var reg)
-        (D.from_symbolic symb_var);    
-      
-    method make_f1_sym_snap = 
-      (* this method is implemented in SRFM *)
-      if !opt_trace_mem_snapshots = true then
-	Printf.printf "FM#make_f1_sym_snap called\n";
-      ()
-
-    method save_f1_sym_se = 
-      (* this method is implemented in SRFM *)
-      if !opt_trace_mem_snapshots = true then
-	Printf.printf "FM#save_f1_sym_se called\n";
-      ()
-    
-    method make_f2_sym_snap = 
-      (* this method is implemented in SRFM *)
-      if !opt_trace_mem_snapshots = true then
-	Printf.printf "FM#make_f2_sym_snap called\n";
-      ()
-	
-    method compare_sym_se =
-      (* this method is implemented in SRFM *)
-      if !opt_trace_mem_snapshots = true then
-	Printf.printf "FM#compare_sym_se called\n";
-      ()
-   
-    method make_f1_conc_snap = 
-      if !opt_trace_mem_snapshots = true then
-	Printf.printf "FM#make_f1_conc_snap called\n";
-      mem#make_snap ();
-      ()
-
-    method save_f1_conc_se = 
-      if !opt_trace_mem_snapshots = true then
-	Printf.printf "FM#save_f1_conc_se called\n";
-      self#conc_mem_struct_adaptor true;
-      f1_se <- mem#get_level4;
-      f1_hash <- Hashtbl.copy f1_se#get_mem;
-      mem#reset4_3 ();
-      ()
-
-    method make_f2_conc_snap = 
-      (* reset back to level 3 already completed in save_f1_conc_se *)
-      if !opt_trace_mem_snapshots = true then
-	Printf.printf "FM#make_f2_conc_snap called\n";
-      mem#make_snap ();
-      ()
-
-    method compare_conc_se =
-      (* compare side-effects on concrete memory between f1 and f2 *)
-      if !opt_trace_mem_snapshots = true then
-	Printf.printf "FM#compare_conc_se called\n";
-      f2_se <- mem#get_level4;
-      let f2_hash = (f2_se#get_mem) in
-      let f1_nonlocal_se = Hashtbl.create 0 in
-      let f2_nonlocal_se = Hashtbl.create 0 in
-      Hashtbl.iter (fun addr chunk ->
-	let (exp1, _) = GM.gran64_get_long chunk (f1_se#get_missing) addr in
-	let exp = D.to_symbolic_64 exp1 in
-	if (self#is_nonlocal_addr saved_f1_rsp addr) = true then
-	  (if !opt_trace_mem_snapshots = true then
-	      Printf.printf "In f1, addr = %Lx, rsp = %Lx was non-local side-effect\n" 
-		addr saved_f1_rsp;
-	   Hashtbl.replace f1_nonlocal_se addr exp;)
-      ) f1_hash;
-      Hashtbl.iter (fun addr chunk ->
-	let (exp1, _) = GM.gran64_get_long chunk (f2_se#get_missing) addr in
-	let exp = D.to_symbolic_64 exp1 in
-	if (self#is_nonlocal_addr saved_f2_rsp addr) = true then
-	  (if !opt_trace_mem_snapshots = true then
-	      Printf.printf "In f2, addr = %Lx, rsp = %Lx was non-local side-effect\n" 
-		addr saved_f2_rsp;
-	   Hashtbl.replace f2_nonlocal_se addr exp;)
-      ) f2_hash;
-      
-      (* Check for non-local memory side-effects equivalence here *)
-      if f1_nonlocal_se = f2_nonlocal_se then
-	(if !opt_trace_mem_snapshots = true then
-	  Printf.printf "all side-effects were equal\n";)
-      else 
-      (
-      (* Iterate through f1_nonlocal_se, f2_nonlocal_se and check for equivalence *)
-	Hashtbl.iter ( fun addr f1_exp ->
-	  let f2_exp =
-	  try 
-	    Hashtbl.find f2_nonlocal_se addr
-	  with Not_found -> (* f1 wrote to an address that f2 did not *)
-	    D.to_symbolic_64 (mem#load_long addr) in
-	  if !opt_trace_mem_snapshots = true then
-	    Printf.printf "addr = %Lx f1_exp = %s f2_exp = %s\n"
-	      addr (V.exp_to_string f1_exp) (V.exp_to_string f2_exp);
-	  self#query_exp f1_exp f2_exp;
-	) f1_nonlocal_se;
-	Hashtbl.iter ( fun addr f2_exp -> 
-	  (* Check if f2 wrote to an address that f1 did not *)
-	  try 
-	    ignore(Hashtbl.find f1_nonlocal_se addr)
-	  with Not_found ->
-	    (* is this correct ? wont this mem#load_long give us the same expr
-	       that is f2's non-local side-effect *)
-	    let f1_exp = D.to_symbolic_64 (mem#load_long addr) in
-	    if !opt_trace_mem_snapshots = true then
-	      Printf.printf "addr = %Lx f1_exp = %s f2_exp = %s\n"
-		addr (V.exp_to_string f1_exp) (V.exp_to_string f2_exp);
-	    self#query_exp f1_exp f2_exp;
-	) f2_nonlocal_se;
-      );
-      mem#reset4_3 ();
-      saved_f1_rsp <- 0L;
-      saved_f2_rsp <- 0L;
-      ()
-	
-    (* Check if two expressions are syntactically or semantically equal,
-       disqualify the path if not *)
-    method query_exp exp1 exp2 =
-      if exp1 = exp2 then
-	(if !opt_trace_mem_snapshots = true then
-	    Printf.printf "equal side-effects %s = %s\n"
-	      (V.exp_to_string exp1) 
-	      (V.exp_to_string exp2);)
-      else (
-	let q_exp = V.BinOp(V.EQ, exp1, exp2) in
-	let (b,_) = (self#query_condition q_exp (Some true) 0x6df0) in
-	if b = false then (
-	  if !opt_trace_mem_snapshots = true then
-	    Printf.printf "inequivalent side-effects %s!=\n%s\n" 
-	      (V.exp_to_string exp1) (V.exp_to_string exp2);
-	  raise DisqualifiedPath;
-	)
-	else (
-	  if !opt_trace_mem_snapshots = true then
-	    Printf.printf "equivalent side-effects %s=\n%s"
-	      (V.exp_to_string exp1) (V.exp_to_string exp2);
-	)
-      )
-
-    method simplify_exp e =
-      let v = D.from_symbolic e in
-	match Vine_typecheck.infer_type_fast e with
-	  | V.REG_1  -> D.to_symbolic_1  (form_man#simplify1  v)
-	  | V.REG_8  -> D.to_symbolic_8  (form_man#simplify8  v)
-	  | V.REG_16 -> D.to_symbolic_16 (form_man#simplify16 v)
-	  | V.REG_32 -> D.to_symbolic_32 (form_man#simplify32 v)
-	  | V.REG_64 -> D.to_symbolic_64 (form_man#simplify64 v)
-	  | _ -> failwith "Bad size in simplify_exp"
-
-    method get_reg_symbolic reg =
-      D.to_symbolic_64 (self#get_int_var (Hashtbl.find reg_to_var reg))
-    
-    method get_fresh_symbolic name size = 
-      match size with
-        | 1  -> D.to_symbolic_1 (form_man#fresh_symbolic_1 name)
-        | 8  -> D.to_symbolic_8 (form_man#fresh_symbolic_8 name)
-        | 16 -> D.to_symbolic_16 (form_man#fresh_symbolic_16 name)
-        | 32 -> D.to_symbolic_32 (form_man#fresh_symbolic_32 name)
-        | 64 -> D.to_symbolic_64 (form_man#fresh_symbolic_64 name)
-        | _ -> failwith "Bad size in on_missing_symbol"
-    
-    method load_byte_symbolic  addr = D.to_symbolic_8 (mem#load_byte addr)
-  
-    method store_byte_symbolic  addr b = mem#store_byte addr (D.from_symbolic b) 
-
-    method make_table_lookup table_vexp idx_exp idx_wd ty =
-      let rec map_vexp_dt_list fn l =
-	(if (List.length l) <> 0 then (fn (List.hd l)) :: 
-	    (map_vexp_dt_list fn (List.tl l)) 
-	 else [])
-      in
-      let table_dt =  map_vexp_dt_list (fun e -> D.from_symbolic e) table_vexp in
-      D.to_symbolic_8 (form_man#make_table_lookup table_dt idx_exp idx_wd ty)
-
     val mutable snap = (V.VarHash.create 1, V.VarHash.create 1)
 
     method init_prog (dl, sl) =
@@ -1059,57 +647,8 @@ struct
 	 print_string "\n"; *)
       List.iter (fun fn -> (fn (self :> fragment_machine) eip))
 	extra_eip_hooks;
-      List.iter (
-	fun (start1,end1,start2,end2) ->
-	  if eip = start1 then (
-	    saved_f1_rsp <- self#get_long_var R_RSP; 
-	    in_f1_range <- true;
-	    self#make_f1_sym_snap ; 
-	    self#make_f1_conc_snap ;  
-	    self#make_f1_special_handlers_snap ;
-	  )
-	  else if eip = end1 then (
-	    in_f1_range <- false;
-	    self#save_f1_sym_se ;
-	    self#save_f1_conc_se ;
-	    self#reset_f1_special_handlers_snap ;
-	  );
-	  if eip = start2 then (
-	    saved_f2_rsp <- self#get_long_var R_RSP;
-	    in_f2_range <- true;
-	    self#make_f2_sym_snap ;
-	    self#make_f2_conc_snap ;
-	    self#make_f2_special_handlers_snap ;
-	  )
-	  else if eip = end2 then (
-	    in_f2_range <- false;
-	    (* use this snippet to disable SE eq chk when using the memsub adaptor *)
-	    (* let (n_fields, _) = !opt_struct_adaptor_params in
-	    if n_fields = 0 then (
-	      self#compare_sym_se ;
-	      self#compare_conc_se ;
-	    ) else (
-	      mem#reset4_3 ();
-	      saved_f1_rsp <- 0L;
-	      saved_f2_rsp <- 0L;
-	    );*)
-	    if !opt_dont_compare_mem_se = false then (
-	      self#compare_sym_se ;
-	      self#compare_conc_se ;
-	      self#reset_f2_special_handlers_snap ;)
-	    else (
-	      mem#reset4_3 ();
-	      saved_f1_rsp <- 0L;
-	      saved_f2_rsp <- 0L;
-	    )
-	  );
-      ) !opt_match_syscalls_addr_range;
       self#watchpoint
 
-    method reset_struct_counts = 
-      e_o_f1_count := 0;
-      f2_init_count := 0;
-	
     method get_eip =
       match !opt_arch with
 	| X86 -> self#get_word_var R_EIP
@@ -1217,44 +756,13 @@ struct
     method private on_missing_symbol_m (m:GM.granular_memory) name =
       m#on_missing
 	(fun size addr -> 
-	  match size with
-	  | 8  -> form_man#fresh_symbolic_mem_8  name addr
-	  | 16 -> form_man#fresh_symbolic_mem_16 name addr
-	  | 32 -> form_man#fresh_symbolic_mem_32 name addr
-	  | 64 -> form_man#fresh_symbolic_mem_64 name addr
-	  | _ -> failwith "Bad size in on_missing_symbol")
-	
-    method private on_missing_symbol_m_lim (m:GM.granular_memory) name lim =
-      let contains s1 s2 =
-	let re = Str.regexp_string s2
-	in
-        try ignore (Str.search_forward re s1 0); true
-        with Not_found -> false
-      in
-      m#on_missing
-	(fun size addr -> 
-	  let ret_sym = ref false in
-	  let is_region = ref false in
-	  if (addr<0L) || (addr>=lim) then 
-	    ret_sym := true;
-	  if (contains name "region_") = true then is_region := true;
-	  match (!is_region, !ret_sym, size) with
-	  | (true, false, 8)  -> form_man#fresh_symbolic_mem_8  name addr
-	  | (true, false, 16) -> form_man#fresh_symbolic_mem_16 name addr
-	  | (true, false, 32) -> form_man#fresh_symbolic_mem_32 name addr
-	  | (true, false, 64) -> form_man#fresh_symbolic_mem_64 name addr
-	  | (true, false,_) -> 
-	    failwith "Bad size in on_missing_symbol_m_lim inside region limit"
-	  | (true, true, 8) -> D.from_concrete_8  0
-	  | (true, true, 16) -> D.from_concrete_16 0
-	  | (true, true, 32) -> D.from_concrete_32 0L
-	  | (true, true, 64) -> D.from_concrete_64 0L
-	  | (true, true, _) -> 
-	    failwith "Bad size in on_missing_symbol_m_lim outside region limit"
-	  | (false, _, _) ->
-	    failwith "on_missing_symbol_m_lim called on non-region memory"
-	)
-	
+	   match size with
+	     | 8  -> form_man#fresh_symbolic_mem_8  name addr
+	     | 16 -> form_man#fresh_symbolic_mem_16 name addr
+	     | 32 -> form_man#fresh_symbolic_mem_32 name addr
+	     | 64 -> form_man#fresh_symbolic_mem_64 name addr
+	     | _ -> failwith "Bad size in on_missing_symbol")
+
     method on_missing_symbol =
       self#on_missing_symbol_m (mem :> GM.granular_memory) "mem"
 
@@ -1611,24 +1119,24 @@ struct
       let reg r v =
 	self#set_int_var (Hashtbl.find reg_to_var r) v
       in
-	reg R_RBP (form_man#fresh_symbolic_tracked_64 "initial_rbp");
-	reg R_RSP (form_man#fresh_symbolic_tracked_64 "initial_rsp");
-	reg R_RSI (form_man#fresh_symbolic_tracked_64 "initial_rsi");
-	reg R_RDI (form_man#fresh_symbolic_tracked_64 "initial_rdi");
-	reg R_RAX (form_man#fresh_symbolic_tracked_64 "initial_rax");
-	reg R_RBX (form_man#fresh_symbolic_tracked_64 "initial_rbx");
-	reg R_RCX (form_man#fresh_symbolic_tracked_64 "initial_rcx");
-	reg R_RDX (form_man#fresh_symbolic_tracked_64 "initial_rdx");
-	reg R_R8  (form_man#fresh_symbolic_tracked_64 "initial_r8");
-	reg R_R9  (form_man#fresh_symbolic_tracked_64 "initial_r9");
-	reg R_R10 (form_man#fresh_symbolic_tracked_64 "initial_r10");
-	reg R_R11 (form_man#fresh_symbolic_tracked_64 "initial_r11");
-	reg R_R12 (form_man#fresh_symbolic_tracked_64 "initial_r12");
-	reg R_R13 (form_man#fresh_symbolic_tracked_64 "initial_r13");
-	reg R_R14 (form_man#fresh_symbolic_tracked_64 "initial_r14");
-	reg R_R15 (form_man#fresh_symbolic_tracked_64 "initial_r15");
-	reg R_FS_BASE (form_man#fresh_symbolic_tracked_64 "fs_base");
-	reg R_GS_BASE (form_man#fresh_symbolic_tracked_64 "gs_base");
+	reg R_RBP (form_man#fresh_symbolic_64 "initial_rbp");
+	reg R_RSP (form_man#fresh_symbolic_64 "initial_rsp");
+	reg R_RSI (form_man#fresh_symbolic_64 "initial_rsi");
+	reg R_RDI (form_man#fresh_symbolic_64 "initial_rdi");
+	reg R_RAX (form_man#fresh_symbolic_64 "initial_rax");
+	reg R_RBX (form_man#fresh_symbolic_64 "initial_rbx");
+	reg R_RCX (form_man#fresh_symbolic_64 "initial_rcx");
+	reg R_RDX (form_man#fresh_symbolic_64 "initial_rdx");
+	reg R_R8  (form_man#fresh_symbolic_64 "initial_r8");
+	reg R_R9  (form_man#fresh_symbolic_64 "initial_r9");
+	reg R_R10 (form_man#fresh_symbolic_64 "initial_r10");
+	reg R_R11 (form_man#fresh_symbolic_64 "initial_r11");
+	reg R_R12 (form_man#fresh_symbolic_64 "initial_r12");
+	reg R_R13 (form_man#fresh_symbolic_64 "initial_r13");
+	reg R_R14 (form_man#fresh_symbolic_64 "initial_r14");
+	reg R_R15 (form_man#fresh_symbolic_64 "initial_r15");
+	reg R_FS_BASE (form_man#fresh_symbolic_64 "fs_base");
+	reg R_GS_BASE (form_man#fresh_symbolic_64 "gs_base");
 	reg R_DFLAG (D.from_concrete_64 1L);
 	reg R_ACFLAG (D.from_concrete_64 0L);
 	reg R_IDFLAG (D.from_concrete_64 0L);
@@ -1641,40 +1149,40 @@ struct
 	reg R_ZF (D.from_concrete_1 0);
 	reg R_FTOP (D.from_concrete_32 0L);
 	reg R_FC3210 (D.from_concrete_32 0L);
-	reg R_YMM0_0 (form_man#fresh_symbolic_tracked_64 "initial_ymm0_0");
-	reg R_YMM0_1 (form_man#fresh_symbolic_tracked_64 "initial_ymm0_1");
+	reg R_YMM0_0 (form_man#fresh_symbolic_64 "initial_ymm0_0");
+	reg R_YMM0_1 (form_man#fresh_symbolic_64 "initial_ymm0_1");
 	reg R_YMM0_2 (form_man#fresh_symbolic_64 "initial_ymm0_2");
 	reg R_YMM0_3 (form_man#fresh_symbolic_64 "initial_ymm0_3");
-	reg R_YMM1_0 (form_man#fresh_symbolic_tracked_64 "initial_ymm1_0");
-	reg R_YMM1_1 (form_man#fresh_symbolic_tracked_64 "initial_ymm1_1");
+	reg R_YMM1_0 (form_man#fresh_symbolic_64 "initial_ymm1_0");
+	reg R_YMM1_1 (form_man#fresh_symbolic_64 "initial_ymm1_1");
 	reg R_YMM1_2 (form_man#fresh_symbolic_64 "initial_ymm1_2");
 	reg R_YMM1_3 (form_man#fresh_symbolic_64 "initial_ymm1_3");
-	reg R_YMM2_0 (form_man#fresh_symbolic_tracked_64 "initial_ymm2_0");
-	reg R_YMM2_1 (form_man#fresh_symbolic_tracked_64 "initial_ymm2_1");
+	reg R_YMM2_0 (form_man#fresh_symbolic_64 "initial_ymm2_0");
+	reg R_YMM2_1 (form_man#fresh_symbolic_64 "initial_ymm2_1");
 	reg R_YMM2_2 (form_man#fresh_symbolic_64 "initial_ymm2_2");
 	reg R_YMM2_3 (form_man#fresh_symbolic_64 "initial_ymm2_3");
-	reg R_YMM3_0 (form_man#fresh_symbolic_tracked_64 "initial_ymm3_0");
-	reg R_YMM3_1 (form_man#fresh_symbolic_tracked_64 "initial_ymm3_1");
+	reg R_YMM3_0 (form_man#fresh_symbolic_64 "initial_ymm3_0");
+	reg R_YMM3_1 (form_man#fresh_symbolic_64 "initial_ymm3_1");
 	reg R_YMM3_2 (form_man#fresh_symbolic_64 "initial_ymm3_2");
 	reg R_YMM3_3 (form_man#fresh_symbolic_64 "initial_ymm3_3");
-	reg R_YMM4_0 (form_man#fresh_symbolic_tracked_64 "initial_ymm4_0");
-	reg R_YMM4_1 (form_man#fresh_symbolic_tracked_64 "initial_ymm4_1");
+	reg R_YMM4_0 (form_man#fresh_symbolic_64 "initial_ymm4_0");
+	reg R_YMM4_1 (form_man#fresh_symbolic_64 "initial_ymm4_1");
 	reg R_YMM4_2 (form_man#fresh_symbolic_64 "initial_ymm4_2");
 	reg R_YMM4_3 (form_man#fresh_symbolic_64 "initial_ymm4_3");
-	reg R_YMM5_0 (form_man#fresh_symbolic_tracked_64 "initial_ymm5_0");
-	reg R_YMM5_1 (form_man#fresh_symbolic_tracked_64 "initial_ymm5_1");
+	reg R_YMM5_0 (form_man#fresh_symbolic_64 "initial_ymm5_0");
+	reg R_YMM5_1 (form_man#fresh_symbolic_64 "initial_ymm5_1");
 	reg R_YMM5_2 (form_man#fresh_symbolic_64 "initial_ymm5_2");
 	reg R_YMM5_3 (form_man#fresh_symbolic_64 "initial_ymm5_3");
-	reg R_YMM6_0 (form_man#fresh_symbolic_tracked_64 "initial_ymm6_0");
-	reg R_YMM6_1 (form_man#fresh_symbolic_tracked_64 "initial_ymm6_1");
+	reg R_YMM6_0 (form_man#fresh_symbolic_64 "initial_ymm6_0");
+	reg R_YMM6_1 (form_man#fresh_symbolic_64 "initial_ymm6_1");
 	reg R_YMM6_2 (form_man#fresh_symbolic_64 "initial_ymm6_2");
 	reg R_YMM6_3 (form_man#fresh_symbolic_64 "initial_ymm6_3");
-	reg R_YMM7_0 (form_man#fresh_symbolic_tracked_64 "initial_ymm7_0");
-	reg R_YMM7_1 (form_man#fresh_symbolic_tracked_64 "initial_ymm7_1");
+	reg R_YMM7_0 (form_man#fresh_symbolic_64 "initial_ymm7_0");
+	reg R_YMM7_1 (form_man#fresh_symbolic_64 "initial_ymm7_1");
 	reg R_YMM7_2 (form_man#fresh_symbolic_64 "initial_ymm7_2");
 	reg R_YMM7_3 (form_man#fresh_symbolic_64 "initial_ymm7_3");
-	reg R_YMM8_0 (form_man#fresh_symbolic_tracked_64 "initial_ymm8_0");
-	reg R_YMM8_1 (form_man#fresh_symbolic_tracked_64 "initial_ymm8_1");
+	reg R_YMM8_0 (form_man#fresh_symbolic_64 "initial_ymm8_0");
+	reg R_YMM8_1 (form_man#fresh_symbolic_64 "initial_ymm8_1");
 	reg R_YMM8_2 (form_man#fresh_symbolic_64 "initial_ymm8_2");
 	reg R_YMM8_3 (form_man#fresh_symbolic_64 "initial_ymm8_3");
 	reg R_YMM9_0 (form_man#fresh_symbolic_64 "initial_ymm9_0");
@@ -1705,7 +1213,6 @@ struct
 	reg R_YMM15_1 (form_man#fresh_symbolic_64 "initial_ymm15_1");
 	reg R_YMM15_2 (form_man#fresh_symbolic_64 "initial_ymm15_2");
 	reg R_YMM15_3 (form_man#fresh_symbolic_64 "initial_ymm15_3");
-	reg R_SSEROUND (D.from_concrete_64 0L); (* to nearest *)
 	reg R_FTOP (D.from_concrete_32 0L);
 	reg R_FC3210 (D.from_concrete_32 0L);
 	reg R_FPREG0 (D.from_concrete_64 0L);
@@ -1724,7 +1231,6 @@ struct
 	reg R_FPTAG5 (D.from_concrete_8 0);
 	reg R_FPTAG6 (D.from_concrete_8 0);
 	reg R_FPTAG7 (D.from_concrete_8 0);
-	reg R_FPROUND (D.from_concrete_64 0L); (* to nearest *)
 
     method private make_arm_regs_symbolic =
       let reg r v =
@@ -1824,18 +1330,6 @@ struct
 	   (self#get_int_var (Hashtbl.find reg_to_var rh)))
 	(D.to_string_64
 	   (self#get_int_var (Hashtbl.find reg_to_var rl)));
-	   
-	method private print_reg256 str r1 r2 r3 r4 = (* high -> low *)
-      Printf.printf "%s: " str;
-      Printf.printf "%s %s %s %s\n"
-	(D.to_string_64
-	   (self#get_int_var (Hashtbl.find reg_to_var r1)))
-	(D.to_string_64
-	   (self#get_int_var (Hashtbl.find reg_to_var r2)))
-	(D.to_string_64
-	   (self#get_int_var (Hashtbl.find reg_to_var r3)))
-	(D.to_string_64
-	   (self#get_int_var (Hashtbl.find reg_to_var r4)));
 
     method private print_x86_regs =
       self#print_reg32 "%eax" R_EAX;
@@ -1894,23 +1388,7 @@ struct
       self#print_reg1 "AF" R_AF;
       self#print_reg1 "ZF" R_ZF;
       self#print_reg1 "SF" R_SF;
-      self#print_reg1 "OF" R_OF;
-      self#print_reg256 "YMM0" R_YMM0_3 R_YMM0_2 R_YMM0_1 R_YMM0_0;
-      self#print_reg256 "YMM1" R_YMM1_3 R_YMM1_2 R_YMM1_1 R_YMM1_0;
-      self#print_reg256 "YMM2" R_YMM2_3 R_YMM2_2 R_YMM2_1 R_YMM2_0;
-      self#print_reg256 "YMM3" R_YMM3_3 R_YMM3_2 R_YMM3_1 R_YMM3_0;
-      self#print_reg256 "YMM4" R_YMM4_3 R_YMM4_2 R_YMM4_1 R_YMM4_0;
-      self#print_reg256 "YMM5" R_YMM5_3 R_YMM5_2 R_YMM5_1 R_YMM5_0;
-      self#print_reg256 "YMM6" R_YMM6_3 R_YMM6_2 R_YMM6_1 R_YMM6_0;
-      self#print_reg256 "YMM7" R_YMM7_3 R_YMM7_2 R_YMM7_1 R_YMM7_0;
-      self#print_reg256 "YMM8" R_YMM8_3 R_YMM8_2 R_YMM8_1 R_YMM8_0;
-      self#print_reg256 "YMM9" R_YMM9_3 R_YMM9_2 R_YMM9_1 R_YMM9_0;
-      self#print_reg256 "YMM10" R_YMM10_3 R_YMM10_2 R_YMM10_1 R_YMM10_0;
-      self#print_reg256 "YMM11" R_YMM11_3 R_YMM11_2 R_YMM11_1 R_YMM11_0;
-      self#print_reg256 "YMM12" R_YMM12_3 R_YMM12_2 R_YMM12_1 R_YMM12_0;
-      self#print_reg256 "YMM13" R_YMM13_3 R_YMM13_2 R_YMM13_1 R_YMM13_0;
-      self#print_reg256 "YMM14" R_YMM14_3 R_YMM14_2 R_YMM14_1 R_YMM14_0;
-      self#print_reg256 "YMM15" R_YMM15_3 R_YMM15_2 R_YMM15_1 R_YMM15_0;
+      self#print_reg1 "OF" R_OF
 
     method private print_arm_regs =
       self#print_reg32 " r0" R0;
@@ -1942,34 +1420,6 @@ struct
 	| X64 -> self#print_x64_regs
 	| ARM -> self#print_arm_regs
 
-    method print_syscall_regs =
-      match !opt_arch with
-	| X86 ->
-	    self#print_reg32 "%eax" R_EAX;
-	    self#print_reg32 "%ebx" R_EBX;
-	    self#print_reg32 "%ecx" R_ECX;
-	    self#print_reg32 "%edx" R_EDX;
-	    self#print_reg32 "%esi" R_ESI;
-	    self#print_reg32 "%edi" R_EDI;
-	    self#print_reg32 "%ebp" R_EBP;
-	| X64 ->
-	    self#print_reg64 "%rax" R_RAX;
-	    self#print_reg64 "%rdi" R_RDI;
-	    self#print_reg64 "%rsi" R_RSI;
-	    self#print_reg64 "%rdx" R_RDX;
-	    self#print_reg64 "%r10" R_R10;
-	    self#print_reg64 "%r8"  R_R8;
-	    self#print_reg64 "%r9"  R_R9;
-	| ARM ->
-	    self#print_reg32 " r7" R7;
-	    self#print_reg32 " r0" R0;
-	    self#print_reg32 " r1" R1;
-	    self#print_reg32 " r2" R2;
-	    self#print_reg32 " r3" R3;
-	    self#print_reg32 " r4" R4;
-	    self#print_reg32 " r5" R5;
-	    self#print_reg32 " r6" R6;
-
     method private simplify_reg32 r =
       let var = Hashtbl.find reg_to_var r in
 	self#set_int_var var (form_man#simplify32 (self#get_int_var var))
@@ -2087,23 +1537,6 @@ struct
     method store_word  addr w = mem#store_word  addr w
     method store_long  addr l = mem#store_long  addr l
 
-    method load_sym addr size = 
-      match size with
-      | 8 -> D.to_symbolic_8 (mem#load_byte addr)
-      | 16 -> D.to_symbolic_16 (mem#load_short addr)
-      | 32 -> D.to_symbolic_32 (mem#load_word addr)
-      | 64 -> D.to_symbolic_64 (mem#load_long addr)
-      | _ -> failwith "Unsupported size in FM#load_sym"
-
-    method store_sym addr size value_s =
-      let value = D.from_symbolic value_s in
-      match size with
-      | 8 -> mem#store_byte addr value
-      | 16 -> mem#store_short addr value
-      | 32 -> mem#store_word addr value
-      | 64 -> mem#store_long addr value
-      | _ -> failwith "Unsupported size in FM#store_sym"
-
     method store_byte_conc  addr b = mem#store_byte addr (D.from_concrete_8 b)
     method store_short_conc addr s = mem#store_short addr(D.from_concrete_16 s)
     method store_word_conc  addr w = mem#store_word addr (D.from_concrete_32 w)
@@ -2141,8 +1574,7 @@ struct
 	setup ()
 
     method start_symbolic =
-      (*mem#inner_make_snap ();*)
-      mem#make_snap ();
+      mem#inner_make_snap ();
       started_symbolic <- true
 
     val mutable special_handler_list = ([] : #special_handler list)
@@ -2152,30 +1584,6 @@ struct
       snap <- (V.VarHash.copy reg_store, V.VarHash.copy temps);
       List.iter (fun h -> h#make_snap) special_handler_list
 
-    method make_f1_special_handlers_snap =
-      if !opt_trace_mem_snapshots = true then
-	Printf.printf "FM#make_f1_special_handlers_snap\n";
-      List.iter (fun h -> h#make_f1_snap) special_handler_list;
-      ()
- 
-    method reset_f1_special_handlers_snap =
-      if !opt_trace_mem_snapshots = true then
-	Printf.printf "FM#reset_f1_special_handlers_snap\n";
-      List.iter (fun h -> h#reset_f1_snap) special_handler_list;
-      ()
- 
-    method make_f2_special_handlers_snap =
-      if !opt_trace_mem_snapshots = true then
-	Printf.printf "FM#make_f2_special_handlers_snap\n";
-      List.iter (fun h -> h#make_f2_snap) special_handler_list;
-      ()
- 
-    method reset_f2_special_handlers_snap =
-      if !opt_trace_mem_snapshots = true then
-	Printf.printf "FM#reset_f2_special_handlers_snap\n";
-      List.iter (fun h -> h#reset_f2_snap) special_handler_list;
-      ()
- 
     val mutable fuzz_finish_reasons = []
     val mutable disqualified = false
 
@@ -2198,22 +1606,15 @@ struct
 	fuzz_finish_reasons
 
     method reset () =
-      if !opt_trace_mem_snapshots = true then
-	Printf.printf "FM#reset calling mem#reset()\n";
       mem#reset ();
       (match snap with (r, t) ->
 	 move_hash r reg_store;
 	 move_hash t temps);
       fuzz_finish_reasons <- [];
       disqualified <- false;
-      if (List.length !opt_match_syscalls_addr_range) <> 0 then
-	self#reset_syscalls ;
       List.iter (fun h -> h#reset) special_handler_list
 
-  method sym_region_struct_adaptor = 
-    Printf.printf "FM#sym_region_struct_adaptor should not have been called\n";
-  
-  method add_special_handler (h:special_handler) =
+    method add_special_handler (h:special_handler) =
       special_handler_list <- h :: special_handler_list
 
     method handle_special str =
@@ -2698,7 +2099,7 @@ struct
 		Printf.printf "    %s is %s\n" s (D.to_string_32 v);
 	      (v, ty)
 	| V.Lval(V.Mem(memv, idx, ty)) ->
-	  self#handle_load idx ty
+	    self#handle_load idx ty
 	| V.Cast(kind, ty, e) ->
 	    let (v1, ty1) = self#eval_int_exp_ty e in
 	      self#eval_cast kind ty v1 ty1
@@ -3205,11 +2606,6 @@ struct
     method query_with_path_cond (e:Vine.exp) (v:bool)
       : (bool * Query_engine.sat_assign) =
       (false, (Query_engine.ce_from_list []))
-    method query_condition (e:Vine.exp) (b:bool option) 
-	(i:int) : (bool * bool option) =
-      (false,None)
-    method query_unique_value (e:Vine.exp) (t:Vine.typ) = None
-    method add_to_path_cond (e:Vine.exp) = ()
     method match_input_var (s:string) : int option = None
     method get_path_cond : Vine.exp list = []
     method on_missing_random : unit =
@@ -3234,302 +2630,5 @@ struct
     method load_long_concretize  addr (b:bool) (s:string)
       = self#load_long_conc addr
     method make_sink_region (s:string) (i:int64) = ()
-
-    method conc_mem_struct_adaptor end_of_f1 = 
-      let get_ite_expr arg op const_type const then_val else_val = 
-	V.Ite(V.BinOp(op, arg, V.Constant(V.Int(const_type, const))),
-              then_val,
-              else_val)
-      in
-      let upcast expr _extend_op end_sz =
-	match _extend_op with 
-	| (Some extend_op) ->  
-	  (match end_sz with
-	  | 8  -> V.Cast(extend_op, V.REG_8 , expr)
-	  | 16 -> V.Cast(extend_op, V.REG_16, expr)
-	  | 32 -> V.Cast(extend_op, V.REG_32, expr)
-	  | 64 -> V.Cast(extend_op, V.REG_64, expr)
-	  | _ -> failwith "unsupported upcast end size")
-	| None -> expr
-      in
-      let from_concrete v sz = 
-	match sz with 
-	| 8 -> assert(v >= -128 && v <= 0xff);
-	  V.Constant(V.Int(V.REG_8,  (Int64.of_int (v land 0xff))))
-	| 16 -> assert(v >= -65536 && v <= 0xffff);
-	  V.Constant(V.Int(V.REG_16, (Int64.of_int (v land 0xffff))))
-	| 32 -> V.Constant(V.Int(V.REG_32, (Int64.logand (Int64.of_int v) 0xffffffffL)))
-	| 64 -> V.Constant(V.Int(V.REG_64, (Int64.of_int v)))
-	| _ -> failwith "unsupported size passed to AS#from_concrete"
-      in
-      let get_byte expr pos =
-	V.Cast(V.CAST_LOW, V.REG_8, 
-	       V.BinOp(V.RSHIFT, expr, (from_concrete (pos*8) 8)))
-      in
-      (* This simplifies formulas and introduces t-variables for comple
-	 sub-expressions. Doing this generally speeds things up, but it
-	 may make debugging the formulas less convenient, so you can disable
-	 it by make "simplify" be the identity function. *)
-      let simplify e = 
-	if !opt_split_target_formulas = true then self#simplify_exp e else e in
-
-      let start_time = Sys.time () in
-      let step_str = if end_of_f1 then "eof1" else "sof2" in
-      if (List.length !opt_synth_struct_adaptor) <> 0 then (
-	if !opt_trace_struct_adaptor = true then
-	  Printf.printf "Starting structure adaptor %s\n" step_str;
-	if !opt_time_stats then
-	  (Printf.printf "Generating structure adaptor formulas...";
-	   flush stdout);
-	let addr_list_ind = if end_of_f1 then !e_o_f1_count else !f2_init_count in
-	let addr = List.nth !opt_synth_struct_adaptor addr_list_ind in
-	let adaptor_vals = Hashtbl.copy Adaptor_synthesis.adaptor_vals in
-	  if !opt_time_stats then
-	    (Printf.printf "(0x%08Lx)..." addr;
-	     flush stdout);
-	  if (Int64.abs (fix_s32 addr)) > 4096L then (
-	    let (_, _, max_size) = !opt_struct_adaptor_params in
-	    let rec get_arr_t_field_expr field_num this_array_field_ranges_l 
-		ai_byte ai_f_sz ai_n =
-		(* Assume ai_n equals target_n for now *)
-	      let get_ai_byte_expr target_n target_sz start_addr ex_op =
-		let cast_op =
-		  if target_sz < ai_f_sz then 
-		    if ex_op = 1 then (Some V.CAST_SIGNED) 
-		    else (Some V.CAST_UNSIGNED)
-		  else if target_sz > ai_f_sz then (Some V.CAST_LOW)
-		  else None
-		in
-		  (* translate ai_byte to a t_byte by using ai_f_sz and t_sz *)
-		let ai_q = ai_byte/ai_f_sz in
-		let ai_r = ai_byte mod ai_f_sz in
-		let tmp_addr = Int64.add start_addr (Int64.of_int (ai_q*target_sz)) in
-		let ai_entry = 
-		  upcast (self#load_sym tmp_addr (target_sz*8)) cast_op (ai_f_sz*8) 
-		in 
-		get_byte ai_entry ai_r
-	      in
-	      match this_array_field_ranges_l with
-	      | [] -> failwith "AS#get_arr_t_field_expr ran out of this_array_field_ranges_l"
-	      | [(start_byte, end_byte, n, f_sz)] -> 
-		assert(n = ai_n);
-		let start_addr = (Int64.add addr (Int64.of_int start_byte)) in
-		get_ai_byte_expr n f_sz start_addr 1
-	      | (start_byte, end_byte, n, f_sz)::tail ->
-		assert(n = ai_n);
-		let start_addr = (Int64.add addr (Int64.of_int start_byte)) in
-		let is_extend_req = (f_sz - 8) in
-		if is_extend_req <> 0 then (
-		  let sign_extend_val = Int64.of_int ((start_byte lsl 32)+(end_byte lsl 16)+1) in 
-		  let zero_extend_val = Int64.of_int ((start_byte lsl 32)+(end_byte lsl 16)+0) in 
-		  if (n = ai_n) then (
-		    let f_type_str = "f"^(Printf.sprintf "%d" field_num)^"_type" in
-		    let f_type = 
-		      if not !opt_adaptor_search_mode then 
-			Hashtbl.find adaptor_vals f_type_str
-		      else self#get_fresh_symbolic f_type_str 64 in
-		    let sign_extend_expr = get_ai_byte_expr n f_sz start_addr 1 in
-		    let zero_extend_expr = get_ai_byte_expr n f_sz start_addr 0 in
-		   
-		    let else_expr' = (get_arr_t_field_expr field_num tail
-			   ai_byte ai_f_sz ai_n ) in
-		    let else_expr = simplify else_expr' in
-		    
-		    get_ite_expr f_type V.EQ V.REG_64 sign_extend_val sign_extend_expr 
-		      (get_ite_expr f_type V.EQ V.REG_64 zero_extend_val zero_extend_expr
-			 else_expr )
-		  ) else (
-		    simplify (get_arr_t_field_expr field_num tail
-				ai_byte ai_f_sz ai_n )
-		  )
-		) else (
-		  let sign_extend_val = Int64.of_int ((start_byte lsl 32)+(end_byte lsl 16)+1) in 
-		  if (ai_n = n) then (
-		    let f_type_str = "f"^(Printf.sprintf "%d" field_num)^"_type" in
-		    let f_type = 
-		      if not !opt_adaptor_search_mode then 
-			Hashtbl.find adaptor_vals f_type_str
-		      else self#get_fresh_symbolic f_type_str 64 in
-		    let sign_extend_expr = get_ai_byte_expr n f_sz start_addr 1 in
-
-		    let else_expr' = (get_arr_t_field_expr field_num tail
-			   ai_byte ai_f_sz ai_n ) in
-		    let else_expr = simplify else_expr' in
-		    
-		    get_ite_expr f_type V.EQ V.REG_64 sign_extend_val sign_extend_expr 
-		      else_expr
-		  ) else (
-		    simplify (get_arr_t_field_expr field_num tail
-				ai_byte ai_f_sz ai_n )
-		  )
-		)
-	    in
-	    let field_exprs = Hashtbl.create 1001 in
-	    let t_field_h = Hashtbl.create 1000 in
-	    let i_n_arr = !Adaptor_synthesis.i_n_arr' in
-	    let i_byte_arr = !Adaptor_synthesis.i_byte_arr' in
-	    let unique_str = if end_of_f1 then "_f1_" else "" in
-	    let rec get_arr_ite_ai_byte_expr this_array_field_ranges_l i_byte = 
-		(* i_byte = interesting_byte *)
-	      match this_array_field_ranges_l with
-	      | [] -> from_concrete 0 8
-	      | (field, start_byte, end_byte, ai_n, ai_f_sz, cond)::tail ->
-		if (i_byte >= start_byte) && (i_byte <= end_byte) then (
-		  let field_size_temp_str = "arr_as_t_field_"^
-		    (Printf.sprintf "%s%d_n%d_sz%d_b%d_%d" unique_str field ai_n ai_f_sz 
-		       (i_byte-start_byte) addr_list_ind)
-		  in
-		  let field_size_temp = self#get_fresh_symbolic field_size_temp_str 8 in
-
-		  let q_exp = 
-		    (try
-		       Hashtbl.find field_exprs field_size_temp_str
-                     with Not_found ->
-		       let new_q_exp =
-			 V.BinOp(V.EQ, field_size_temp,
-				 (get_arr_t_field_expr field 
-				    (List.rev !((i_n_arr).(ai_n))) (* array_field_ranges_l *)
-				    (i_byte-start_byte) ai_f_sz ai_n )) in
-		       
-		       Hashtbl.replace field_exprs field_size_temp_str new_q_exp;
-		       self#add_to_path_cond new_q_exp;
-		       new_q_exp)
-		  in
-
-		  if !opt_trace_struct_adaptor = true then
-		    Hashtbl.replace t_field_h field_size_temp q_exp;
-		  
-		  V.Ite(cond, field_size_temp, 
-			(get_arr_ite_ai_byte_expr tail i_byte ))
-		) else (
-		  get_arr_ite_ai_byte_expr tail i_byte 
-		)
-	    in
-	    if !opt_time_stats then
-	      (Printf.printf "%s byte expressions..." step_str;
-	       flush stdout);
-
-	    (* let upcast expr _extend_op end_sz =
-	      match _extend_op with 
-	      | (Some extend_op) ->  
-		(match end_sz with
-		| 8  -> V.Cast(extend_op, V.REG_8 , expr)
-		| 16 -> V.Cast(extend_op, V.REG_16, expr)
-		| 32 -> V.Cast(extend_op, V.REG_32, expr)
-		| 64 -> V.Cast(extend_op, V.REG_64, expr)
-		| _ -> failwith "unsupported upcast end size")
-	      | None -> expr
-	    in  
-	    let from_concrete v sz = 
-	      match sz with 
-	      | 8 -> assert(v >= -128 && v <= 0xff);
-		V.Constant(V.Int(V.REG_8,  (Int64.of_int (v land 0xff))))
-	      | 16 -> assert(v >= -65536 && v <= 0xffff);
-		V.Constant(V.Int(V.REG_16, (Int64.of_int (v land 0xffff))))
-	      | 32 -> V.Constant(V.Int(V.REG_32, (Int64.logand (Int64.of_int v) 0xffffffffL)))
-	      | 64 -> V.Constant(V.Int(V.REG_64, (Int64.of_int v)))
-	      | _ -> failwith "unsupported size passed to AS#from_concrete"
-	    in
-	    let get_byte expr pos =
-	      V.Cast(V.CAST_LOW, V.REG_8, 
-		     V.BinOp(V.RSHIFT, expr, (from_concrete (pos*8) 8)))
-	    in
-	    let byte_ce_expr_l = ref [] in
-	    let get_byte_from_adaptor f_num =
-	      let str_gen i s = Printf.sprintf "f%d%s" i s in
-	      let f_type = match Hashtbl.find adaptor_vals (str_gen f_num "_type") with 
-		| V.Constant(V.Int(V.REG_64, n)) -> (Int64.to_int n)
-		| _ -> 0 in
-	      let f_n = match Hashtbl.find adaptor_vals (str_gen f_num "_n") with
-		| V.Constant(V.Int(V.REG_16, n)) -> (Int64.to_int n)
-		| _ -> 0 in
-	      let f_size = match Hashtbl.find adaptor_vals (str_gen f_num "_size") with 
-		| V.Constant(V.Int(V.REG_16, n)) -> (Int64.to_int n)
-		| _ -> 0 in
-	      let t_s_b = f_type lsr 32 in (* target_start_byte *)
-	      let t_e_b = (f_type lsr 16) land 65535 in (* target_end_byte *)
-	      let t_size = (t_e_b-t_s_b+1)/f_n in
-	      let cast_op = if t_size > f_size then (Some V.CAST_LOW)
-		else if (f_type mod 2) = 1 then (Some V.CAST_SIGNED) 
-		else if (f_type mod 2) = 0 then (Some V.CAST_UNSIGNED)
-		else None in
-	      if !opt_trace_struct_adaptor then
-		Printf.printf "parsing adaptor in FM: type=%x n=%d sz=%d t_s=%d t_e=%d\n"
-		  f_type f_n f_size t_s_b t_e_b;
-	      for byte = 0 to (f_n*f_size)-1 do
-		let i_this_entry = byte/f_size in
-		let i_this_byte_within_entry = byte mod f_size in
-		let t_this_entry = t_size*i_this_entry in
-		let t_load_addr = Int64.add addr (Int64.of_int (t_s_b+t_this_entry)) in
-		let i_this_entry_val = 
-		  upcast (self#load_sym t_load_addr (t_size*8)) cast_op (f_size*8) in
-		let byte_val = get_byte i_this_entry_val i_this_byte_within_entry in
-		if !opt_trace_struct_adaptor then
-		  Printf.printf "byte_val = %s\n" (V.exp_to_string byte_val);
-		byte_ce_expr_l := byte_val :: !byte_ce_expr_l;
-	      done;
-	    in
-	    if not !opt_adaptor_search_mode then (
-	      for i = 1 to n_fields do
-		get_byte_from_adaptor i;
-	      done;
-	      let sz = List.length !byte_ce_expr_l in
-	      for i = sz to (max_size-1) do
-		let load_addr = Int64.add addr (Int64.of_int i) in
-		let byte_val = self#load_sym load_addr 8 in
-		byte_ce_expr_l := byte_val :: !byte_ce_expr_l;
-	      done;
-	      byte_ce_expr_l := (List.rev !byte_ce_expr_l)); *)
-	    let byte_expr_l = ref [] in 
-	    for i=0 to (max_size-1) do 
-	      let byte_expr = (* if !opt_adaptor_search_mode then *)
-		(get_arr_ite_ai_byte_expr (List.rev !((i_byte_arr).(i))) i) 
-		(* else (List.nth !byte_ce_expr_l i) *)
-	      in
-	      let byte_expr_sym_str = 
-		"arr_ai_byte_"^(Printf.sprintf "%s%d_%d" unique_str i addr_list_ind) in
-	      let byte_expr_sym = self#get_fresh_symbolic byte_expr_sym_str 8 in
-	      let q_exp = V.BinOp(V.EQ, byte_expr_sym, byte_expr) in
-	      if !opt_trace_struct_adaptor = true then
-		Printf.printf "AS#get_arr_ite_ai_byte_expr for byte %d: %s\n\n" i
-		  (V.exp_to_string q_exp);
-	      self#add_to_path_cond q_exp;
-		(* if this is CE search, check if byte_expr has unique value *)
-	      let final_byte_val = 
-		if not !opt_adaptor_ivc || !opt_adaptor_search_mode then
-		  byte_expr_sym 
-		else (
-		  match self#query_unique_value byte_expr_sym V.REG_8 with
-		  | Some v ->
-		    Printf.printf "%s has unique value %Lx\n" 
-		      (V.exp_to_string byte_expr_sym) v;
-		    (V.Constant(V.Int(V.REG_8, v)))
-		  | None -> 
-		    Printf.printf "%s does not have unique value\n" 
-		      (V.exp_to_string byte_expr_sym);
-		    byte_expr_sym )
-	      in
-	      byte_expr_l := final_byte_val :: !byte_expr_l;
-	    done;
-	    byte_expr_l := (List.rev !byte_expr_l);
-
-	    if !opt_trace_struct_adaptor = true then
-	      Hashtbl.iter (fun key value ->
-		Printf.printf "AS#apply_struct_adaptor t_field_h[%s] = %s\n" 
-		  (V.exp_to_string key) (V.exp_to_string value);
-	      ) t_field_h; 
-	    
-	    for i=0 to (max_size-1) do
-	      self#store_sym (Int64.add addr (Int64.of_int i)) 8 (List.nth !byte_expr_l i);
-	    done;
-	    
-	  );
-	  if end_of_f1 then e_o_f1_count := !e_o_f1_count + 1
-	  else f2_init_count := !f2_init_count + 1;
-      );
-      if !opt_time_stats then
-	(Printf.printf "AS#ready to apply (%f sec). %s\n" (Sys.time () -. start_time) step_str;
-	 flush stdout);
-
   end
 end
diff --git a/execution/fragment_machine.mli b/execution/fragment_machine.mli
index 3dd15c8..86b63e7 100644
--- a/execution/fragment_machine.mli
+++ b/execution/fragment_machine.mli
@@ -7,10 +7,6 @@ class virtual special_handler : object
   method virtual handle_special : string -> Vine.stmt list option
   method virtual make_snap : unit
   method virtual reset : unit
-  method virtual make_f1_snap : unit
-  method virtual reset_f1_snap : unit
-  method virtual make_f2_snap : unit
-  method virtual reset_f2_snap : unit
 end
 
 type register_name = 
@@ -103,7 +99,6 @@ class virtual fragment_machine : object
   method virtual make_regs_symbolic : unit
   method virtual load_x86_user_regs : Temu_state.userRegs -> unit
   method virtual print_regs : unit
-  method virtual print_syscall_regs : unit
   method virtual printable_word_reg : register_name -> string
   method virtual printable_long_reg : register_name -> string
 
@@ -119,12 +114,7 @@ class virtual fragment_machine : object
   method virtual load_word_conc  : int64 -> int64
   method virtual load_long_conc  : int64 -> int64
 
-  method virtual load_sym : int64 -> int -> Vine.exp
-  method virtual store_sym : int64 -> int -> Vine.exp -> unit
-  
   method virtual load_byte_concolic  : int64 -> int
-  method virtual load_byte_symbolic  : int64 -> Vine.exp
-  method virtual store_byte_symbolic  : int64 -> Vine.exp -> unit
   method virtual load_short_concolic : int64 -> int
   method virtual load_word_concolic  : int64 -> int64
   method virtual load_long_concolic  : int64 -> int64
@@ -139,8 +129,6 @@ class virtual fragment_machine : object
 
   method virtual make_snap : unit -> unit
   method virtual reset : unit -> unit
-  method virtual conc_mem_struct_adaptor: bool -> unit
-  method virtual sym_region_struct_adaptor: unit
 
   method virtual add_special_handler : special_handler -> unit
 
@@ -173,35 +161,6 @@ class virtual fragment_machine : object
     -> string
   method virtual set_reg_fresh_region : register_name -> string -> unit
 
-  method virtual get_fresh_symbolic : string -> int -> Vine.exp
-  method virtual get_reg_symbolic : register_name -> Vine.exp
-  method virtual query_exp : Vine.exp -> Vine.exp -> unit
-  method virtual simplify_exp : Vine.exp -> Vine.exp
-  method virtual save_arg_regs : int64 -> unit
-  method virtual get_saved_arg_regs : unit -> Vine.exp list
-  method virtual reset_saved_arg_regs : unit 
-  method virtual set_reg_symbolic : register_name -> Vine.exp -> unit
-
-  method virtual make_f1_sym_snap : unit 
-  method virtual make_f1_conc_snap : unit 
-  method virtual save_f1_sym_se : unit
-  method virtual save_f1_conc_se : unit
-
-  method virtual make_f2_sym_snap : unit
-  method virtual make_f2_conc_snap : unit
-  method virtual compare_sym_se : unit
-  method virtual compare_conc_se : unit
-  method virtual make_f1_special_handlers_snap : unit
-  method virtual reset_f1_special_handlers_snap : unit
-  method virtual make_f2_special_handlers_snap : unit
-  method virtual reset_f2_special_handlers_snap : unit
-  
-  method virtual make_table_lookup : (Vine.exp list) -> Vine.exp -> int -> Vine.typ -> Vine.exp
-  
-  method virtual add_f1_store : int64 -> unit
-  method virtual add_f2_store : int64 -> unit
-  method virtual match_writes : unit -> bool
-  
   method virtual set_long_reg_symbolic : register_name -> string -> unit
   method virtual set_long_reg_fresh_symbolic : register_name -> string
     -> string
@@ -287,12 +246,6 @@ class virtual fragment_machine : object
   method virtual query_with_path_cond : Vine.exp -> bool
     -> (bool * Query_engine.sat_assign)
 
-  method virtual query_condition : Vine.exp -> bool option -> int -> (bool * bool option)
-
-  method virtual query_unique_value : Vine.exp -> Vine.typ -> int64 option
-
-  method virtual add_to_path_cond : Vine.exp -> unit
-
   method virtual match_input_var : string -> int option
 
   method virtual print_tree : out_channel -> unit
@@ -318,19 +271,6 @@ class virtual fragment_machine : object
   method virtual load_long_concretize  : int64 -> bool -> string -> int64
 
   method virtual make_sink_region : string -> int64 -> unit
- 
-  method virtual get_in_f1_range: unit -> bool
-  method virtual get_in_f2_range: unit -> bool
-  method virtual add_f1_syscall_with_args: int -> Vine.exp list -> unit
-  method virtual check_f2_syscall: int -> bool
-  method virtual check_f2_syscall_args: Vine.exp list -> int -> bool
-  method virtual match_syscalls: unit -> bool
-  method virtual reset_syscalls: unit
-  method virtual reset_struct_counts: unit 
-  
-  method virtual restrict_symbolic_expr : register_name list -> int -> (Vine.exp -> Vine.exp) -> unit
-  method virtual check_adaptor_condition : Vine.exp -> unit
-  
 end
 
 module FragmentMachineFunctor :
@@ -357,9 +297,6 @@ sig
     method private on_missing_symbol_m :
       Granular_memory.GranularMemoryFunctor(D).granular_memory
       -> string -> unit
-    method private on_missing_symbol_m_lim :
-      Granular_memory.GranularMemoryFunctor(D).granular_memory
-      -> string -> int64 -> unit
     method on_missing_zero : unit
     method on_missing_random : unit
     method on_missing_symbol : unit
@@ -368,7 +305,6 @@ sig
     method make_regs_symbolic : unit
     method load_x86_user_regs : Temu_state.userRegs -> unit
     method print_regs : unit
-    method print_syscall_regs : unit
     method printable_word_reg : register_name -> string
     method printable_long_reg : register_name -> string
 
@@ -377,9 +313,6 @@ sig
     method store_word  : int64 -> D.t -> unit
     method store_long  : int64 -> D.t -> unit
 
-    method load_sym : int64 -> int -> Vine.exp
-    method store_sym : int64 -> int -> Vine.exp -> unit
-    
     method store_byte_conc  : int64 -> int   -> unit
     method store_short_conc : int64 -> int   -> unit
     method store_word_conc  : int64 -> int64 -> unit
@@ -387,27 +320,6 @@ sig
 
     method store_page_conc  : int64 -> string -> unit
 
-    val mutable in_f1_range: bool
-    val mutable in_f2_range: bool
-    val mutable f1_syscalls: int list
-    val mutable f1_syscalls_args: Vine.exp list
-    val mutable f2_syscalls_num: int 
-    val mutable f2_syscalls_arg_num: int 
-    val mutable saved_arg_regs: Vine.exp list
-    method get_in_f1_range: unit -> bool
-    method get_in_f2_range: unit -> bool
-    method add_f1_syscall_with_args: int -> Vine.exp list -> unit
-    method check_f2_syscall: int -> bool
-    method check_f2_syscall_args: Vine.exp list -> int -> bool
-    method match_syscalls: unit -> bool
-    method reset_syscalls: unit
-    method reset_struct_counts: unit 
-    val mutable f1_write_addr_l:int64 list
-    val mutable f2_write_addr_l:int64 list
-    
-    method restrict_symbolic_expr : register_name list -> int -> (Vine.exp -> Vine.exp) -> unit
-    method check_adaptor_condition : Vine.exp -> unit
-    
     method private load_byte  : int64 -> D.t
     method private load_short : int64 -> D.t
     method private load_word  : int64 -> D.t
@@ -419,8 +331,6 @@ sig
     method load_long_conc  : int64 -> int64
 
     method load_byte_concolic  : int64 -> int
-    method load_byte_symbolic  : int64 -> Vine.exp
-    method store_byte_symbolic  : int64 -> Vine.exp -> unit
     method load_short_concolic : int64 -> int
     method load_word_concolic  : int64 -> int64
     method load_long_concolic  : int64 -> int64
@@ -435,8 +345,6 @@ sig
 
     method make_snap : unit -> unit
     method reset : unit -> unit
-    method conc_mem_struct_adaptor: bool -> unit
-    method sym_region_struct_adaptor: unit
 
     method add_special_handler : special_handler -> unit
 
@@ -479,33 +387,6 @@ sig
     method set_word_reg_fresh_symbolic : register_name -> string -> string
     method set_reg_fresh_region : register_name -> string -> unit
 
-    method get_fresh_symbolic : string -> int -> Vine.exp
-    method get_reg_symbolic : register_name -> Vine.exp
-    method query_exp : Vine.exp -> Vine.exp -> unit
-    method simplify_exp : Vine.exp -> Vine.exp
-    method save_arg_regs : int64 -> unit
-    method add_f1_store : int64 -> unit
-    method add_f2_store : int64 -> unit
-    method match_writes : unit -> bool
-    method get_saved_arg_regs : unit -> Vine.exp list
-    method reset_saved_arg_regs : unit
-    method set_reg_symbolic : register_name -> Vine.exp -> unit
-
-    method make_f1_sym_snap : unit 
-    method make_f1_conc_snap : unit 
-    method save_f1_sym_se : unit
-    method save_f1_conc_se : unit
-    method make_f2_sym_snap : unit
-    method make_f2_conc_snap : unit
-    method compare_sym_se : unit
-    method compare_conc_se : unit
-    method make_f1_special_handlers_snap : unit
-    method reset_f1_special_handlers_snap : unit
-    method make_f2_special_handlers_snap : unit
-    method reset_f2_special_handlers_snap : unit
-
-    method make_table_lookup : (Vine.exp list) -> Vine.exp -> int -> Vine.typ -> Vine.exp
-    
     method set_long_reg_symbolic : register_name -> string -> unit
     method set_long_reg_fresh_symbolic : register_name -> string -> string
 
@@ -612,17 +493,14 @@ sig
     val form_man : Formula_manager.FormulaManagerFunctor(D).formula_manager
     method get_form_man :
       Formula_manager.FormulaManagerFunctor(D).formula_manager
-    
     val reg_to_var : (register_name, Vine.var) Hashtbl.t
     val mem :
       Granular_memory.GranularMemoryFunctor(D).granular_second_snapshot_memory
+
     method get_path_cond : Vine.exp list
     method set_query_engine : Query_engine.query_engine -> unit
     method query_with_path_cond : Vine.exp -> bool
       -> (bool * Query_engine.sat_assign)
-    method query_condition : Vine.exp -> bool option -> int -> (bool * bool option) 
-    method query_unique_value : Vine.exp -> Vine.typ -> int64 option
-    method add_to_path_cond : Vine.exp -> unit
     method match_input_var : string -> int option
     method print_tree : out_channel -> unit
     method set_iter_seed : int -> unit
diff --git a/execution/granular_memory.ml b/execution/granular_memory.ml
index ea375de..285c9cd 100644
--- a/execution/granular_memory.ml
+++ b/execution/granular_memory.ml
@@ -3,7 +3,6 @@
 *)
 
 open Exec_domain;;
-open Exec_options;;
 
 module GranularMemoryFunctor =
   functor (D : DOMAIN) ->
@@ -286,8 +285,6 @@ struct
 	
     method on_missing m = missing <- m
       
-    method get_missing = missing
-      
     method private virtual with_chunk : int64 ->
       (gran64 -> int64 -> int -> (D.t * gran64)) -> D.t option
 
@@ -429,13 +426,6 @@ struct
 
     method virtual measure_size : int * int * int
 
-    method get_mem : (int64, gran64) Hashtbl.t =  Hashtbl.create 0
-      
-    method set_mem (mem : (int64, gran64) Hashtbl.t) = () 
-      (*let ret = Hashtbl.create 1 in
-      Hashtbl.replace ret 0L Absent64;
-      ret*)
-
   (* method make_snap () = failwith "make_snap unsupported"; ()
      method reset () = failwith "reset unsupported"; () *)
   end
@@ -514,7 +504,7 @@ struct
   class granular_hash_memory = object(self)
     inherit granular_memory
 
-    val mutable mem = Hashtbl.create 101
+    val mem = Hashtbl.create 101
 
     method private with_chunk addr fn =
       let which = Int64.to_int (Int64.logand addr 0x7L) in
@@ -546,27 +536,13 @@ struct
 	"[" ^ (gran64_to_string chunk) ^ "]"
 
     method clear () =
-      if !opt_trace_mem_snapshots = true then
-	(Printf.printf "GHM#clear called\n";
-	 (*Hashtbl.iter 
-	   (fun addr chunk ->
-	     let (exp,_) = gran64_get_long chunk missing addr in
-	     Printf.printf "%Lx %s\n" addr 
-	       (Vine.exp_to_string (D.to_symbolic_64 exp));) 
-	   mem;
-	 Printf.printf "-x-x-x-x-fin-x-x-x-x-\n\n";*)
-	);
       Hashtbl.clear mem
-	  
+
     method measure_size =
       let num_nodes = Hashtbl.fold (fun k v sum -> sum + gran64_size v) mem 0
       in
       let num_entries = Hashtbl.length mem in
 	(num_nodes, num_entries, 0)
-
-    method get_mem = mem
-      
-    method set_mem _mem = mem <- _mem;
   end
 
   class granular_snapshot_memory
@@ -685,82 +661,24 @@ struct
 	(ents_d + ents_m, nodes_d + nodes_m, conc_d + conc_m)
 
     method clear () = 
-      if !opt_trace_mem_snapshots = true then
-	Printf.printf "GSM#clear clearing diff\n";
       diff#clear ();
-      if !opt_trace_mem_snapshots = true then
-	Printf.printf "GSM#clear clearing main\n";
       main#clear ()
 	
     method make_snap () =
-      if !opt_trace_mem_snapshots = true then
-	Printf.printf "GSM#make_snap called\n";
       have_snap <- true
 	
     method reset () = 
-      if !opt_trace_mem_snapshots = true then
-	Printf.printf "GSM#reset called\n";
       diff#clear (); ()
-	
-    method get_snap () = have_snap
-      
-    (* This method should only be used to set level 4 memory have_snap to false *)
-    method set_snap b = have_snap <- b
-
-    method get_mem = diff#get_mem
-
-    method set_mem _mem = diff#set_mem _mem
-
-    method get_diff = diff
-
-    method get_missing = main#get_missing
   end
 
   class granular_second_snapshot_memory
-    (mem1_2:granular_snapshot_memory) (mem3_4:granular_snapshot_memory) =
+    (mem1_2:granular_snapshot_memory) (mem3:granular_memory) =
   object(self) 
-    inherit granular_snapshot_memory (mem1_2 :> granular_memory) 
-      (mem3_4 :> granular_memory)
-    val mutable f1_se : (int64, gran64) Hashtbl.t = Hashtbl.create 0 
-      
-    (*method inner_make_snap () = mem1_2#make_snap ()*)
-    method make_snap_self () =
-      have_snap <- true
+    inherit granular_snapshot_memory (mem1_2 :> granular_memory) mem3
       
-    method make_snap =
-      if ((mem1_2#get_snap ()) = false) then
-	(if !opt_trace_mem_snapshots = true then
-	    Printf.printf "GSSM#make_snap 1 -> 2\n";
-	  mem1_2#make_snap)
-      else if ((mem1_2#get_snap ()) = true) && ((self#get_snap ()) = false) then
-	(if !opt_trace_mem_snapshots = true then
-	    Printf.printf "GSSSM#make_snap 2 -> 3\n";	
-	 self#make_snap_self)
-      else if ((mem1_2#get_snap ()) = true) && ((self#get_snap ()) = true) && 
-	  ((mem3_4#get_snap ()) = false) then
-	(if !opt_trace_mem_snapshots = true then
-	    Printf.printf "GSSM#make_snap 3 -> 4\n";
-	 mem3_4#make_snap)
-      else failwith "oh snap!"
-	
-    method reset4_3 =
-      if !opt_trace_mem_snapshots = true then
-	Printf.printf "GSSM#reset4_3 4 -> 3 \n";
-      f1_se <- mem3_4#get_mem;
-      mem3_4#set_snap false;
-      mem3_4#reset
-
-    method reset =
-      if !opt_trace_mem_snapshots = true then
-	Printf.printf "GSSM#reset called\n";
-      mem3_4#set_snap false;
-      mem3_4#clear
-	
-    method get_level4 = 
-      let ret = mem3_4#get_diff in
-      (ret :> granular_hash_memory)
-end
-  
+    method inner_make_snap () = mem1_2#make_snap ()
+  end
+    
   class concrete_adaptor_memory (mem:Concrete_memory.concrete_memory) =
   object(self)
     method on_missing (m:int -> int64 -> D.t) = ()
@@ -794,14 +712,8 @@ end
       val mutable missing : (int -> int64 -> D.t) =
 	(fun _ -> failwith "Must call on_missing")
 
-      method get_mem : (int64, gran64) Hashtbl.t =  Hashtbl.create 0
-
-      method set_mem (mem: (int64, gran64) Hashtbl.t) = ()
-      
       method on_missing m = missing <- m
 
-      method get_missing = missing
-
       method store_byte  addr b = mem#store_byte  addr (D.to_concrete_8 b)
       method store_short addr s = mem#store_short addr (D.to_concrete_16 s)
       method store_word  addr w = mem#store_word  addr (D.to_concrete_32 w)
diff --git a/execution/granular_memory.mli b/execution/granular_memory.mli
index c668b56..5ccecea 100644
--- a/execution/granular_memory.mli
+++ b/execution/granular_memory.mli
@@ -63,8 +63,6 @@ sig
   class virtual granular_memory : object
     method on_missing : missing_t -> unit
 
-    method get_missing : (int -> int64 -> D.t)
-
     method private virtual store_common_fast :
       int64 -> (gran64 -> int -> gran64) -> unit
       
@@ -91,8 +89,6 @@ sig
     method virtual clear : unit -> unit
 
     method virtual measure_size : int * int * int
-    method get_mem : (int64, gran64) Hashtbl.t
-    method set_mem : (int64, gran64) Hashtbl.t -> unit
   end
     
   class granular_page_memory : object
@@ -147,8 +143,6 @@ sig
     method store_page : int64 -> string -> unit
     method clear : unit -> unit
     method measure_size : int * int * int
-    method get_mem : (int64, gran64) Hashtbl.t 
-    method set_mem : (int64, gran64) Hashtbl.t -> unit
   end
 
   class granular_hash_memory : object
@@ -176,8 +170,6 @@ sig
     method store_page : int64 -> string -> unit
     method clear : unit -> unit
     method measure_size : int * int * int
-    method get_mem : (int64, gran64) Hashtbl.t 
-    method set_mem : (int64, gran64) Hashtbl.t -> unit
   end
 
   class granular_snapshot_memory : granular_memory -> granular_memory ->
@@ -198,19 +190,13 @@ sig
     method store_page : int64 -> string -> unit
     method clear : unit -> unit
     method measure_size : int * int * int
-    method get_snap : unit -> bool
 
     method make_snap : unit -> unit
-    method set_snap : bool -> unit
     method reset : unit -> unit
-    method get_mem : (int64, gran64) Hashtbl.t
-    method set_mem : (int64, gran64) Hashtbl.t -> unit
-    method get_diff : granular_hash_memory
-    method get_missing : (int -> int64 -> D.t)
   end
 
   class granular_second_snapshot_memory :
-    granular_snapshot_memory -> granular_snapshot_memory ->
+    granular_snapshot_memory -> granular_memory ->
   object
     method on_missing : missing_t -> unit
     method maybe_load_byte  : int64 -> D.t option
@@ -228,20 +214,13 @@ sig
     method store_page : int64 -> string -> unit
     method clear : unit -> unit
     method measure_size : int * int * int
-    method get_snap : unit -> bool
 
     method make_snap : unit -> unit
-    method set_snap : bool -> unit
-    method make_snap_self : unit -> unit
     method reset : unit -> unit
-    method reset4_3 : unit -> unit
-    method get_mem : (int64, gran64) Hashtbl.t
-    method set_mem : (int64, gran64) Hashtbl.t -> unit
-    method get_diff : granular_hash_memory
-    method get_level4 : granular_hash_memory
-    method get_missing : (int -> int64 -> D.t)
+
+    method inner_make_snap : unit -> unit
   end
- 
+    
   class concrete_adaptor_memory : Concrete_memory.concrete_memory -> object
     method on_missing : missing_t -> unit
     method maybe_load_byte  : int64 -> D.t option
@@ -279,8 +258,5 @@ sig
     method store_page : int64 -> string -> unit
     method clear : unit -> unit
     method measure_size : int * int * int
-    method get_mem : (int64, gran64) Hashtbl.t
-    method set_mem : (int64, gran64) Hashtbl.t -> unit
-    method get_missing : (int -> int64 -> D.t)
   end
 end
diff --git a/execution/linux_syscalls.ml b/execution/linux_syscalls.ml
index 9e67c9b..ce41f62 100644
--- a/execution/linux_syscalls.ml
+++ b/execution/linux_syscalls.ml
@@ -78,8 +78,7 @@ type fd_extra_info = {
   mutable dirp_offset : int;
   mutable readdir_eof: int;
   mutable fname : string;
-  mutable snap_pos : int option Stack.t;
-  (*mutable snap_pos : int option;*)
+  mutable snap_pos : int option;
 }
 
 (* N.b. the argument order here is the opposite from D.assemble64,
@@ -190,9 +189,7 @@ object(self)
 	    (Unix.Unix_error(Unix.EBADF, "Bad (virtual) file handle", ""))
 
   val fd_info = Array.init 1024
-    (fun _ -> { dirp_offset = 0; readdir_eof = 0; fname = ""; snap_pos = Stack.create()
-	      (*snap_pos = None*) 
-	      })
+    (fun _ -> { dirp_offset = 0; readdir_eof = 0; fname = ""; snap_pos = None })
 
   val netlink_sim_sockfd = ref 1025
   val netlink_sim_seq = ref 0L
@@ -284,26 +281,16 @@ object(self)
 
   val the_break = ref None
 
-  (*val mutable saved_next_fresh_addr = 0L*)
-  (*val mutable saved_the_break = None*)
-  val mutable saved_next_fresh_addr = Stack.create()
-  val mutable saved_the_break = Stack.create() 
+  val mutable saved_next_fresh_addr = 0L
+  val mutable saved_the_break = None
 
   method private save_memory_state =
-    (*saved_next_fresh_addr <- next_fresh_addr;*)
-    Stack.push next_fresh_addr saved_next_fresh_addr;
-    (*saved_the_break <- !the_break*)
-    Stack.push !the_break saved_the_break;
+    saved_next_fresh_addr <- next_fresh_addr;
+    saved_the_break <- !the_break
 
   method private reset_memory_state =
-    (*next_fresh_addr <- saved_next_fresh_addr;*)
-    next_fresh_addr <- Stack.pop saved_next_fresh_addr;
-    if (Stack.length saved_next_fresh_addr = 0) then 
-      Stack.push next_fresh_addr saved_next_fresh_addr;
-    (*the_break := saved_the_break*)
-    the_break := Stack.pop saved_the_break;
-    if (Stack.length saved_the_break) = 0 then
-      Stack.push !the_break saved_the_break;
+    next_fresh_addr <- saved_next_fresh_addr;
+    the_break := saved_the_break
 
   method string_create len =
     try String.create len
@@ -712,149 +699,25 @@ object(self)
 
   method private save_sym_fd_positions = 
     Hashtbl.iter
-      (fun fd _ -> 
-	(*fd_info.(fd).snap_pos <- 
-	 Some (Unix.lseek (self#get_fd fd) 0 Unix.SEEK_CUR)*)
-	Stack.push (Some (Unix.lseek (self#get_fd fd) 0 Unix.SEEK_CUR)) 
-	  fd_info.(fd).snap_pos;
-      )
-      symbolic_fds
-
-  method private save_unix_fd_positions = 
-    for vt_fd = 0 to (Array.length unix_fds)-1 do 
-      if vt_fd > 2 then (
-	match unix_fds.(vt_fd) with
-	| Some _fd ->
-	  let cur_pos = Unix.lseek (self#get_fd vt_fd) 0 Unix.SEEK_CUR in
-	  (*Printf.printf "linux_syscalls#save_unix_fd_positions before len = %d fname = %s cur_pos = %d\n"
-	    (Stack.length fd_info.(vt_fd).snap_pos) fd_info.(vt_fd).fname cur_pos;*)
-	  Stack.push (Some cur_pos) fd_info.(vt_fd).snap_pos;
-	  (*Printf.printf "linux_syscalls#save_unix_fd_positions after len = %d fname = %s cur_pos = %d\n"
-	    (Stack.length fd_info.(vt_fd).snap_pos) fd_info.(vt_fd).fname cur_pos;*)
-	| _ -> ()
-      )
-    done
-
-  method private reset_unix_fd_positions =
-    for vt_fd = 0 to (Array.length unix_fds)-1 do 
-      if vt_fd > 2 then (
-	match unix_fds.(vt_fd) with
-	| Some _fd ->
-	  (*Printf.printf "linux_syscalls#reset_unix_fd_positions before len = %d fname = %s\n"
-	    (Stack.length fd_info.(vt_fd).snap_pos) fd_info.(vt_fd).fname;
-	  let snap_pos = *)
-	  let _ =
-	    match Stack.top fd_info.(vt_fd).snap_pos with
-	    | Some pos -> ignore(Unix.lseek (self#get_fd vt_fd) pos Unix.SEEK_SET); pos
-	    | None -> 0
-	  in
-	  if Stack.length fd_info.(vt_fd).snap_pos > 1 then
-	    ignore(Stack.pop fd_info.(vt_fd).snap_pos);
-	  (*Printf.printf "linux_syscalls#reset_unix_fd_positions after len = %d fname = %s snap_pos = %d\n"
-	    (Stack.length fd_info.(vt_fd).snap_pos) fd_info.(vt_fd).fname snap_pos;*)
-	| _ -> ()
-      )
-    done
-
-  method private reset_unix_fd_positions_to_base =
-    for vt_fd = 0 to (Array.length unix_fds)-1 do 
-      if vt_fd > 2 then (
-	match unix_fds.(vt_fd) with
-	| Some _fd ->
-	  (* Printf.printf "linux_syscalls#reset_unix_fd_positions before len = %d fname = %s vt_fd = %d\n"
-	    (Stack.length fd_info.(vt_fd).snap_pos) fd_info.(vt_fd).fname vt_fd; *)
-	  let _ = while Stack.length fd_info.(vt_fd).snap_pos > 1 do
-	      ignore(Stack.pop fd_info.(vt_fd).snap_pos);
-	    done 
-	  in
-	  (*let snap_pos = *)
-	  let _ =
-	    if (Stack.length fd_info.(vt_fd).snap_pos) > 0 then (
-	      match Stack.top fd_info.(vt_fd).snap_pos with
-	      | Some pos -> ignore(Unix.lseek (self#get_fd vt_fd) pos Unix.SEEK_SET); pos
-	      | None -> 0) 
-	    else 0
-	  in
-	  if Stack.length fd_info.(vt_fd).snap_pos > 1 then
-	    ignore(Stack.pop fd_info.(vt_fd).snap_pos);
-	(*Printf.printf "linux_syscalls#reset_unix_fd_positions after len = %d fname = %s snap_pos = %d\n"
-	  (Stack.length fd_info.(vt_fd).snap_pos) fd_info.(vt_fd).fname snap_pos;*)
-	| _ -> ()
-      );
-    done
-      
-  method private reset_sym_fd_positions =
-    Hashtbl.iter
-      (fun fd _ ->
-	 (*match fd_info.(fd).snap_pos with
-	   | Some pos -> ignore(Unix.lseek (self#get_fd fd) pos Unix.SEEK_SET)
-	   | None -> ()*)
-	(match Stack.top fd_info.(fd).snap_pos with
-	| Some pos -> ignore(Unix.lseek (self#get_fd fd) pos Unix.SEEK_SET)
-	| None -> ());
-	if Stack.length fd_info.(fd).snap_pos > 1 then
-	  ignore(Stack.pop fd_info.(fd).snap_pos);
-      )
+      (fun fd _ -> fd_info.(fd).snap_pos <- 
+	 Some (Unix.lseek (self#get_fd fd) 0 Unix.SEEK_CUR))
       symbolic_fds
 
-  method private reset_sym_fd_positions_to_base =
+  method private reset_sym_fd_positions = 
     Hashtbl.iter
       (fun fd _ ->
-	(*match fd_info.(fd).snap_pos with
+	 match fd_info.(fd).snap_pos with
 	   | Some pos -> ignore(Unix.lseek (self#get_fd fd) pos Unix.SEEK_SET)
-	  | None -> ()*)
-	let _ = while Stack.length fd_info.(fd).snap_pos > 1 do
-	  ignore(Stack.pop fd_info.(fd).snap_pos);
-	  done in
-	(match Stack.top fd_info.(fd).snap_pos with
-	| Some pos -> ignore(Unix.lseek (self#get_fd fd) pos Unix.SEEK_SET)
-	| None -> ());
-	if Stack.length fd_info.(fd).snap_pos > 1 then
-	  ignore(Stack.pop fd_info.(fd).snap_pos);
-      )
+	   | None -> ())
       symbolic_fds
 
   method make_snap = 
-    if !opt_trace_mem_snapshots = true then
-      Printf.printf "linux_syscalls#make_snap called\n";
     self#save_sym_fd_positions;
-    self#save_unix_fd_positions;
     self#save_memory_state
 
   method reset = 
-    if !opt_trace_mem_snapshots = true then
-      Printf.printf "linux_syscalls#reset called\n";
-    self#reset_sym_fd_positions_to_base;
-    self#reset_unix_fd_positions_to_base;
-    self#reset_memory_state
-
-  method make_f1_snap = 
-    if !opt_trace_mem_snapshots = true then
-      Printf.printf "linux_syscalls#make_f1_snap called\n";
-    self#make_snap ;
-    ()
-    
-  method reset_f1_snap = 
-    if !opt_trace_mem_snapshots = true then
-      Printf.printf "linux_syscalls#reset_f1_snap called\n";
     self#reset_sym_fd_positions;
-    self#reset_unix_fd_positions;
-    self#reset_memory_state;
-    ()
-
-  method make_f2_snap =
-    if !opt_trace_mem_snapshots = true then
-      Printf.printf "linux_syscalls#make_f2_snap called\n";
-    self#make_snap ;
-    ()
-
-  method reset_f2_snap =
-    if !opt_trace_mem_snapshots = true then
-      Printf.printf "linux_syscalls#reset_f2_snap called\n";
-    self#reset_sym_fd_positions;
-    self#reset_unix_fd_positions;
-    self#reset_memory_state;
-    ()
+    self#reset_memory_state
 
   method sys_access path mode =
     let oc_mode =
@@ -2859,96 +2722,6 @@ object(self)
 	   r6 = get_reg arg_regs.(6) in
 	 (r0, r1, r2, r3, r4, r5, r6)
      in
-     let read_1_reg_sym () = fm#get_reg_symbolic arg_regs.(0) in
-     let read_2_regs_sym () =
-       let ebx = read_1_reg_sym () and
-	   ecx = fm#get_reg_symbolic arg_regs.(1) in
-	 (ebx, ecx) in
-     let read_3_regs_sym () = 
-       let (ebx, ecx) = read_2_regs_sym () and
-	   edx = fm#get_reg_symbolic arg_regs.(2) in
-	 (ebx, ecx, edx) in
-     let read_4_regs_sym () =
-       let (ebx, ecx, edx) = read_3_regs_sym () and
-	   esi = fm#get_reg_symbolic arg_regs.(3) in
-	 (ebx, ecx, edx, esi) in
-     let read_5_regs_sym () =
-       let (ebx, ecx, edx, esi) = read_4_regs_sym () and
-	   edi = fm#get_reg_symbolic arg_regs.(4) in
-	 (ebx, ecx, edx, esi, edi) in
-     let read_6_regs_sym () =
-       let (ebx, ecx, edx, esi, edi) = read_5_regs_sym () and
-	   ebp = fm#get_reg_symbolic arg_regs.(5) in
-	 (ebx, ecx, edx, esi, edi, ebp) 
-     in
-     if (fm#get_in_f1_range ()) && (not !opt_dont_compare_syscalls) then (
-       Printf.printf "f1:syscall(%d)\n" syscall_num;
-       let (num_args, name) = Noop_syscalls.syscalls_x64.(syscall_num) in
-       Printf.printf "Recording Linux/x86-64 system call %d %s(%d)\n" 
-	 syscall_num name num_args;
-       let arg_list = 
-	 (if num_args = 1 then
-	     let arg1 = read_1_reg_sym () in
-	     [arg1]
-	  else if num_args = 2 then
-	    let (arg1, arg2) = read_2_regs_sym () in
-	    [arg1; arg2]
-	  else if num_args = 3 then
-	    let (arg1, arg2, arg3) = read_3_regs_sym () in
-	    [arg1; arg2; arg3]
-	  else if num_args = 4 then
-	    let (arg1, arg2, arg3, arg4) = read_4_regs_sym () in
-	    [arg1; arg2; arg3; arg4]
-	  else if num_args = 5 then
-	    let (arg1, arg2, arg3, arg4, arg5) = read_5_regs_sym () in
-		[arg1; arg2; arg3; arg4; arg5]
-	  else if num_args = 6 then
-	    let (arg1, arg2, arg3, arg4, arg5, arg6) = read_6_regs_sym () in
-	    [arg1; arg2; arg3; arg4; arg5; arg6]
-	  else [])
-       in
-       (*for i = 0 to num_args-1 do
-	 Printf.printf "arg%d = %s \n" i (V.exp_to_string (List.nth arg_list i));
-       done;*)
-       fm#add_f1_syscall_with_args syscall_num arg_list;
-     );
-     if (fm#get_in_f2_range ()) && (not !opt_dont_compare_syscalls) then (
-       Printf.printf "f2:syscall(%d)\n" syscall_num;
-       if fm#check_f2_syscall syscall_num = false then (
-	 Printf.printf "linux_syscalls:syscall divergence: raising DisqualifiedPath\n";
-	  raise DisqualifiedPath;);
-       let (num_args, name) = Noop_syscalls.syscalls_x64.(syscall_num) in
-       Printf.printf "Recording Linux/x86-64 system call %d %s(%d)\n" 
-	 syscall_num name num_args;
-       let arg_list = 
-	 (if num_args = 1 then
-	     let arg1 = read_1_reg_sym () in
-	     [arg1]
-	  else if num_args = 2 then
-	    let (arg1, arg2) = read_2_regs_sym () in
-	    [arg1; arg2]
-	  else if num_args = 3 then
-	    let (arg1, arg2, arg3) = read_3_regs_sym () in
-	    [arg1; arg2; arg3]
-	  else if num_args = 4 then
-	    let (arg1, arg2, arg3, arg4) = read_4_regs_sym () in
-	    [arg1; arg2; arg3; arg4]
-	  else if num_args = 5 then
-	    let (arg1, arg2, arg3, arg4, arg5) = read_5_regs_sym () in
-	    [arg1; arg2; arg3; arg4; arg5]
-	  else if num_args = 6 then
-	    let (arg1, arg2, arg3, arg4, arg5, arg6) = read_6_regs_sym () in
-	    [arg1; arg2; arg3; arg4; arg5; arg6]
-	  else [])
-       in
-       assert((List.length arg_list)=num_args);
-       (*for i = 0 to num_args-1 do
-	 Printf.printf "arg%d = %s \n" i (V.exp_to_string (List.nth arg_list i));
-       done;*)
-       if (fm#check_f2_syscall_args arg_list syscall_num) = true then (
-	 Printf.printf "linux_syscalls:syscalls argument divergence raising DisqualifiedPath\n";
-	 raise DisqualifiedPath; );
-     );
        ignore(0, read_7_regs);
        match (!opt_arch, syscall_num) with 
 	 | ((X86|ARM), 0) -> (* restart_syscall *)
@@ -4142,8 +3915,7 @@ object(self)
 	 | (X86, 217) -> (* pivot_root *)
 	     uh "Unhandled Linux system call pivot_root"
 	 | (ARM, 219) -> uh "Check whether ARM mincore syscall matches x86"
-	 | (X86, 218) (* mincore *) 
-         | (X64, 27) ->  
+	 | (X86, 218) -> (* mincore *)
 	     let (ebx, ecx, edx) = read_3_regs () in
 	     let addr = ebx and
 		 length = Int64.to_int ecx and
@@ -4732,7 +4504,7 @@ object(self)
 	     uh "Unhandled Linux system call clock_adjtime (343)"
 	 | (X86, 344) -> (* syncfs *)
 	     uh "Unhandled Linux system call syncfs (344)"
-	 | (X86, 345) -> (* sendmmsg *)
+       | (X86, 345) -> (* sendmmsg *)
            let (ebx, ecx, edx, esi) = read_4_regs () in
            let sockfd = Int64.to_int ebx and
                msg = ecx and
@@ -4766,9 +4538,8 @@ object(self)
 	     Printf.printf "Unknown Linux/ARM system call %d\n" syscall_num;
 	     uh "Unhandled Linux system call"
 	 | (X64, _) ->
-	   if !opt_ret_zero_missing_x64_syscalls = true then 
-	     put_return 0L
-	   else self#put_errno Unix.ENOSYS);
+	     Printf.printf "Unknown Linux/x86-64 system call %d\n" syscall_num;
+	     uh "Unhandled Linux system call");
     if !opt_trace_syscalls then
       let ret_val = match !opt_arch with
 	| (X86|ARM) -> fm#get_word_var ret_reg
diff --git a/execution/linux_syscalls.mli b/execution/linux_syscalls.mli
index 0ccbdc0..dfb2957 100644
--- a/execution/linux_syscalls.mli
+++ b/execution/linux_syscalls.mli
@@ -38,11 +38,6 @@ object
   method make_snap : unit
   method reset : unit
 
-  method make_f1_snap : unit
-  method reset_f1_snap : unit
-  method make_f2_snap : unit
-  method reset_f2_snap : unit
-
   method set_proc_identities : (int * int * int * int) option -> unit
 
   method get_pid : int
diff --git a/execution/noop_syscalls.ml b/execution/noop_syscalls.ml
index 5f6afc2..3748c20 100644
--- a/execution/noop_syscalls.ml
+++ b/execution/noop_syscalls.ml
@@ -388,9 +388,9 @@ let syscalls_x64 =
     (3, "msync");                  (*  26 *)
     (3, "mincore");                (*  27 *)
     (3, "madvise");                (*  28 *)
-    (3, "shmget");                 (*  29 *)
-    (3, "shmat");                  (*  30 *)
-    (3, "shmctl");                 (*  31 *)
+    (4, "shmget");                 (*  29 *)
+    (4, "shmat");                  (*  30 *)
+    (4, "shmctl");                 (*  31 *)
     (1, "dup");                    (*  32 *)
     (2, "dup2");                   (*  33 *)
     (0, "pause");                  (*  34 *)
@@ -423,11 +423,11 @@ let syscalls_x64 =
     (4, "wait4");                  (*  61 *)
     (2, "kill");                   (*  62 *)
     (1, "uname");                  (*  63 *)
-    (3, "semget");                 (*  64 *)
-    (3, "semop");                  (*  65 *)
+    (4, "semget");                 (*  64 *)
+    (4, "semop");                  (*  65 *)
     (4, "semctl");                 (*  66 *)
-    (1, "shmdt");                  (*  67 *)
-    (2, "msgget");                 (*  68 *)
+    (4, "shmdt");                  (*  67 *)
+    (4, "msgget");                 (*  68 *)
     (4, "msgsnd");                 (*  69 *)
     (5, "msgrcv");                 (*  70 *)
     (3, "msgctl");                 (*  71 *)
@@ -971,17 +971,17 @@ let syscalls_arm =
     (5, "getsockopt");             (* 295 *)
     (3, "sendmsg");                (* 296 *)
     (3, "recvmsg");                (* 297 *)
-    (3, "semop");                  (* 298 *)
-    (3, "semget");                 (* 299 *)
+    (4, "semop");                  (* 298 *)
+    (4, "semget");                 (* 299 *)
     (4, "semctl");                 (* 300 *)
     (4, "msgsnd");                 (* 301 *)
     (4, "msgrcv");                 (* 302 *)
-    (2, "msgget");                 (* 303 *)
+    (4, "msgget");                 (* 303 *)
     (4, "msgctl");                 (* 304 *)
-    (3, "shmat");                  (* 305 *)
-    (1, "shmdt");                  (* 306 *)
-    (3, "shmget");                 (* 307 *)
-    (3, "shmctl");                 (* 308 *)
+    (4, "shmat");                  (* 305 *)
+    (4, "shmdt");                  (* 306 *)
+    (4, "shmget");                 (* 307 *)
+    (4, "shmctl");                 (* 308 *)
     (5, "add_key");                (* 309 *)
     (4, "request_key");            (* 310 *)
     (5, "keyctl");                 (* 311 *)
@@ -1096,42 +1096,8 @@ object(self)
       else
 	let (num_args, name) = syscalls.(syscall_num) in
 	let args = read_regs num_args in
-	let args' =
-	  (match (name, args) with
-	     | ("open", [fd; flags; mode]) ->
-		 let flags_i = Int64.to_int (get_reg_i arg_regs.(1)) in
-		   if (flags_i land 0o100) = 0 then
-		     [fd; flags]
-		   else
-		     (* O_CREAT set *)
-		     [fd; flags; mode]
-	     | ("fcntl", [fd; cmd; arg]) ->
-		 let cmd_i = get_reg_i arg_regs.(1) in
-		   (match cmd_i with
-		      | 1L -> [fd; cmd] (* F_GETFD *)
-		      | 3L -> [fd; cmd] (* F_GETFL *)
-		      | 9L -> [fd; cmd] (* F_GETOWN *)
-		      | 11L -> [fd; cmd] (* F_GETSIG *)
-		      | 1025L -> [fd; cmd] (* F_GETLEASE *)
-		      | 1032L -> [fd; cmd] (* F_GETPIPE_SZ *)
-		      | _ -> [fd; cmd; arg])
-	     | ("futex", [uaddr; op; val1; timeout; uaddr2; val3]) ->
-		 let op_i = Int64.to_int (get_reg_i arg_regs.(1)) in
-		 let skip = "0 /* unused */" in
-		 let (timeout', uaddr2', val3') =
-		   match op_i with
-		     | (0|128) -> (timeout, skip, skip) (* FUTEX_WAIT *)
-		     | (1|129) -> (skip, skip, skip) (* FUTEX_WAKE *)
-		     | (2|130) -> (skip, skip, skip) (* FUTEX_FD *)
-		     | (3|131) -> (skip, uaddr2, skip) (* FUTEX_REQUEUE *)
-		     | (4|132) -> (skip, uaddr2, val3) (* FUTEX_CMP_REQUEUE *)
-		     | _ -> (timeout, uaddr2, val3)
-		 in
-		   [uaddr; op; val1; timeout'; uaddr2'; val3']
-	     | (_, _) -> args)
-	in
 	  if !opt_trace_syscalls then
-	    Printf.printf "%s(%s)" name (String.concat ", " args');
+	    Printf.printf "%s(%s)" name (String.concat ", " args);
 	  if name = "_exit" || name = "exit_group" then
 	    let status = get_reg_i arg_regs.(0) in
 	      Printf.printf "\n";
@@ -1163,8 +1129,4 @@ object(self)
   (* This class is stateless so these are also no-ops: *)
   method make_snap = ()
   method reset = ()
-  method make_f1_snap : unit = ()
-  method reset_f1_snap : unit = ()
-  method make_f2_snap : unit = ()
-  method reset_f2_snap : unit = ()
 end
diff --git a/execution/noop_syscalls.mli b/execution/noop_syscalls.mli
index 2024d54..c806033 100644
--- a/execution/noop_syscalls.mli
+++ b/execution/noop_syscalls.mli
@@ -1,12 +1,6 @@
-val syscalls_x64: ( int * string ) array 
-
 class noop_linux_special_handler : Fragment_machine.fragment_machine ->
 object
   method handle_special : string -> Vine.stmt list option
   method make_snap : unit
   method reset : unit
-  method make_f1_snap : unit
-  method reset_f1_snap : unit
-  method make_f2_snap : unit
-  method reset_f2_snap : unit
 end
diff --git a/execution/options_linux.ml b/execution/options_linux.ml
index c881f98..f50a950 100644
--- a/execution/options_linux.ml
+++ b/execution/options_linux.ml
@@ -59,16 +59,6 @@ let linux_cmdline_opts =
      " Simulate Linux system calls as having no effect");
     ("-trace-syscalls", Arg.Set(opt_trace_syscalls),
      " Print systems calls (like strace)");
-    ("-match-syscalls-in-addr-range", Arg.String
-       (add_delimited_info_4 opt_match_syscalls_addr_range ':'),
-     " addr1_start:addr1_end:addr2_start:addr2_end" ^ 
-       " Capture trace of system call numbers in address ranges specified by addr1_start, addr1_end," ^
-       " and addr2_start, addr2_end, and" ^
-       " raise DisqualifiedPath exception if" ^
-       " the sequence of system calls in the 2nd address range diverges from" ^
-       " the sequence of system calls seen in the 1st address range");
-    ("-return-zero-missing-x64-syscalls", Arg.Set(opt_ret_zero_missing_x64_syscalls),
-     " Return zero for missing X64 system calls");
     ("-prefix-out", Arg.String
        (fun s -> opt_prefix_out := Some s),
      "prefix Add a distinguishing prefix before the program's writes");
diff --git a/execution/special_handlers.ml b/execution/special_handlers.ml
index e18bd24..e122e6c 100644
--- a/execution/special_handlers.ml
+++ b/execution/special_handlers.ml
@@ -14,22 +14,17 @@ object(self)
   method private unhandle_syscall str =
     if !opt_trace_stopping then
       (Printf.printf "Not handling system call special %s\n" str;
-       fm#print_syscall_regs);
+       fm#print_regs);
     raise (UnhandledSysCall("System calls disabled"))
 
   method handle_special str : V.stmt list option =
     match str with
       | "int 0x80" -> self#unhandle_syscall str
       | "sysenter" -> self#unhandle_syscall str
-      | "syscall" -> self#unhandle_syscall str
       | _ -> None
 
   method make_snap : unit = ()
   method reset : unit = ()
-  method make_f1_snap : unit = ()
-  method reset_f1_snap : unit = ()
-  method make_f2_snap : unit = ()
-  method reset_f2_snap : unit = ()
 end
 
 class trap_special_nonhandler (fm : fragment_machine) =
@@ -40,12 +35,83 @@ object(self)
       | _ -> None
   method make_snap : unit = ()
   method reset : unit = ()
-  method make_f1_snap : unit = ()
-  method reset_f1_snap : unit = ()
-  method make_f2_snap : unit = ()
-  method reset_f2_snap : unit = ()
 end
 
+let translate_creq tool_str req_num =
+  match (tool_str, req_num) with
+    | ("FC",  0) -> Some "VALGRIND_MAKE_MEM_NOACCESS"
+    | ("FC",  1) -> Some "VALGRIND_MAKE_MEM_UNDEFINED"
+    | ("FC",  2) -> Some "VALGRIND_MAKE_MEM_DEFINED"
+    | ("FC",  3) -> Some "VALGRIND_DISCARD"
+    | ("FC",  4) -> Some "VALGRIND_CHECK_MEM_IS_ADDRESSABLE"
+    | ("FC",  5) -> Some "VALGRIND_CHECK_MEM_IS_DEFINED"
+    | ("FC",  6) -> Some "VALGRIND_DO_LEAK_CHECK"
+    | ("FC",  7) -> Some "VALGRIND_COUNT_LEAKS"
+    | ("FC",  8) -> Some "VALGRIND_GET_VBITS"
+    | ("FC",  9) -> Some "VALGRIND_SET_VBITS"
+    | ("FC", 10) -> Some "VALGRIND_CREATE_BLOCK"
+    | ("FC", 11) -> Some "VALGRIND_MAKE_MEM_DEFINED_IF_ADDRESSABLE"
+    | ("FC", 12) -> Some "FC_PUSH_ENCLOSE"
+    | ("FC", 13) -> Some "FC_POP_ENCLOSE"
+    | ("FC", 14) -> Some "FC_LEAK_WORD"
+    | ("FC", 15) -> Some "FC_MAYBE_LEAK_WORD"
+    | ("FC", 16) -> Some "FC_TAINT_WORD"
+    | ("FC", 17) -> Some "FC_UNTAINT_WORD"
+    | ("FC", 18) -> Some "FC_MD5SUM_BLOCK"
+    | ("FC", 19) -> Some "FC_PREPARE_ROLLBACK"
+    | ("FC", 20) -> Some "FC_PREPARE_ESCAPEE"
+    | ("FC", 21) -> Some "FC_DO_ROLLBACK"
+    | ("FC", 22) -> Some "FC_NOTE_ITERATION"
+    | _ -> None
+
+class vg_client_req_special_handler (fm : fragment_machine) =
+object(self)
+  method private handle_creq =
+    let eip = fm#get_eip in
+    let args_ptr = match !opt_arch with
+      | X86 -> fm#get_word_var R_EAX
+      | X64 -> fm#get_long_var R_RAX
+      | ARM -> fm#get_word_var R4
+    in
+    let req_id = match !opt_arch with
+      | (X86|ARM) -> fm#load_word_conc args_ptr
+      | X64 -> fm#load_long_conc args_ptr
+    in
+    let byte_str i64 = String.make 1 (Char.chr (Int64.to_int i64)) in
+    let tool_str = (byte_str (Int64.shift_right req_id 24)) ^
+      (byte_str (Int64.logand 0xffL (Int64.shift_right req_id 16)))
+    in
+    let req_num = Int64.to_int (Int64.logand req_id 0xffffL) in
+    let req_name = match translate_creq tool_str req_num with
+      | Some name -> name
+      | None -> Printf.sprintf "%s-%d" tool_str req_num
+    in
+    let arg_size = match !opt_arch with
+      | (X86|ARM) -> 4
+      | X64 -> 8
+    in
+    let at_off offset =
+      fm#load_word_conc (Int64.add args_ptr (Int64.of_int (arg_size * offset)))
+    in
+    let arg1 = at_off 1 and
+	arg2 = at_off 2 and
+	arg3 = at_off 3 and
+	arg4 = at_off 4 and
+	arg5 = at_off 5
+    in
+      if !opt_trace_client_reqs then
+	Printf.printf "0x%08Lx: %s(0x%Lx, 0x%Lx, 0x%Lx, 0x%Lx, 0x%Lx)\n"
+	  eip req_name arg1 arg2 arg3 arg4 arg5
+
+  method handle_special str : V.stmt list option =
+    match str with
+      | "Valgrind client request" -> self#handle_creq; Some []
+      | _ -> None
+  method make_snap : unit = ()
+  method reset : unit = ()
+end
+
+
 class cpuid_special_handler (fm : fragment_machine)
 =
 object(self)
@@ -94,10 +160,6 @@ object(self)
       | (_, _) -> None
   method make_snap : unit = ()
   method reset : unit = ()
-  method make_f1_snap : unit = ()
-  method reset_f1_snap : unit = ()
-  method make_f2_snap : unit = ()
-  method reset_f2_snap : unit = ()
 end
   
 class x87_emulator_special_handler (fm : fragment_machine) =
@@ -120,8 +182,4 @@ object(self)
       | _ -> None
   method make_snap : unit = ()
   method reset : unit = ()
-  method make_f1_snap : unit = ()
-  method reset_f1_snap : unit = ()
-  method make_f2_snap : unit = ()
-  method reset_f2_snap : unit = ()
 end
diff --git a/execution/special_handlers.mli b/execution/special_handlers.mli
index 4bc77ae..abc53f6 100644
--- a/execution/special_handlers.mli
+++ b/execution/special_handlers.mli
@@ -7,30 +7,25 @@ class linux_special_nonhandler : Fragment_machine.fragment_machine -> object
   method handle_special : string -> Vine.stmt list option
   method make_snap : unit
   method reset : unit
-  method make_f1_snap : unit
-  method reset_f1_snap : unit
-  method make_f2_snap : unit
-  method reset_f2_snap : unit
+end
+
+class vg_client_req_special_handler : Fragment_machine.fragment_machine ->
+object
+  method handle_special : string -> Vine.stmt list option
+  method make_snap : unit
+  method reset : unit
 end
 
 class trap_special_nonhandler : Fragment_machine.fragment_machine -> object
   method handle_special : string -> Vine.stmt list option
   method make_snap : unit
   method reset : unit
-  method make_f1_snap : unit
-  method reset_f1_snap : unit
-  method make_f2_snap : unit
-  method reset_f2_snap : unit
 end
 
 class cpuid_special_handler : Fragment_machine.fragment_machine -> object
   method handle_special : string -> Vine.stmt list option
   method make_snap : unit
   method reset : unit
-  method make_f1_snap : unit
-  method reset_f1_snap : unit
-  method make_f2_snap : unit
-  method reset_f2_snap : unit
 end
 
 class x87_emulator_special_handler : Fragment_machine.fragment_machine ->
@@ -38,8 +33,4 @@ object
   method handle_special : string -> Vine.stmt list option
   method make_snap : unit
   method reset : unit
-  method make_f1_snap : unit
-  method reset_f1_snap : unit
-  method make_f2_snap : unit
-  method reset_f2_snap : unit
 end
diff --git a/execution/sym_path_frag_machine.ml b/execution/sym_path_frag_machine.ml
index 848a4bb..c54d252 100644
--- a/execution/sym_path_frag_machine.ml
+++ b/execution/sym_path_frag_machine.ml
@@ -216,32 +216,10 @@ struct
       if path_cond = [] && !opt_extra_conditions <> [] then
 	List.iter
 	  (fun cond ->
-	    (match cond with
-	    | V.BinOp(V.EQ,V.Lval(V.Temp(var_name)),
-		      V.Constant(V.Int(V.REG_8,const_val))) ->
-	      (*Printf.printf "ensure_extra_conditions found exp of type 1\n";*)
-	      form_man#add_special_ec_var var_name 
-		(V.Constant(V.Int(V.REG_8,const_val)))
-	    | V.BinOp(V.EQ,V.Lval(V.Temp(var_name)),
-		      V.Constant(V.Int(V.REG_64,const_val))) ->
-	      (*Printf.printf "ensure_extra_conditions found exp of type 2\n";*)
-	      form_man#add_special_ec_var var_name 
-		(V.Constant(V.Int(V.REG_64,const_val)))
-	    | V.BinOp(V.EQ,V.Constant(V.Int(V.REG_8,const_val)),
-		      V.Lval(V.Temp(var_name))) ->
-	      (*Printf.printf "ensure_extra_conditions found exp of type 3\n";*)
-	      form_man#add_special_ec_var var_name 
-		(V.Constant(V.Int(V.REG_8,const_val)))
-	    | V.BinOp(V.EQ,V.Constant(V.Int(V.REG_64,const_val)),
-		      V.Lval(V.Temp(var_name))) ->
-	      (*Printf.printf "ensure_extra_conditions found exp of type 4\n";*)
-	      form_man#add_special_ec_var var_name 
-		(V.Constant(V.Int(V.REG_64,const_val)))
-	    | _ -> ());
-	    (* Similar to self#add_to_path_cond, but without the call
-	       to ensure_extra_conditions. *)
-	    path_cond <- cond :: path_cond;
-	    self#push_cond_to_qe cond)
+	     (* Similar to self#add_to_path_cond, but without the call
+		to ensure_extra_conditions. *)
+	     path_cond <- cond :: path_cond;
+	     self#push_cond_to_qe cond)
 	  (List.rev !opt_extra_conditions)
 
     method get_path_cond =
@@ -289,16 +267,6 @@ struct
     method query_with_path_cond cond verbose =
       self#query_with_path_cond_wcache cond verbose true
 
-    method query_condition cond_e choice ident = 
-      dt#start_new_query_binary;
-      let b = match choice with 
-	| None -> self#extend_pc_random cond_e true ident 
-	| Some bit -> self#extend_pc_known cond_e true ident bit
-      in
-      let choices = dt#check_last_choices in
-      dt#count_query;
-      (b, choices)
-
     method private query_with_path_cond_wcache cond verbose with_cache =
       self#ensure_extra_conditions;
       Query_engine.query_extra_counter := 1 + self#get_depth;
@@ -423,17 +391,6 @@ struct
 		 Printf.printf "Unique!\n%!";
 	       Some v)
 
-    method query_relevance v exp =
-      let exp' = form_man#prime_var_in_exp v exp in
-      let neq_e = V.BinOp(V.NEQ, exp, exp') in
-      let (is_sat, ce) = self#query_with_path_cond neq_e true in
-	if is_sat then
-	  Printf.printf "Relevance of %s confirmed by query\n"
-	    (V.var_to_string v)
-	else
-	  Printf.printf "Irrelevant according to query\n";
-	is_sat
-
     method private check_concolic_value exp ty =
       let conc_val = form_man#eval_expr exp in
       let conc_e = V.Constant(V.Int(ty, conc_val)) in
@@ -499,8 +456,6 @@ struct
        0x68yy Memory long concretize
        0x6ayy Misc. concretize
        0x6byy Binop concretize
-       0x6cyy Adaptor expression concretize, yy is argnum*10+(type!=0 && type!=1)
-       0x6dyy Syscall argument expr added by SPFM#query_condition, yy is argnum*10
        0x7100 on_missing_random
        0x81yy SRFM load, base choice
        0x82yy SRFM load, offset concretize, yy is bit or 0x80 + try
@@ -663,9 +618,6 @@ struct
 		if !opt_trace_conditions then 
 		  Printf.printf "Symbolic branch condition (0x%08Lx) %s\n"
 		    (self#get_eip) (V.exp_to_string e);
-		if !opt_track_sym_usage then
-		  form_man#check_sym_usage e "branch condition"
-		    false self#query_relevance;
 		if !opt_concrete_path then
 		  self#eval_bool_exp_conc_path e ident
 		else 
@@ -737,9 +689,6 @@ struct
 	    if !opt_trace_conditions then 
 	      Printf.printf "Symbolic branch condition (0x%08Lx) %s\n"
 		(self#get_eip) (V.exp_to_string e);
-	    if !opt_track_sym_usage then
-	      form_man#check_sym_usage e "branch condition"
-		false self#query_relevance;
 	    if !opt_concrete_path then
 	      let (b, _) = self#eval_bool_exp_conc_path e ident in
 		b
@@ -849,11 +798,7 @@ struct
 	   if eip = eip' then
 	     let str = self#eval_expr_to_string expr in
 	       Printf.printf "At %08Lx, %s is %s\n"
-		 eip e_str str;
-	       if !opt_track_sym_usage then
-		 let e = self#eval_expr_to_symbolic_expr expr in
-		   form_man#check_sym_usage e "tracepoint"
-		     false self#query_relevance)
+		 eip e_str str)
 	!opt_tracepoints;
       List.iter
 	(fun (eip', e_str, expr) ->
diff --git a/execution/sym_path_frag_machine.mli b/execution/sym_path_frag_machine.mli
index efe02af..0ad13b8 100644
--- a/execution/sym_path_frag_machine.mli
+++ b/execution/sym_path_frag_machine.mli
@@ -35,12 +35,8 @@ sig
     method query_with_path_cond : Vine.exp -> bool
       -> (bool * Query_engine.sat_assign)
 
-    method query_condition : Vine.exp -> bool option -> int -> (bool * bool option) 
-
     method query_unique_value : Vine.exp -> Vine.typ -> int64 option
 
-    method query_relevance : Vine.var -> Vine.exp -> bool
-
     method follow_or_random : bool 
 
     method query_with_pc_choice : Vine.exp -> bool -> int -> (unit -> bool)
@@ -82,9 +78,6 @@ sig
       
     method reset : unit -> unit
 
-    method conc_mem_struct_adaptor: bool -> unit
-    method sym_region_struct_adaptor: unit
-    
     method after_exploration : unit
 
     method init_prog : Vine.program -> unit
@@ -102,24 +95,16 @@ sig
     method private on_missing_symbol_m :
       Granular_memory.GranularMemoryFunctor(D).granular_memory
       -> string -> unit
-    method private on_missing_symbol_m_lim :
-      Granular_memory.GranularMemoryFunctor(D).granular_memory
-      -> string -> int64 -> unit
     method make_regs_zero : unit
     method make_regs_symbolic : unit
     method load_x86_user_regs : Temu_state.userRegs -> unit
     method print_regs : unit
-    method print_syscall_regs : unit
     method printable_word_reg : Fragment_machine.register_name -> string
     method printable_long_reg : Fragment_machine.register_name -> string
     method store_byte  : int64 -> D.t -> unit
     method store_short : int64 -> D.t -> unit
     method store_word  : int64 -> D.t -> unit
     method store_long  : int64 -> D.t -> unit
-
-    method load_sym : int64 -> int -> Vine.exp
-    method store_sym : int64 -> int -> Vine.exp -> unit
-
     method store_byte_conc  : int64 -> int   -> unit
     method store_short_conc : int64 -> int   -> unit
     method store_word_conc  : int64 -> int64 -> unit
@@ -174,36 +159,6 @@ sig
       Fragment_machine.register_name -> int -> unit
     method set_word_var_second_byte :
       Fragment_machine.register_name -> int -> unit
-    method get_fresh_symbolic : string -> int -> Vine.exp
-    method get_reg_symbolic : 
-      Fragment_machine.register_name -> Vine.exp
-    method query_exp : Vine.exp -> Vine.exp -> unit
-    method simplify_exp : Vine.exp -> Vine.exp
-    method set_reg_symbolic : 
-      Fragment_machine.register_name -> Vine.exp -> unit
-    
-    method make_f1_sym_snap : unit 
-    method make_f1_conc_snap : unit 
-    method save_f1_sym_se : unit
-    method save_f1_conc_se : unit
-    method make_f2_sym_snap : unit
-    method make_f2_conc_snap : unit
-    method compare_sym_se : unit
-    method compare_conc_se : unit
-    method make_f1_special_handlers_snap : unit
-    method reset_f1_special_handlers_snap : unit
-    method make_f2_special_handlers_snap : unit
-    method reset_f2_special_handlers_snap : unit
-
-    method save_arg_regs : int64 -> unit
-    method add_f1_store : int64 -> unit
-    method add_f2_store : int64 -> unit
-    method match_writes : unit -> bool
-    method get_saved_arg_regs : unit -> Vine.exp list
-    method reset_saved_arg_regs : unit
-    method load_byte_symbolic  : int64 -> Vine.exp
-    method store_byte_symbolic  : int64 -> Vine.exp -> unit
-    method make_table_lookup : (Vine.exp list) -> Vine.exp -> int -> Vine.typ -> Vine.exp
     method set_word_reg_symbolic :
       Fragment_machine.register_name -> string -> unit
     method set_word_reg_concolic :
@@ -282,27 +237,7 @@ sig
     method get_form_man :
       Formula_manager.FormulaManagerFunctor(D).formula_manager
     val reg_to_var :(Fragment_machine.register_name, Vine.var) Hashtbl.t
-
-
-    val mutable in_f1_range: bool
-    val mutable in_f2_range: bool
-    val mutable f1_syscalls: int list
-    val mutable f1_syscalls_args: Vine.exp list
-    val mutable f2_syscalls_num: int 
-    val mutable f2_syscalls_arg_num: int 
-    method get_in_f1_range: unit -> bool
-    method get_in_f2_range: unit -> bool
-    method add_f1_syscall_with_args: int -> Vine.exp list -> unit
-    method check_f2_syscall: int -> bool
-    method check_f2_syscall_args: Vine.exp list -> int -> bool
-    method match_syscalls: unit -> bool
-    method reset_syscalls: unit
-    method reset_struct_counts: unit 
-    
-    method restrict_symbolic_expr : Fragment_machine.register_name list -> int -> (Vine.exp -> Vine.exp) -> unit
-    method check_adaptor_condition : Vine.exp -> unit
- 
-   val mem :
+    val mem :
       Granular_memory.GranularMemoryFunctor(D).granular_second_snapshot_memory
     method make_x86_segtables_symbolic : unit
     method store_word_special_region :
diff --git a/execution/sym_region_frag_machine.ml b/execution/sym_region_frag_machine.ml
index 13953da..889d70c 100644
--- a/execution/sym_region_frag_machine.ml
+++ b/execution/sym_region_frag_machine.ml
@@ -16,7 +16,6 @@ open Granular_memory;;
 open Fragment_machine;;
 open Decision_tree;;
 open Sym_path_frag_machine;;
-open Vine_util;;
 
 module SymRegionFragMachineFunctor =
   functor (D : DOMAIN) ->
@@ -25,9 +24,6 @@ struct
   module GM = GranularMemoryFunctor(D)
   module SPFM = SymPathFragMachineFunctor(D)
 
-  type region_location = SingleLocation of int option * int64
-			 | TableLocation of int option * V.exp * int64
-
   let reg_addr () = match !opt_arch with
     | (X86|ARM) -> V.REG_32
     | X64 -> V.REG_64
@@ -112,13 +108,7 @@ struct
 	| V.Unknown(_) ->
 	    failwith "Unhandled unknown in narrow_bitwidth"
     in
-    let f_traced loop e =
-      Printf.printf "Narrow bitwidth of %s:\n" (V.exp_to_string e);
-      let i = f loop e in
-	Printf.printf "Narrow bitwidth of %s is %d\n" (V.exp_to_string e) i;
-	i
-    in
-      FormMan.map_expr_temp form_man e (if false then f_traced else f) combine
+      FormMan.map_expr_temp form_man e f combine
 
   (* Similar to narrow_bitwidth, but count negative numbers of small
      absolute value (i.e. with many leading 1s) as narrow as well. I
@@ -183,7 +173,8 @@ struct
     match (!opt_narrow_bitwidth_cutoff, (reg_addr ())) with
       | ((Some i), _) -> i
       | (_, V.REG_32) -> 23
-      | (_, V.REG_64) -> 40
+      | (_, V.REG_64) -> 23 (* also experimented with 40,
+			       not clear what's best *)
       | (_, _) -> 23
 
   let ctz i =
@@ -254,30 +245,10 @@ struct
       !l
 
   let split_terms e form_man =
-    (*Printf.printf "split_terms e = %s\n" (V.exp_to_string e);*)
-    (* x | y = x - (x & m) + ((x & m) | y)
-       where m is a bitmask >= y. *)
-    let split_or loop e_wide e_narrow narrow_wd =
-      assert(narrow_wd >= 0); (* x & 0 should have been optimized away *)
-      let mask = Int64.pred (Int64.shift_left 1L narrow_wd) in
-      let ty_y = Vine_typecheck.infer_type None e_narrow in
-      let masked = V.BinOp(V.BITAND, e_wide,
-			   V.Constant(V.Int(ty_y, mask))) in
-	(loop e_wide) @
-	  [V.UnOp(V.NEG, masked);
-	   V.BinOp(V.BITOR, masked, e_narrow)]
-    in
     let rec loop e =
-      (*Printf.printf "    split_terms inside loop e = %s\n" (V.exp_to_string e);*)
       match e with
 	| V.BinOp(V.PLUS, e1, e2) -> (loop e1) @ (loop e2)
-	| V.Ite(cond, V.BinOp(V.PLUS, e1, e2), V.BinOp(V.PLUS, e1', e3))
-	    when e1 = e1' ->
-	    (loop e1) @ (loop (V.Ite(cond, e2, e3)))
-	| V.Ite(cond, V.BinOp(V.PLUS, e1, e2), V.BinOp(V.PLUS, e3, e2'))
-	    when e2 = e2' ->
-	    (loop (V.Ite(cond, e1, e3))) @ (loop e2)
-	| V.BinOp(V.BITAND, e, V.Constant(V.Int(ty, v)))
+(*	| V.BinOp(V.BITAND, e, V.Constant(V.Int(ty, v)))
 	    when is_high_mask ty v ->
 	    (* x & 0xfffffff0 = x - (x & 0xf), etc. *)
 	    (loop e) @
@@ -285,34 +256,30 @@ struct
 		 (V.UnOp(V.NEG,
 			 V.BinOp(V.BITAND, e,
 				 V.UnOp(V.NOT, V.Constant(V.Int(ty, v)))))))
-	| V.BinOp(V.BITOR, e1, V.BinOp(V.BITOR, e2, e3))
-	| V.BinOp(V.BITOR, V.BinOp(V.BITOR, e1, e2), e3)
-	    ->
-	    let w1 = narrow_bitwidth form_man e1 and
-		w2 = narrow_bitwidth form_man e2 and
-		w3 = narrow_bitwidth form_man e3 in
-	      if min w1 (min w2 w3) <= 8 then
-		(if w1 <= w2 && w1 <= w3 then
-		   split_or loop (V.BinOp(V.BITOR, e2, e3)) e1 w1
-		 else if w2 <= w1 && w2 <= w3 then
-		   split_or loop (V.BinOp(V.BITOR, e1, e3)) e2 w2
-		 else
-		   (assert(w3 <= w1 && w3 <= w2);
-		    split_or loop (V.BinOp(V.BITOR, e1, e2)) e3 w3))
-	      else
-		[e]
 	| V.BinOp(V.BITOR, e1, e2) ->
 	    let w1 = narrow_bitwidth form_man e1 and
 		w2 = narrow_bitwidth form_man e2 in
 (* 	      Printf.printf "In %s (OR) %s, widths are %d and %d\n" *)
 (* 		(V.exp_to_string e1) (V.exp_to_string e2) w1 w2; *)
 	      if min w1 w2 <= 8 then
-		(if w1 < w2 then
-		   split_or loop e2 e1 w1
-		 else
-		   split_or loop e1 e2 w2)
+		(* x | y = x - (x & m) + ((x & m) | y)
+		   where m is a bitmask >= y. *)
+		let (e_x, e_y, w) = 
+		  if w1 < w2 then
+		    (e2, e1, w1)
+		  else
+		    (e1, e2, w2)
+		in
+		  assert(w >= 0); (* x & 0 should have been optimized away *)
+		  let mask = Int64.pred (Int64.shift_left 1L w) in
+		  let ty_y = Vine_typecheck.infer_type None e_y in
+		  let masked = V.BinOp(V.BITAND, e_x,
+				       V.Constant(V.Int(ty_y, mask))) in
+		    (loop e_x) @ 
+		      [V.UnOp(V.NEG, masked);
+		       V.BinOp(V.BITOR, masked, e_y)]
 	      else
-		[e] 
+		[e] *)
 	| V.Lval(V.Temp(var)) ->
 	    FormMan.if_expr_temp form_man var
 	      (fun e' -> loop e') [e] (fun v -> ())
@@ -407,9 +374,8 @@ struct
 	  (match (classify_term form_man x), (classify_term form_man y) with
 	     | (ExprOffset(_)|ConstantOffset(_)),
 	       (ExprOffset(_)|ConstantOffset(_)) ->
-	       ExprOffset(e)
-	     | _ -> 
-	       AmbiguousExpr(e)
+		 ExprOffset(e)
+	     | _ -> AmbiguousExpr(e)
 	  )
       (* Similar pattern where we don't have the sign extend, but
 	 we do have something and its negation *)
@@ -423,8 +389,7 @@ struct
 	     | (ExprOffset(_)|ConstantOffset(_)),
 	       (ExprOffset(_)|ConstantOffset(_)) ->
 		 ExprOffset(e)
-	     | _ -> 
-	       AmbiguousExpr(e)
+	     | _ -> AmbiguousExpr(e)
 	  )
       (* Occurs as an optimization of bitwise ITE: *)
       | V.BinOp(V.BITAND, x, V.UnOp(V.NOT, V.Cast(V.CAST_SIGNED, _, _)))
@@ -455,12 +420,6 @@ struct
 	       (ExprOffset(_)|ConstantOffset(_)) -> ExprOffset(e)
 	     | _,_ -> AmbiguousExpr(e))
 
-      | V.BinOp(V.XOR, e1, e2)
-	->
-	  (match (classify_term form_man e1), (classify_term form_man e2) with
-	     | (ExprOffset(_)|ConstantOffset(_)),
-	       (ExprOffset(_)|ConstantOffset(_)) -> ExprOffset(e)
-	     | _,_ -> AmbiguousExpr(e))
 
 (*       | V.BinOp(V.BITAND, _, _) *)
 (*       | V.BinOp(V.BITOR, _, _) (* XXX happens in Windows 7, don't know why *) *)
@@ -518,339 +477,44 @@ struct
   class sym_region_frag_machine (dt:decision_tree) = object(self)
     inherit SPFM.sym_path_frag_machine dt as spfm
 
-    val mutable regions : GM.granular_snapshot_memory list = []
-    val mutable region_conc_addr_h = Hashtbl.create 101
-    val mutable conc_addr_region_h = Hashtbl.create 101
-    val mutable sym_input_region_l = []
+    val mutable regions = []
     val region_vals = Hashtbl.create 101
 
-    (* per execution path (region expression != 0) query is maintained in
-       region_val_queried *)
-    val region_val_queried = Hashtbl.create 101
-    
-    (* per execution path region expression to region number mapping is 
-       maintained in region_vals_per_path *)
-    val region_vals_per_path = Hashtbl.create 101
-    val mutable have_snap = false
-    val mutable f1_hash_list : (((int64, GM.gran64) Hashtbl.t) list )= []
-    val mutable f2_hash_list : (((int64, GM.gran64) Hashtbl.t) list )= []
-
     val mutable location_id = 0L
 
     method set_eip i =
       location_id <- i;
       spfm#set_eip i
 
-    (* eip hook to track change in region contents as execution proceeds *)
-    method private print_region r_num = 
-      try
-	let tmp_val = (List.nth regions r_num)#load_long 0L in
-	Printf.printf "SRFM#print_reg regions[%d][0] = %s\n" 
-	  r_num (D.to_string_64 tmp_val)
-      with Failure("nth") -> 
-	Printf.printf "SRFM#print_reg regions.length = %d\n" 
-	  (List.length regions);
-	
-    method start_symbolic =
-      spfm#start_symbolic ;
-      (* self#add_extra_eip_hook (fun fm _ -> self#print_reg 15 );  *)
-	
     val sink_mem = new GM.granular_sink_memory
 
     method private region r =
       match r with
 	| None -> (sink_mem :> (GM.granular_memory))
 	| Some 0 -> (mem :> (GM.granular_memory))
-	| Some r_num -> ((List.nth regions (r_num - 1)) :> GM.granular_memory)
-
-    method private region_load r size addr =
-      let (mem, conc_addr) = 
-	match r with
-	| None -> ((sink_mem :> (GM.granular_memory)), 0L)
-	| Some 0 -> ((mem :> (GM.granular_memory)), 0L)
-	| Some r_num -> 
-	  let conc_addr = 
-	    if Hashtbl.mem region_conc_addr_h r_num then
-	      Hashtbl.find region_conc_addr_h r_num 
-	    else 0L 
-	  in
-	  if conc_addr = 0L then ((self#region r), 0L) 
-	  else ((self#region (Some 0)), conc_addr) 
-      in
-      let new_addr = (Int64.add conc_addr addr) in
-      match size with
-      | 8 -> mem#load_byte new_addr
-      | 16 -> mem#load_short new_addr
-      | 32 -> mem#load_word new_addr
-      | 64 -> mem#load_long new_addr
-      | _ -> failwith "wrong size passed to region_load"
-
-    method private region_store r size addr value =
-      let (mem, conc_addr) = 
-	match r with
-	| None -> ((sink_mem :> (GM.granular_memory)), 0L)
-	| Some 0 -> ((mem :> (GM.granular_memory)), 0L)
-	| Some r_num -> 
-	  let conc_addr = 
-	    if Hashtbl.mem region_conc_addr_h r_num then 
-	      Hashtbl.find region_conc_addr_h r_num 
-	    else 0L 
-	  in
-	  if conc_addr = 0L then ((self#region r), 0L) 
-	  else ((self#region (Some 0)), conc_addr) 
-      in
-      let new_addr = (Int64.add conc_addr addr) in
-      match size with
-      | 8 -> mem#store_byte new_addr value
-      | 16 -> mem#store_short new_addr value
-      | 32 -> mem#store_word new_addr value
-      | 64 -> mem#store_long new_addr value
-      | _ -> failwith "wrong size password to region_store"
-
-    method make_f1_sym_snap =
-      if !opt_trace_mem_snapshots = true then
-	Printf.printf "SRFM#make_sym_snap called\n";
-      List.iter (fun m -> m#make_snap ();) regions;
-      have_snap <- true;
-      ()
-	
-    method save_f1_sym_se =
-      List.iteri (fun ind ele -> 
-	let f1_hash = Hashtbl.copy (ele#get_mem) in
-	f1_hash_list <- f1_hash_list @ [f1_hash];
-      ) regions;
-      
-      if !opt_trace_mem_snapshots = true then
-	Printf.printf "SRFM#save_sym_se saving f1_hash_list.length = %d\n"
-	  (List.length f1_hash_list);
-      ()
-
-    method make_f2_sym_snap =
-      if !opt_trace_mem_snapshots = true then
-	Printf.printf "SRFM#make_f2_sym_snap called\n";
-      List.iter (fun m -> 
-	if (m#get_snap ()) = false then
-	  failwith "unsnapped region being reset, panic!";
-	m#reset ();) regions;
-      have_snap <- false;
-      ()
-
-    method compare_sym_se =
-      if !opt_trace_mem_snapshots = true then
-	Printf.printf "SRFM#compare_sym_se called len(f1_h_l) = %d len(f2_h_l)=%d\n"
-	  (List.length f1_hash_list) (List.length f2_hash_list);
-      
-      List.iteri (fun ind ele -> 
-	let f2_hash = Hashtbl.copy (ele#get_mem) in
-	f2_hash_list <- f2_hash_list @ [f2_hash];
-      ) regions;
-
-      let inequiv = ref 0 in
-      let f2_hash_list_len = List.length f2_hash_list in
-      let f1_hash_list_len = List.length f1_hash_list in
-      if !opt_trace_mem_snapshots = true then
-	Printf.printf "f1_hash_list_len = %d f2_hash_list_len = %d\n"
-	  f1_hash_list_len f2_hash_list_len;
-      if f1_hash_list_len <> 0 || f2_hash_list_len <> 0 then (
-	(* Compare each of f1's symbolic region writes with f2 *)
-	List.iteri ( fun ind ele ->
-	  (* If region has concrete address then fragment_machine#compare_conc_se
-	     will do the side-effect equivalence checking for this region *)
-	  if (Hashtbl.mem region_conc_addr_h (ind+1)) = false then (
-	    if ind >= f2_hash_list_len then 
-	      failwith "region list became smaller after f2, panic!"
-	    else (
-	      Hashtbl.iter ( fun addr chunk ->
-	      (List.nth regions ind)#set_mem (List.nth f1_hash_list ind);
-		let f1_exp = (List.nth regions ind)#load_long addr in
-		(List.nth regions ind)#set_mem (List.nth f2_hash_list ind);
-		let f2_exp = (List.nth regions ind)#load_long addr in
-		if !opt_trace_mem_snapshots = true then
-		  Printf.printf "SRFM#compare_sym_se region = %d addr = %Ld f1_exp = %s f2_exp = %s\n"
-		    ind addr (D.to_string_64 f1_exp) (D.to_string_64 f2_exp);
-		self#query_exp (D.to_symbolic_64 f1_exp) (D.to_symbolic_64 f2_exp);
-	      ) ele;
-	    ));
-	) f1_hash_list;
-	
-	(* Compare each of f2's symbolic region writes with f1 *)
-	List.iteri ( fun ind ele ->
-	  (* If region has concrete address then fragment_machine#compare_conc_se
-	     will do the side-effect equivalence checking for this region *)
-	  if (Hashtbl.mem region_conc_addr_h (ind+1)) = false then (
-	    if (ind >= f1_hash_list_len) && ((Hashtbl.length ele) <> 0) then 
-	      inequiv := 1
-	    else (
-	      Hashtbl.iter ( fun addr chunk ->
-		let f2_exp = (List.nth regions ind)#load_long addr in
-		(List.nth regions ind)#set_mem (List.nth f1_hash_list ind);
-		let f1_exp = (List.nth regions ind)#load_long addr in
-		(List.nth regions ind)#set_mem (List.nth f2_hash_list ind);
-		if !opt_trace_mem_snapshots = true then
-		  Printf.printf "SRFM#compare_sym_se region = %d addr = %Ld f1_exp = %s f2_exp = %s\n"
-		    ind addr (D.to_string_64 f1_exp) (D.to_string_64 f2_exp);
-		self#query_exp (D.to_symbolic_64 f1_exp) (D.to_symbolic_64 f2_exp);
-	      ) ele;
-	    ));
-	) f2_hash_list;
-	
-	if !inequiv = 1 then
-	  ( if !opt_trace_mem_snapshots = true then
-	      Printf.printf "SRFM#compare_sym_se inequivalent side-effects in symbolic regions\n";
-	    raise DisqualifiedPath;);
-      );
-      List.iter (fun m -> m#reset ();) regions;
-      f1_hash_list <- [];
-      f2_hash_list <- [];
-      ()
-	
-    (* Check if two expressions are syntactically or semantically equal,
-       disqualify the path if not *)
-    method private query_exp exp1 exp2 =
-      if exp1 = exp2 then
-	(if !opt_trace_mem_snapshots = true then
-	    Printf.printf "equal side-effects %s = %s\n"
-	      (V.exp_to_string exp1) 
-	      (V.exp_to_string exp2);)
-      else (
-	let q_exp = V.BinOp(V.EQ, exp1, exp2) in
-	let (b,_) = (self#query_condition q_exp (Some true) 0x6df0) in
-	if b = false then (
-	  if !opt_trace_mem_snapshots = true then
-	    Printf.printf "inequivalent symbolic region side-effects %s!=\n%s\n" 
-	      (V.exp_to_string exp1) (V.exp_to_string exp2);
-	  raise DisqualifiedPath;
-	)
-	else (
-	  if !opt_trace_mem_snapshots = true then
-	    Printf.printf "equivalent side-effects %s=\n%s"
-	      (V.exp_to_string exp1) (V.exp_to_string exp2);
-	)
-      )
+	| Some r_num -> List.nth regions (r_num - 1)
 
     method private fresh_region =
       let new_idx = 1 + List.length regions in
-      let region = (new GM.granular_snapshot_memory 
-		      (new GM.granular_hash_memory) 
-		      (new GM.granular_hash_memory)) and
+      let region = (new GM.granular_hash_memory)  and
 	  name = "region_" ^ (string_of_int new_idx) in
-      regions <- regions @ [region];
-      (match (!opt_region_limit, !opt_zero_memory) with
-	 | (Some lim, _) ->
-	     spfm#on_missing_symbol_m_lim (region :> GM.granular_memory)
-	       name lim
-	 | (_, true) ->
-	     spfm#on_missing_zero_m (region :> GM.granular_memory)
-	 | _ ->
-	     spfm#on_missing_symbol_m (region :> GM.granular_memory) name);
-      if have_snap = true then region#make_snap ();
-      new_idx
+	regions <- regions @ [region];
+	if !opt_zero_memory then
+	  spfm#on_missing_zero_m region
+	else
+	  spfm#on_missing_symbol_m region name;
+	new_idx
 
     method private region_for e =
-      (* We dont allow a region-creating expression to be set to NULL 
-	 on this execution path while limiting this query to only once
-	 per execution path *)
-      (try 
-	 let _ = Hashtbl.find region_val_queried e in
-	 if !opt_trace_regions then
-	   Printf.printf "SRFM#region_for found in region_val_queried expr = %s\n"
-	     (V.exp_to_string e);
-       with Not_found ->
-	 let (b_is_regexp_null,_) = self#query_condition 
-	   (V.BinOp(V.NEQ, e, V.Constant(V.Int(V.REG_64, 0L))))
-	   (Some true) 0x6d01 in
-	 if !opt_trace_regions then
-	   Printf.printf "SRFM#region_for took branch %b in Not_found case expr = %s\n" 
-	     b_is_regexp_null (V.exp_to_string e);
-	 Hashtbl.replace region_val_queried e 1;
-	 if b_is_regexp_null <> true then raise NullDereference;
-      );
-      
       try
-	let ret = Hashtbl.find region_vals_per_path e in
-	if !opt_trace_regions then
-	  Printf.printf "SRFM#region_for found region number in region_vals, ret = %d expr = %s\n" 
-	    ret (V.exp_to_string e);
-	ret
+	Hashtbl.find region_vals e
       with Not_found ->
-	(* Try to eagerly concretize this address expression if it is a ITE expression *)
-	let const = ref [] in
-	let rec loop e =
-	  match e with
-	  | V.BinOp(op, e1, e2) -> V.BinOp(op, e1, e2)
-	  | V.Constant(V.Int(V.REG_64, _const)) -> 
-	    if (Int64.abs (fix_s32 _const)) > 4096L then (
-	      (* if a concrete address has already been used for eager
-		 concretization of region R, then add to the tail of const
-		 so that it does not force this region to be equal to region R *)
-	      if Hashtbl.length conc_addr_region_h = 0 || 
-		Hashtbl.mem conc_addr_region_h _const then
-		  const := !const @ [_const] 
-		else const := _const :: !const );
-	    V.Constant(V.Int(V.REG_64, _const))
-	  | V.Ite(ce, te, fe) ->
-	    V.Ite((loop ce), (loop te), (loop fe))
-	  | _ -> e
-	in
-	let conc_addr = ref 0L in
-	let _ = loop e in
-	List.iter ( fun _conc_addr -> 
-	  let exp = V.BinOp(V.EQ, e, V.Constant(V.Int(V.REG_64, _conc_addr))) in
-	  let (b,_) = self#query_condition exp (Some true) 0x6dfe in
-	  if b = true then ( (* save this region's concrete value *)
-	    if !opt_trace_regions then
-	      Printf.printf "SRFM#region_for using concrete address %Lx for %s\n"
-		_conc_addr (V.exp_to_string e);
-	    conc_addr := _conc_addr; )
-	  else ( 
-	    if !opt_trace_regions then
-	      Printf.printf "SRFM#region_for not using concrete address %Lx for %s\n"
-		_conc_addr (V.exp_to_string e);
-	  )
-	) !const;
-
-	(* adaptor symbolic formula fix: equivalent adaptor formulae should use 
-	   same region, if e is equivalent to an expression already in 
-	   seen in this execution path then reuse that region *)
-	let new_rnum = ref 0 in
-	if !opt_trace_regions = true then
-	  Printf.printf "SRFM#region_for regions seen in this path = %d\n"
-	    (Hashtbl.length region_vals_per_path);
-	Hashtbl.iter (fun reg_exp region -> 
-	  let exp = V.BinOp(V.EQ, reg_exp, e) in
-	  let (b,_) = (self#query_condition exp (Some false) 0x6d02) in
-	  if b = true then (
-	    if !opt_trace_regions then
-	      Printf.printf "SRFM#region_for satisfied expr = %s\n"
-		(V.exp_to_string exp);
-	    new_rnum := region;)
-	) region_vals_per_path;
-	let is_sym_input_region_l = ref false in
-	let new_region =
-	  if !new_rnum <> 0 then !new_rnum 
-	  else if Hashtbl.mem region_vals e then Hashtbl.find region_vals e 
-	  else ( 
-	    let rnum' = self#fresh_region in
-	    Hashtbl.replace region_vals e rnum';
-	    rnum'
-	  )
-	in
-	if !opt_adaptor_search_mode = false then (
-	  match e with
-	  | V.Lval(V.Temp((i,s,ty))) when 
-	      (((String.length s) = 1) && ((Char.code s.[0]) - (Char.code 'a') < 6)) -> 
-	    (Printf.printf "found symbolic input(%s) as address \n" s;
-	     is_sym_input_region_l := true;)
-	  | _ -> ());
-	Hashtbl.replace region_vals_per_path e new_region;
-	Hashtbl.replace region_conc_addr_h new_region !conc_addr;
-	Hashtbl.replace conc_addr_region_h !conc_addr new_region;
-	if !is_sym_input_region_l = true then
-	  sym_input_region_l <- sym_input_region_l @ [new_region];
-	if !opt_trace_regions then
-	  Printf.printf "Address %s is region %d\n"
-	    (V.exp_to_string e) new_region;
-	new_region
+	let new_region = self#fresh_region in
+	  Hashtbl.replace region_vals e new_region;
+	  if !opt_trace_regions then
+	    Printf.printf "Address %s is region %d\n"
+	      (V.exp_to_string e) new_region;
+	  new_region
 
     method private is_region_base e =
       Hashtbl.mem region_vals e
@@ -926,9 +590,6 @@ struct
 	if !opt_trace_sym_addrs then
 	  Printf.printf "%s concrete value 0x%Lx for %s\n"
 	    verb bits (V.exp_to_string e);
-	if !opt_track_sym_usage then
-	  form_man#check_sym_usage e "concretized value"
-	    false self#query_relevance;
 	self#add_to_path_cond (V.BinOp(V.EQ, e, (const bits)));
 	bits
 
@@ -975,7 +636,7 @@ struct
 	       ignore(b));
 	!choices
 
-    method private region_expr e ident decide_fn =
+    method private region_expr e ident =
       if !opt_check_for_null then
 	(match
 	   self#check_cond (V.BinOp(V.EQ, e, addr_const 0L))
@@ -985,6 +646,7 @@ struct
 	   | Some false -> Printf.printf "Cannot be null.\n"
 	   | None -> Printf.printf "Can be null or non-null\n";
 	       infl_man#maybe_measure_influence_deref e);
+      dt#start_new_query;
       let (cbases, coffs, eoffs, ambig, syms) = classify_terms e form_man in
       let eoffs = List.map simplify_fp eoffs in
 	if !opt_trace_sym_addr_details then
@@ -1006,13 +668,11 @@ struct
 	let cbase = List.fold_left Int64.add 0L cbases in
 	let (base, off_syms) = match (cbase, syms, ambig) with
 	  | (0L, [], []) -> raise NullDereference
-	  (* adaptor expressions are classified as AmbiguousExpr, but they can
-	     still be region expressions *)
-	  (* The following two cases are applicable when applying table treatment 
-	     for symbolic regions *)
+	  (* This is the case to use when applying table treatment for symbolic
+	     regions *)
 	  | (0L, [], [e]) -> (Some(self#region_for e), [])
+	  | (0L, [], el) -> (Some 0, el)
 	  | (0L, [v], _) -> (Some(self#region_for v), ambig)
-	  | (0L, [], el) -> (Some 0, el) (* TODO: Pick one element from el *)
 	  | (0L, vl, _) ->
 	      let (bvar, rest_vars) =
 		(* We used to have logic here that checked whether one
@@ -1025,7 +685,6 @@ struct
 		   set, but with preferences based on seen regions. For
 		   now, omit that logic and always choose randomly from
 		   among all the possibilties.  *)
-		dt#start_new_query;
 		let split_count = ref (-1) in
 		  select_one vl
 		    (fun () ->
@@ -1033,7 +692,6 @@ struct
 		       self#random_case_split !opt_trace_decisions
 			 (!split_count + 0x100 + ident))
 	      in
-	      dt#count_query;
 		if !opt_trace_sym_addrs then
 		  Printf.printf "Choosing %s as the base address\n"
 		    (V.exp_to_string bvar);
@@ -1041,9 +699,9 @@ struct
 	  | (off, vl, _) ->
 	      (Some 0, vl @ ambig)
 	in
+	let no_off_expr = V.Constant(V.Int(V.REG_64, 0L)) in
 	let cloc = Int64.add cbase (List.fold_left Int64.add 0L coffs) in
-	(* return a SingleLocation(region, offset)
-	   or a TableLocation(region, off_expr, cloc) *)
+	(* return a (region, offset, is_table_load, off_expr, cloc) *)
 	match base with
 	| Some r
 	    when List.exists (fun (r', _) -> r = r') sink_regions ->
@@ -1061,17 +719,20 @@ struct
 	   else
 	     Printf.printf "Can be out of bounds.\n");
 	  sink_read_count <- Int64.add sink_read_count 0x10L;
-	  SingleLocation(None, sink_read_count)
+	  (None, sink_read_count, false, no_off_expr, cloc)
 	| _ ->
 	  let off_expr = (sum_list (eoffs @ off_syms)) in
-	  match decide_fn off_expr 0L with
+	  match self#decide_wd "Load" off_expr 0L with
 	  | Some wd ->
 	    if !opt_trace_tables then
 	      Printf.printf 
 		"Table treatment for sym region with base = %s and offset expr = %s\n"
 		(V.exp_to_string (List.hd ambig))
 		(V.exp_to_string off_expr);
-	    TableLocation(base, off_expr, cloc)
+	    (* region_expr should return a meaningless offset 
+	       without concretizing it because this load
+	       should be handled by a table_load or table_store *)
+	    (base, (fix_u32 0L), true, off_expr, cloc)
 	  | None -> 
 	    let coff = List.fold_left Int64.add 0L coffs in
 	    let offset = Int64.add (Int64.add cbase coff)
@@ -1083,7 +744,7 @@ struct
 		   (simplify_fp (sum_list (el @ vel))))
 		  (ident + 0x200)) in
 	    dt#count_query;
-	    SingleLocation(base, (fix_u32 offset))
+	    (base, (fix_u32 offset), false, no_off_expr, cloc)
 
     method private eval_addr_exp_region_conc_path e ident =
       let term_is_known_base = function
@@ -1124,35 +785,32 @@ struct
 	  | [_] -> failwith "known_base invariant failure"
 	  | _ -> failwith "multiple bases"
 
-    method private eval_addr_exp_region exp ident decide_fn =
+    method eval_addr_exp_region exp ident =
       let (to_concrete, to_symbolic) = match !opt_arch with
 	| (X86|ARM) -> (D.to_concrete_32, D.to_symbolic_32)
 	| X64       -> (D.to_concrete_64, D.to_symbolic_64)
       in
       let v = self#eval_int_exp_simplify exp in
 	try
-	  SingleLocation(Some 0, to_concrete v)
+	  (Some 0, to_concrete v, false, V.Constant(V.Int(V.REG_64, 0L)), 0L)
 	with NotConcrete _ ->
 	  let e = to_symbolic v in
 	  let eip = self#get_eip in
-	    if !opt_trace_sym_addrs then
+	    if !opt_trace_sym_addrs then (
 	      Printf.printf "Symbolic address %s @ (0x%Lx)\n"
-		(V.exp_to_string e) eip; 
-	    if !opt_track_sym_usage then
-	      form_man#check_sym_usage e "symbolic address"
-		false self#query_relevance;
+		(V.exp_to_string e) eip;
+	    );
 	    if !opt_concrete_path then
 	      let (r, addr) = self#eval_addr_exp_region_conc_path e ident in
-	      SingleLocation(r, addr)
+	      (r, addr, false, V.Constant(V.Int(V.REG_64, 0L)), 0L)
 	    else
-	      self#region_expr e ident decide_fn
+	      self#region_expr e ident
 		  
     (* Because we override handle_{load,store}, this should only be
        called for jumps. *)
     method eval_addr_exp exp =
-      match (self#eval_addr_exp_region exp 0xa000 (fun _ _ -> None)) with
-      | SingleLocation(r, addr) ->
-	(match r with
+      let (r, addr, _, _, _) = self#eval_addr_exp_region exp 0xa000 in
+	match r with
 	  | Some 0 -> addr
 	  | Some r_num ->
 	      if !opt_trace_stopping then
@@ -1169,9 +827,7 @@ struct
 	  | None ->
 	      if !opt_trace_stopping then
 		Printf.printf "Unsupported jump into sink region\n";
-	      raise SymbolicJump)
-      | TableLocation(r, off_expr, cloc) -> 
-	failwith "no table support for jumps, panic!"
+	      raise SymbolicJump
 
     method private register_num reg =
       match reg with
@@ -1293,18 +949,18 @@ struct
 	  | _ -> (v1, v2)
 
     method private store_byte_region  r addr b =
-      self#region_store r 8 addr b
+      (self#region r)#store_byte  addr b
     method private store_short_region r addr s =
-      self#region_store r 16 addr s
+      (self#region r)#store_short addr s
     method private store_word_region  r addr w =
-      self#region_store r 32 addr w
+      (self#region r)#store_word  addr w
     method private store_long_region  r addr l =
-      self#region_store r 64 addr l
+      (self#region r)#store_long  addr l
 
-    method private load_byte_region  r addr = self#region_load r 8 addr
-    method private load_short_region r addr = self#region_load r 16 addr
-    method private load_word_region  r addr = self#region_load r 32 addr
-    method private load_long_region  r addr = self#region_load r 64 addr
+    method private load_byte_region  r addr = (self#region r)#load_byte  addr
+    method private load_short_region r addr = (self#region r)#load_short addr
+    method private load_word_region  r addr = (self#region r)#load_word  addr
+    method private load_long_region  r addr = (self#region r)#load_long  addr
 
     method private query_valid e =
       let is_sat_r = ref false in
@@ -1358,9 +1014,9 @@ struct
 		   op_name cloc (V.exp_to_string off_exp) slow_wd;
 	       None)
 	    else
-	      Some (Int64.of_int slow_wd)
+	      Some slow_wd
 	else
-	  Some (Int64.of_int fast_wd)
+	  Some fast_wd
       in
 	if fast_wd = 0 then
 	  None
@@ -1370,16 +1026,16 @@ struct
 	      let wd = Hashtbl.find bitwidth_cache key in
 		if !opt_trace_tables then
 		  Printf.printf "Reusing cached width %d for %s at [%s]\n%!"
-		    (match wd with Some w -> (Int64.to_int w) | None -> -1)
+		    (match wd with Some w -> w | None -> -1)
 		    (V.exp_to_string off_exp) dt#get_hist_str;
 		wd
 	    with Not_found ->
-	      let wd = match compute_wd off_exp 
-		with Some 0L -> None
-		| wd' -> wd'
-	      in
+	      let wd = compute_wd off_exp in
 		Hashtbl.replace bitwidth_cache key wd;
-	        wd
+		if wd = Some 0 then
+		  None
+		else
+		  wd
 
     method private decide_offset_wd off_exp = 
       let fast_wd = narrow_bitwidth form_man off_exp in
@@ -1424,34 +1080,17 @@ struct
 		wd
 		    
     method private query_maxval e ty =
-      let midpoint a b =
-	let half_rounded x =
-	  let half = Int64.shift_right_logical x 1 in
-	    if Int64.logand x 1L = 0L then
-	      half
-	    else
-	      Int64.add half 0L
-	in
-	let sz = Int64.sub b a in
-	let hf_sz = half_rounded sz in
-	let mid = Int64.add a hf_sz in
-	assert(Vine_util.int64_ucompare a mid <= 0);
-	assert(Vine_util.int64_ucompare mid b <= 0);
-	mid
-      in
       let rec loop min max =
-	assert((int64_ucompare min max) <= 0);
+	assert(min <= max);
 	if min = max then
 	  min
 	else
 	  let mid = 
-	    if min = 0L && (int64_ucompare max 0x1000L) > 0 then
-	      int64_udiv max 256L (* reduce size faster to start *)
+	    if min = 0L && max > 0x1000L then
+	      Int64.div max 256L (* reduce size faster to start *)
 	    else
-	      midpoint min max
+	      Int64.div (Int64.add min max) 2L
 	  in
-	  assert((int64_ucompare min mid) <= 0);
-	  assert((int64_ucompare mid max) <= 0);
 	  let cond_e = V.BinOp(V.LE, e, V.Constant(V.Int(ty, mid))) in
 	  let in_bounds = self#query_valid cond_e in
 	    if !opt_trace_tables then
@@ -1467,7 +1106,7 @@ struct
       in
       let limit = loop 0L max_limit in
 	if !opt_trace_tables then
-	  Printf.printf "Largest value based on queries is %Lu\n" limit;
+	  Printf.printf "Largest value based on queries is %Ld\n" limit;
 	limit
 
     val maxval_cache = Hashtbl.create 101
@@ -1548,13 +1187,13 @@ struct
       in
       let load_ent addr = match ty with
 	| V.REG_8  -> form_man#simplify8
-	  (self#region_load region_num 8 addr)
+	    ((self#region region_num)#load_byte  addr)
 	| V.REG_16 -> form_man#simplify16
-	  (self#region_load region_num 16 addr)
+	    ((self#region region_num)#load_short addr)
 	| V.REG_32 -> form_man#simplify32
-	  (self#region_load region_num 32 addr)
+	    ((self#region region_num)#load_word  addr)
 	| V.REG_64 -> form_man#simplify64
-	  (self#region_load region_num 64 addr)
+	    ((self#region region_num)#load_long  addr)
 	| _ -> failwith "Unexpected type in table_load"
       in
       let table = map_n
@@ -1562,8 +1201,8 @@ struct
 	(num_ents - 1)
       in
         if !opt_trace_tables then
-	  Printf.printf "Load with base %08Lx, size 2**%d, stride %d, idx_exp %s"
-	    cloc idx_wd stride (V.exp_to_string idx_exp);
+	  Printf.printf "Load with base %08Lx, size 2**%d, stride %d"
+	    cloc idx_wd stride;
         Some (form_man#make_table_lookup table idx_exp idx_wd ty)
 
     method private concretize_once_and_load addr_e ty =
@@ -1588,13 +1227,13 @@ struct
       in
       let load_ent addr = match ty with
 	| V.REG_8  -> form_man#simplify8
-	  (self#region_load (Some 0) 8 addr)
+	    ((self#region (Some 0))#load_byte  addr)
 	| V.REG_16 -> form_man#simplify16
-	  (self#region_load (Some 0) 16 addr)
+	    ((self#region (Some 0))#load_short addr)
 	| V.REG_32 -> form_man#simplify32
-	  (self#region_load (Some 0) 32 addr)
+	    ((self#region (Some 0))#load_word  addr)
 	| V.REG_64 -> form_man#simplify64
-	  (self#region_load (Some 0) 64 addr)
+	    ((self#region (Some 0))#load_long  addr)
 	| _ -> failwith "Unexpected type in concretize_once_and_load"
       in
       let taut = V.BinOp(V.EQ, addr_e, addr_e) in
@@ -1628,81 +1267,62 @@ struct
 	  | (None, _) ->
 	      self#concretize_once_and_load addr_e ty
 	  | _ ->
-            if cbase = 0L then
-	      None
-	    else 
-	      match self#decide_wd "Load" off_exp cloc with
-	      | None -> None
-	      | Some wd -> self#table_load cloc (Some 0) off_exp (Int64.to_int wd) ty
-
-    method private get_esp_conc_base =
-      let (reg, ty) = match !opt_arch with
-	| X86 -> (R_ESP, V.REG_32)
-	| X64 -> (R_RSP, V.REG_64)
-	| ARM -> (R13, V.REG_32)
-      in
-      let e = match ty with
-	| V.REG_32 -> D.to_symbolic_32 (self#get_word_var_d reg)
-	| V.REG_64 -> D.to_symbolic_64 (self#get_long_var_d reg)
-	| _ -> failwith "Unexpected SP type in get_esp_conc_base"
-      in
-      let (cbases, _, _, _, _) = classify_terms e form_man in
-      let cbase = List.fold_left Int64.add 0L cbases in
-	cbase
-
+        if cbase = 0L then
+	  None
+	else 
+	  match self#decide_wd "Load" off_exp cloc with
+	    | None -> None
+	    | Some wd -> self#table_load cloc (Some 0) off_exp wd ty
+	    
     method private handle_load addr_e ty =
       if !opt_trace_offset_limit then
 	Printf.printf "Loading from... %s\n" (V.exp_to_string addr_e);
       match self#maybe_table_or_concrete_load addr_e ty with
       | Some v -> (v, ty)
       | None ->
-	let location = 
-	  self#eval_addr_exp_region addr_e 0x8000 (self#decide_wd "Load") in
-	let r' = ref None in
-	let addr' = ref 0L in
+	let (r, addr, is_table_load, off_expr, cloc ) = 
+	  self#eval_addr_exp_region addr_e 0x8000 in
 	let sym_region_table_v = 
-	  match location with
-	  | TableLocation(r, off_expr, _) ->
-	    (match self#decide_wd "Load" off_expr 0L with
+	  if is_table_load = true then (
+	    if addr <> 0L then 
+	      failwith "table load from symbolic region with non-zero offset, panic!";
+	    match self#decide_wd "Load" off_expr 0L with
 	    | None -> None
-	    | Some wd ->
-	      if !opt_trace_tables then
-		Printf.printf 
-		  "SRFM#handle_load table load for sym region with offset expr = %s\n"
-		  (V.exp_to_string off_expr);
-	      self#table_load 0L r off_expr (Int64.to_int wd) ty)
-	  | SingleLocation(r, addr) -> 
-	    r' := r; addr' := addr; None
+	    | Some wd -> 
+	      Printf.printf 
+		"SRFM#handle_load table load for sym region with offset expr = %s\n"
+		(V.exp_to_string off_expr);
+	      self#table_load 0L r off_expr wd ty
+	  ) else (
+	    if cloc <> 0L then 
+	      failwith "table load from symbolic region with non-zero cloc, panic!";
+	    None 
+	  )
 	in 
 	let v =
 	  match sym_region_table_v with
 	  | (Some value) -> value
 	  | None ->
 	    (match ty with
-	    | V.REG_8  -> form_man#simplify8  (self#load_byte_region  !r' !addr')
-	    | V.REG_16 -> form_man#simplify16 (self#load_short_region !r' !addr')
-	    | V.REG_32 -> form_man#simplify32 (self#load_word_region  !r' !addr')
-	    | V.REG_64 -> form_man#simplify64 (self#load_long_region  !r' !addr')
+	    | V.REG_8  -> form_man#simplify8  (self#load_byte_region  r addr)
+	    | V.REG_16 -> form_man#simplify16 (self#load_short_region r addr)
+	    | V.REG_32 -> form_man#simplify32 (self#load_word_region  r addr)
+	    | V.REG_64 -> form_man#simplify64 (self#load_long_region  r addr)
 	    | _ -> failwith "Unsupported memory type") 
 	in
 	(if !opt_trace_loads then
-	    (if !opt_trace_eval then
-		Printf.printf "    "; (* indent to match other details *)
-	     Printf.printf "Load from %s "
-	       (match !r' with
-	       | None -> "sink"
-	       | Some 0 -> "conc. mem"
-	       | Some r_num -> "region " ^ (string_of_int r_num));
-	     Printf.printf "%08Lx = %s" !addr' (D.to_string_32 v);
-	     (if !opt_use_tags then
-		 Printf.printf " (%Ld @ %08Lx)" (D.get_tag v) location_id);
-	     Printf.printf "\n"));
-	if !opt_track_sym_usage then
-	  (let stack_off = Int64.sub !addr' self#get_esp_conc_base in
-	   let is_stack = stack_off >= -128L && stack_off <= 0x100000L in
-	   form_man#check_sym_usage_d v ty "loaded value"
-	     is_stack self#query_relevance);
-	if !r' = Some 0 && (Int64.abs (fix_s32 !addr')) < 4096L then
+	  (if !opt_trace_eval then
+	       Printf.printf "    "; (* indent to match other details *)
+	   Printf.printf "Load from %s "
+	     (match r with
+		| None -> "sink"
+		| Some 0 -> "conc. mem"
+		| Some r_num -> "region " ^ (string_of_int r_num));
+	   Printf.printf "%08Lx = %s" addr (D.to_string_32 v);
+	   (if !opt_use_tags then
+	      Printf.printf " (%Ld @ %08Lx)" (D.get_tag v) location_id);
+	   Printf.printf "\n"));
+	if r = Some 0 && (Int64.abs (fix_s32 addr)) < 4096L then
 	  raise NullDereference;
 	(v, ty)
 
@@ -1883,20 +1503,20 @@ struct
     method private table_store cloc region_num off_exp e maxval ty value =
       let load_ent addr = match ty with
 	| V.REG_8  -> form_man#simplify8
-	  (self#region_load region_num 8 addr) 
+	    ((self#region region_num)#load_byte  addr)
 	| V.REG_16 -> form_man#simplify16
-	  (self#region_load region_num 16 addr) 
+	    ((self#region region_num)#load_short addr)
 	| V.REG_32 -> form_man#simplify32
-	  (self#region_load region_num 32 addr) 
+	    ((self#region region_num)#load_word  addr)
 	| V.REG_64 -> form_man#simplify64
-	  (self#region_load region_num 64 addr) 
+	    ((self#region region_num)#load_long  addr)
 	| _ -> failwith "Unexpected type in table_store" 
       in
       let store_ent addr v = match ty with
-	| V.REG_8  ->self#region_store region_num 8 addr v
-	| V.REG_16 ->self#region_store region_num 16 addr v
-	| V.REG_32 ->self#region_store region_num 32 addr v
-	| V.REG_64 ->self#region_store region_num 64 addr v
+	| V.REG_8  -> (self#region region_num)#store_byte  addr v
+	| V.REG_16 -> (self#region region_num)#store_short addr v
+	| V.REG_32 -> (self#region region_num)#store_word  addr v
+	| V.REG_64 -> (self#region region_num)#store_long  addr v
 	| _ -> failwith "Unexpected store type in table_store"
       in
       let stride = stride form_man off_exp in
@@ -1909,9 +1529,8 @@ struct
 	  let old_v = load_ent addr in
 	  let cond_e = (V.BinOp(V.EQ, off_exp, 
 				addr_const (Int64.of_int (i*stride)))) in
-	  if !opt_trace_tables then
-	    Printf.printf "SRFM#table_store i = %d cond_e = %s off_exp = %s\n" i
-	      (V.exp_to_string cond_e) (V.exp_to_string off_exp);
+	  Printf.printf "SRFM#table_store i = %d cond_e = %s off_exp = %s\n" i
+	    (V.exp_to_string cond_e) (V.exp_to_string off_exp);
 	  let cond_v = D.from_symbolic cond_e in
 	  let ite_v = form_man#make_ite cond_v ty value old_v in
 	    store_ent addr ite_v;
@@ -1939,10 +1558,10 @@ struct
 
     method private concretize_once_and_store addr_e ty value =
       let store_ent addr v = match ty with
-	| V.REG_8  ->self#region_store (Some 0) 8 addr v
-	| V.REG_16 ->self#region_store (Some 0) 16 addr v
-	| V.REG_32 ->self#region_store (Some 0) 32 addr v
-	| V.REG_64 ->self#region_store (Some 0) 64 addr v
+	| V.REG_8  -> (self#region (Some 0))#store_byte  addr v
+	| V.REG_16 -> (self#region (Some 0))#store_short addr v
+	| V.REG_32 -> (self#region (Some 0))#store_word  addr v
+	| V.REG_64 -> (self#region (Some 0))#store_long  addr v
 	| _ -> failwith "Unexpected store type in concretize_once_and_store"
       in
       let taut = V.BinOp(V.EQ, addr_e, addr_e) in
@@ -1980,63 +1599,50 @@ struct
       if (!opt_no_table_store) ||
 	not (self#maybe_table_or_concrete_store addr_e ty value)
       then
-	let location = 
-	  self#eval_addr_exp_region addr_e 0x9000 (self#decide_maxval "Store") in
-	let r = ref None in
-	let addr = ref 0L in
-	let table_store_status =
-	  match location with
-	  | TableLocation(r, off_exp, cloc) ->
-	    (match self#decide_maxval "Store" off_exp 0L with
-	    | None -> false
-	    | Some maxval -> 
-	      self#table_store cloc r off_exp 
-		(D.to_symbolic_32 (self#eval_int_exp_simplify addr_e)) 
-		maxval ty value)
-	  | SingleLocation(r', addr') -> r := r'; addr := addr'; false
-	in
-	if !r = Some 0 && (Int64.abs (fix_s32 !addr)) < 4096L then
+      let (r, addr, is_table_store, off_exp, cloc) = self#eval_addr_exp_region addr_e 0x9000 in
+	if r = Some 0 && (Int64.abs (fix_s32 addr)) < 4096L then
 	  raise NullDereference;
 	if !opt_trace_stores then
-	  if not (ty = V.REG_8 && !r = None) then
+	  if not (ty = V.REG_8 && r = None) then
 	    (if !opt_trace_eval then
 	       Printf.printf "    "; (* indent to match other details *)
 	     Printf.printf "Store to %s "
-	       (match !r with
+	       (match r with
 		  | None -> "sink"
 		  | Some 0 -> "conc. mem"
 		  | Some r_num -> "region " ^ (string_of_int r_num));
-	     Printf.printf "%08Lx = %s" !addr (D.to_string_32 value);
+	     Printf.printf "%08Lx = %s" addr (D.to_string_32 value);
 	     (if !opt_use_tags then
 		Printf.printf " (%Ld @ %08Lx)" (D.get_tag value) location_id);
 	     Printf.printf "\n");
-	if !opt_check_store_sequence = true then (  
-	  if (self#get_in_f1_range ()) = true then (
-	    (*Printf.printf "SRFM#handle_store: mem store in f1 at %08Lx\n" addr;*)
-	    self#add_f1_store !addr;
-	  ) else if (self#get_in_f2_range ()) = true then (
-	    (*Printf.printf "SRFM#handle_store: mem store in f2 at %08Lx\n" addr;*)
-	    self#add_f2_store !addr;
-	  );
-	);
-	if !opt_track_sym_usage then
-	  (let stack_off = Int64.sub !addr self#get_esp_conc_base in
-	   let is_stack = stack_off >= -128L && stack_off <= 0x100000L in
-	     form_man#check_sym_usage_d value ty "stored value"
-	       is_stack self#query_relevance);
-	(match (self#started_symbolic, !opt_target_region_start, !r) with
+	(match (self#started_symbolic, !opt_target_region_start, r) with
 	   | (true, Some from, Some 0) ->
-	       (match self#target_store_condition !addr from value ty with
+	       (match self#target_store_condition addr from value ty with
 		  | Some (offset, cond_v, wd) ->
 		      self#target_solve_single offset cond_v wd
 		  | None -> ())
 	   | _ -> ());
-	if not table_store_status then
+	let table_store_status =
+	  if is_table_store = true then (
+	    if addr <> 0L then 
+	      failwith "table store to symbolic region with non-zero concrete offset, panic!";
+	    match self#decide_maxval "Store" off_exp 0L with
+	    | None -> false
+	    | Some maxval -> 
+	      self#table_store cloc r off_exp 
+		(D.to_symbolic_32 (self#eval_int_exp_simplify addr_e)) 
+		maxval ty value)
+	  else (
+	    if cloc <> 0L then 
+	      failwith "table store to symbolic region with non-zero cloc, panic!";
+	    false )
+	in
+	if table_store_status <> true then
 	  (match ty with
-	  | V.REG_8 -> self#store_byte_region !r !addr value
-	  | V.REG_16 -> self#store_short_region !r !addr value
-	  | V.REG_32 -> self#store_word_region !r !addr value
-	  | V.REG_64 -> self#store_long_region !r !addr value
+	  | V.REG_8 -> self#store_byte_region r addr value
+	  | V.REG_16 -> self#store_short_region r addr value
+	  | V.REG_32 -> self#store_word_region r addr value
+	  | V.REG_64 -> self#store_long_region r addr value
 	  | _ -> failwith "Unsupported type in memory move")
 	else ()
 
@@ -2078,233 +1684,8 @@ struct
 	self#store_word_region (Some region) addr (D.from_concrete_32 v)
 
     method reset () =
-      if !opt_trace_mem_snapshots = true then
-	Printf.printf "SRFM#reset called\n";
       spfm#reset ();
-      if !opt_trace_mem_snapshots = true then
-	Printf.printf "SRFM#reset clearing regions\n";
       List.iter (fun gm -> gm#clear ()) regions;
-      if !opt_trace_mem_snapshots = true then
-	Printf.printf "SRFM#reset cleared regions\n";
-      Hashtbl.clear region_val_queried;
-      Hashtbl.clear region_vals_per_path;
-      Hashtbl.clear region_conc_addr_h;
-      Hashtbl.clear conc_addr_region_h;
-      sym_input_region_l <- [];
-      f1_hash_list <- [];
-      f2_hash_list <- [];
       Hashtbl.clear concrete_cache
-
-    method sym_region_struct_adaptor = 
-      let upcast expr _extend_op end_sz =
-	match _extend_op with 
-	| (Some extend_op) ->  
-	  (match end_sz with
-	  | 8  -> V.Cast(extend_op, V.REG_8 , expr)
-	  | 16 -> V.Cast(extend_op, V.REG_16, expr)
-	  | 32 -> V.Cast(extend_op, V.REG_32, expr)
-	  | 64 -> V.Cast(extend_op, V.REG_64, expr)
-	  | _ -> failwith "unsupported upcast end size")
-	| None -> expr
-      in
-      let from_concrete v sz = 
-	match sz with 
-	| 8 -> assert(v >= -128 && v <= 0xff);
-	  V.Constant(V.Int(V.REG_8,  (Int64.of_int (v land 0xff))))
-	| 16 -> assert(v >= -65536 && v <= 0xffff);
-	  V.Constant(V.Int(V.REG_16, (Int64.of_int (v land 0xffff))))
-	| 32 -> V.Constant(V.Int(V.REG_32, (Int64.logand (Int64.of_int v) 0xffffffffL)))
-	| 64 -> V.Constant(V.Int(V.REG_64, (Int64.of_int v)))
-	| _ -> failwith "unsupported size passed to SRFM#from_concrete"
-      in
-      let to_sym_op exp sz = 
-	match sz with
-	| 8 ->  ( D.to_symbolic_8  exp) 
-	| 16 -> ( D.to_symbolic_16 exp) 
-	| 32 -> ( D.to_symbolic_32 exp) 
-	| 64 -> ( D.to_symbolic_64 exp) 
-	| _ -> failwith "unhandled target size in SRFM#apply_struct_adaptor"
-      in
-      let get_byte expr pos =
-	V.Cast(V.CAST_LOW, V.REG_8, 
-	       V.BinOp(V.RSHIFT, expr, (from_concrete (pos*8) 8)))
-      in
-      (* let unique = Vine_util.list_unique in *)
-      (* This simplifies formulas and introduces t-variables for
-	 comple sub-expressions. Doing this generally speeds things up,
-	 but it may make debugging the formulas less convenient, so you
-	 can disable it by make "simplify" be the identity function. *)
-      let simplify e = 
-	if !opt_split_target_formulas = true then spfm#simplify_exp e else e in
-      (* let simplify e = e in *)
-
-      if !opt_trace_struct_adaptor = true then
-	Printf.printf "SRFM#apply_struct_adaptor starting...\n";
-      if !opt_time_stats then
-	(Printf.printf "SRFM#Generating structure adaptor formulas...";
-	 flush stdout);
-      if !opt_adaptor_search_mode = false then	
-	let get_ite_expr arg op const_type const then_val else_val = 
-	  V.Ite(V.BinOp(op, arg, V.Constant(V.Int(const_type, const))),
-		then_val,
-		else_val)
-	in
-	let start_time = Sys.time () in
-	List.iteri ( fun sym_input_region_l_ind rnum ->
-	  let (_, _, max_size) = !opt_struct_adaptor_params in
-
-	  if !opt_time_stats then
-	    (Printf.printf "(%d)..." rnum;
-	     flush stdout);
-
-	  (* Moving array_field_ranges_l, i_byte_arr, i_n_arr computation 
-	     from here to AS.ml *)	
-
-	  let i_byte_arr = Adaptor_synthesis.i_byte_arr' in
-	  let i_n_arr = Adaptor_synthesis.i_n_arr' in
-	  
-	  
-	  let rec get_arr_t_field_expr field_num this_array_field_ranges_l 
-	      ai_byte ai_f_sz ai_n =
-	  (* Assume ai_n equals target_n for now *)
-	    let get_ai_byte_expr target_n target_sz start_addr ex_op =
-	      let cast_op =
-		if target_sz < ai_f_sz then 
-		  if ex_op = 1 then (Some V.CAST_SIGNED) 
-		  else (Some V.CAST_UNSIGNED)
-		else if target_sz > ai_f_sz then (Some V.CAST_LOW)
-		else None
-	      in
-	    (* translate ai_byte to a t_byte by using ai_f_sz and t_sz *)
-	      let ai_q = ai_byte/ai_f_sz in
-	      let ai_r = ai_byte mod ai_f_sz in
-	      let tmp_addr = Int64.add start_addr (Int64.of_int (ai_q*target_sz)) in
-	      let ai_entry = upcast 
-		(to_sym_op (self#region_load (Some rnum) (target_sz*8) tmp_addr) (target_sz*8)) 
-		cast_op (ai_f_sz*8) 
-	      in 
-	      get_byte ai_entry ai_r
-	    in
-	    let addr = 0L in
-	    match this_array_field_ranges_l with
-	    | [] -> failwith "SRFM#get_arr_t_field_expr ran out of this_array_field_ranges_l"
-	    | [(start_byte, end_byte, n, f_sz)] -> 
-	      assert(n = ai_n);
-	      let start_addr = (Int64.add addr (Int64.of_int start_byte)) in
-	      get_ai_byte_expr n f_sz start_addr 1
-	    | (start_byte, end_byte, n, f_sz)::tail ->
-	      assert(n = ai_n);
-	      let start_addr = (Int64.add addr (Int64.of_int start_byte)) in
-	      let is_extend_req = (f_sz - 8) in
-	      if is_extend_req <> 0 then (
-		let sign_extend_val = Int64.of_int ((start_byte lsl 32)+(end_byte lsl 16)+1) in 
-		let zero_extend_val = Int64.of_int ((start_byte lsl 32)+(end_byte lsl 16)+0) in 
-		if  (n = ai_n) then (
-		    let f_type_str = "f"^(Printf.sprintf "%d" field_num)^"_type" in
-		    let f_type = spfm#get_fresh_symbolic f_type_str 64 in
-		    let sign_extend_expr = get_ai_byte_expr n f_sz start_addr 1 in
-		    let zero_extend_expr = get_ai_byte_expr n f_sz start_addr 0 in
-		    get_ite_expr f_type V.EQ V.REG_64 sign_extend_val sign_extend_expr 
-		      (get_ite_expr f_type V.EQ V.REG_64 zero_extend_val zero_extend_expr
-			 (simplify
-			    (get_arr_t_field_expr field_num tail
-			       ai_byte ai_f_sz ai_n) ) 
-		      )
-		   ) else (
-		    simplify (get_arr_t_field_expr field_num tail
-				ai_byte ai_f_sz ai_n)
-		   )
-	      ) else (
-		let sign_extend_val = Int64.of_int ((start_byte lsl 32)+(end_byte lsl 16)+1) in 
-		if (ai_n = n) then (
-		    let f_type_str = "f"^(Printf.sprintf "%d" field_num)^"_type" in
-		    let f_type = spfm#get_fresh_symbolic f_type_str 64 in
-		    let sign_extend_expr = get_ai_byte_expr n f_sz start_addr 1 in
-		    get_ite_expr f_type V.EQ V.REG_64 sign_extend_val sign_extend_expr 
-		      (simplify (get_arr_t_field_expr field_num tail
-				  ai_byte ai_f_sz ai_n))
-		   ) else (
-		    simplify (get_arr_t_field_expr field_num tail
-				ai_byte ai_f_sz ai_n)
-		   )
-	      )
-	  in
-	  let field_exprs = Hashtbl.create 1001 in
-	  let t_field_h = Hashtbl.create 100 in
-
-	  let rec get_arr_ite_ai_byte_expr this_array_field_ranges_l i_byte =
-	    (* i_byte = interesting_byte *)
-	    match this_array_field_ranges_l with
-	    | [] -> from_concrete 0 8
-	    | (field, start_byte, end_byte, ai_n, ai_f_sz, cond)::tail ->
-	      if (i_byte >= start_byte) && (i_byte <= end_byte) then (
-		let field_size_temp_str = "arr_srfm_t_field_"^
-		  (Printf.sprintf "%d_n%d_sz%d_b%d_%d" field ai_n ai_f_sz 
-		     (i_byte-start_byte) sym_input_region_l_ind)
-		in
-		let field_size_temp = spfm#get_fresh_symbolic field_size_temp_str 8 in
-		let q_exp = 
-		  (try
-		     Hashtbl.find field_exprs field_size_temp_str
-		   with Not_found ->
-		     let new_q_exp =
-		       V.BinOp(V.EQ, field_size_temp,
-			       (get_arr_t_field_expr field 
-				  (List.rev !((!i_n_arr).(ai_n))) (* array_field_ranges_l *)
-				  (i_byte-start_byte) ai_f_sz ai_n)) in
-		     Hashtbl.replace field_exprs field_size_temp_str new_q_exp;
-		     spfm#add_to_path_cond new_q_exp;
-		     new_q_exp)
-		in
-		
-		if !opt_trace_struct_adaptor = true then 
-		  Hashtbl.replace t_field_h field_size_temp q_exp;
-		
-		V.Ite(cond, field_size_temp, (get_arr_ite_ai_byte_expr tail i_byte))
-	      ) else (
-		get_arr_ite_ai_byte_expr tail i_byte
-	      )
-	  in
-	  
-	  if !opt_time_stats then
-	    (Printf.printf "byte expressions...";
-	     flush stdout);
-	  
-	  let byte_expr_l = ref [] in
-	  for i=0 to (max_size-1) do 
-	    let byte_expr = (get_arr_ite_ai_byte_expr (List.rev !((!i_byte_arr).(i))) i) in
-	    let byte_expr_sym_str = "arr_ai_byte_"^(Printf.sprintf "%d_%d" i sym_input_region_l_ind) in
-	    let byte_expr_sym = spfm#get_fresh_symbolic byte_expr_sym_str 8 in
-	    let q_exp = V.BinOp(V.EQ, byte_expr_sym, byte_expr) in
-	    if !opt_trace_struct_adaptor = true then 
-	      Printf.printf "SRFM#get_arr_ite_ai_byte_expr for byte %d: %s\n\n" i
-		(V.exp_to_string q_exp);
-	    spfm#add_to_path_cond q_exp; 
-	    byte_expr_l := (D.from_symbolic byte_expr_sym) :: !byte_expr_l;
-	    if !opt_time_stats then
-	      (Printf.printf "om%d " i;
-	       flush stdout);
-	  done;
-
-	  byte_expr_l := (List.rev !byte_expr_l);
-
-	  if !opt_trace_struct_adaptor = true then 
-	    Hashtbl.iter (fun key value ->
-	      Printf.printf "SRFM#apply_struct_adaptor t_field_h[%s] = %s\n" 
-		(V.exp_to_string key) (V.exp_to_string value);
-	    ) t_field_h; 
-	
-	  
-	  for i=0 to (max_size-1) do
-	    self#region_store (Some rnum) 8 (Int64.of_int i) (List.nth !byte_expr_l i);
-	  done;
-	  
-	) sym_input_region_l;
-	if !opt_time_stats then
-	  (Printf.printf "SRFM#ready to apply (%f sec).\n" (Sys.time () -. start_time);
-	   flush stdout);
-
   end
-    
 end
-    
diff --git a/execution/sym_region_frag_machine.mli b/execution/sym_region_frag_machine.mli
index f5af2d3..c9b617d 100644
--- a/execution/sym_region_frag_machine.mli
+++ b/execution/sym_region_frag_machine.mli
@@ -26,6 +26,8 @@ sig
     method get_eip : int64
     method set_eip : int64 -> unit
 
+    method eval_addr_exp_region : Vine.exp -> int -> (int option * int64 * bool * Vine.exp * int64)
+		  
     method eval_addr_exp : Vine.exp -> int64
 
     method get_word_var_concretize : Fragment_machine.register_name ->
@@ -60,9 +62,6 @@ sig
 
     method reset : unit -> unit
 
-    method conc_mem_struct_adaptor: bool -> unit
-    method sym_region_struct_adaptor: unit
-
     method after_exploration : unit
 
     method get_depth : int
@@ -77,10 +76,7 @@ sig
     method input_depth : int
     method query_with_path_cond : Vine.exp -> bool
       -> (bool * Query_engine.sat_assign)
-    method query_condition : Vine.exp -> bool option -> int -> (bool * bool option) 
-    method add_to_path_cond : Vine.exp -> unit
     method query_unique_value : Vine.exp -> Vine.typ -> int64 option
-    method query_relevance : Vine.var -> Vine.exp -> bool
     method follow_or_random : bool 
     method query_with_pc_choice : Vine.exp -> bool -> int -> (unit -> bool)
       -> (bool * Vine.exp)
@@ -113,24 +109,16 @@ sig
     method private on_missing_symbol_m :
       Granular_memory.GranularMemoryFunctor(D).granular_memory
       -> string -> unit
-    method private on_missing_symbol_m_lim :
-      Granular_memory.GranularMemoryFunctor(D).granular_memory
-      -> string -> int64 -> unit
     method make_regs_zero : unit
     method make_regs_symbolic : unit
     method load_x86_user_regs : Temu_state.userRegs -> unit
     method print_regs : unit
-    method print_syscall_regs : unit
     method printable_word_reg : Fragment_machine.register_name -> string
     method printable_long_reg : Fragment_machine.register_name -> string
     method store_byte  : int64 -> D.t -> unit
     method store_short : int64 -> D.t -> unit
     method store_word  : int64 -> D.t -> unit
     method store_long  : int64 -> D.t -> unit
-
-    method load_sym : int64 -> int -> Vine.exp
-    method store_sym : int64 -> int -> Vine.exp -> unit
-
     method store_byte_conc  : int64 -> int   -> unit
     method store_short_conc : int64 -> int   -> unit
     method store_word_conc  : int64 -> int64 -> unit
@@ -185,36 +173,6 @@ sig
       Fragment_machine.register_name -> int -> unit
     method set_word_var_second_byte :
       Fragment_machine.register_name -> int -> unit
-    method get_fresh_symbolic : string -> int -> Vine.exp
-    method get_reg_symbolic : 
-      Fragment_machine.register_name -> Vine.exp
-    method query_exp : Vine.exp -> Vine.exp -> unit
-    method simplify_exp : Vine.exp -> Vine.exp
-    method set_reg_symbolic : 
-      Fragment_machine.register_name -> Vine.exp -> unit
-   
-    method make_f1_sym_snap : unit 
-    method make_f1_conc_snap : unit 
-    method save_f1_sym_se : unit
-    method save_f1_conc_se : unit
-    method make_f2_sym_snap : unit
-    method make_f2_conc_snap : unit
-    method compare_sym_se : unit
-    method compare_conc_se : unit
-    method make_f1_special_handlers_snap : unit
-    method reset_f1_special_handlers_snap : unit
-    method make_f2_special_handlers_snap : unit
-    method reset_f2_special_handlers_snap : unit
-
-    method save_arg_regs : int64 -> unit
-    method add_f1_store : int64 -> unit
-    method add_f2_store : int64 -> unit
-    method match_writes : unit -> bool
-    method get_saved_arg_regs : unit -> Vine.exp list
-    method reset_saved_arg_regs : unit 
-    method load_byte_symbolic  : int64 -> Vine.exp
-    method store_byte_symbolic  : int64 -> Vine.exp -> unit
-    method make_table_lookup : (Vine.exp list) -> Vine.exp -> int -> Vine.typ -> Vine.exp
     method set_word_reg_symbolic :
       Fragment_machine.register_name -> string -> unit
     method set_word_reg_concolic :
@@ -288,25 +246,6 @@ sig
     method get_form_man :
       Formula_manager.FormulaManagerFunctor(D).formula_manager
     val reg_to_var :(Fragment_machine.register_name, Vine.var) Hashtbl.t
-
-    val mutable in_f1_range: bool
-    val mutable in_f2_range: bool
-    val mutable f1_syscalls: int list
-    val mutable f1_syscalls_args: Vine.exp list
-    val mutable f2_syscalls_num: int 
-    val mutable f2_syscalls_arg_num: int 
-    method get_in_f1_range: unit -> bool
-    method get_in_f2_range: unit -> bool
-    method add_f1_syscall_with_args: int -> Vine.exp list -> unit
-    method check_f2_syscall: int -> bool
-    method check_f2_syscall_args: Vine.exp list -> int -> bool
-    method match_syscalls: unit -> bool
-    method reset_syscalls: unit
-    method reset_struct_counts: unit 
-    
-    method restrict_symbolic_expr : Fragment_machine.register_name list -> int -> (Vine.exp -> Vine.exp) -> unit
-    method check_adaptor_condition : Vine.exp -> unit
-    
     val mem :
       Granular_memory.GranularMemoryFunctor(D).granular_second_snapshot_memory
   end
diff --git a/libasmir/src/vex/irtoir-x64.cpp b/libasmir/src/vex/irtoir-x64.cpp
index 859724c..786708b 100644
--- a/libasmir/src/vex/irtoir-x64.cpp
+++ b/libasmir/src/vex/irtoir-x64.cpp
@@ -939,7 +939,7 @@ Exp *x64_translate_get( IRExpr *expr, IRSB *irbb, vector<Stmt *> *irout )
     {
         result = translate_get_reg_16(offset);
     }
-    else if ( type == Ity_I32 || type == Ity_F32 )
+    else if ( type == Ity_I32 )
     {
         result = translate_get_reg_32(offset);
     }
@@ -947,6 +947,10 @@ Exp *x64_translate_get( IRExpr *expr, IRSB *irbb, vector<Stmt *> *irout )
     {
         result = translate_get_reg_64(offset);
     }
+    else if ( type == Ity_F32 )
+    {
+        result = new Unknown("register type (F32)");
+    }
 
     else if ( type == Ity_I128 || type == Ity_V128 )
     {
@@ -1417,7 +1421,7 @@ Stmt *x64_translate_put( IRStmt *stmt, IRSB *irbb, vector<Stmt *> *irout )
     //
     // Regular 32 bit registers
     //
-    else if ( type == Ity_I32 || type == Ity_F32 )
+    else if ( type == Ity_I32 )
     {
         result = translate_put_reg_32(offset, data, irbb);
     }
diff --git a/libasmir/src/vex/irtoir.cpp b/libasmir/src/vex/irtoir.cpp
index 83907a2..882fc7d 100644
--- a/libasmir/src/vex/irtoir.cpp
+++ b/libasmir/src/vex/irtoir.cpp
@@ -2672,6 +2672,10 @@ Stmt *translate_jumpkind( IRSB *irbb, vector<Stmt *> *irout )
       result = new Jmp(dest);
       break;
 #endif
+    case Ijk_ClientReq:
+      irout->push_back( new Special("Valgrind client request") );
+      result = new Jmp(dest);
+      break;
     default:
       assert(0);
     }
diff --git a/ocaml/vine_opt.ml b/ocaml/vine_opt.ml
index f078080..4adce23 100644
--- a/ocaml/vine_opt.ml
+++ b/ocaml/vine_opt.ml
@@ -433,15 +433,15 @@ let rec constant_fold ctx e =
     | Ite(UnOp(NOT, c), x, y) -> Ite(c, y, x)
     | Ite(cond, Constant(Int(REG_1, 1L)), Constant(Int(REG_1, 0L))) -> cond
     | Ite(cond, Constant(Int(REG_1, 0L)), Constant(Int(REG_1, 1L))) ->
-	UnOp(NOT, cond)
+        UnOp(NOT, cond)
     | Ite(cond, Constant(Int(REG_1, 1L)), cond2) ->
-	BinOp(BITOR, cond, cond2)
+        BinOp(BITOR, cond, cond2)
     | Ite(cond, cond2, Constant(Int(REG_1, 0L))) ->
-	BinOp(BITAND, cond, cond2)
+        BinOp(BITAND, cond, cond2)
     | Cast(ct, ty, Ite(cond, e1, e2)) ->
-	Ite(cond, Cast(ct, ty, e1), Cast(ct, ty, e2))
+        Ite(cond, Cast(ct, ty, e1), Cast(ct, ty, e2))
     | BinOp(op, Ite(cond, e1, e2), (Constant(_) as k)) ->
-	Ite(cond, BinOp(op, e1, k), BinOp(op, e2, k))
+        Ite(cond, BinOp(op, e1, k), BinOp(op, e2, k))
     (* AND / OR with itself *)
     | BinOp(BITOR, x, y)
     | BinOp(BITAND, x, y)
@@ -466,10 +466,6 @@ let rec constant_fold ctx e =
 	    Constant(Int(ty2, s2)))
 	when ty1 = ty2 && s1 >= 0L && s2 >= 0L ->
 	BinOp(ARSHIFT, x, (Constant(Int(ty1, (Int64.add s1 s2)))))
-    | BinOp(BITAND,BinOp(BITOR,e,Constant(Int(_,or_const))),
-	    Constant(Int(and_const_type,and_const))) 
-	when (Int64.logand or_const and_const) = 0L ->
-      BinOp(BITAND,e,Constant(Int(and_const_type,and_const)))
     (* byte & 0xffffff00 = 0 *)
     | BinOp(BITAND,
 	    Cast(CAST_UNSIGNED, REG_32, e),
diff --git a/vex-r3206-bsf.patch b/vex-r3206-bsf.patch
deleted file mode 100644
index dd05972..0000000
--- a/vex-r3206-bsf.patch
+++ /dev/null
@@ -1,26 +0,0 @@
-Index: priv/guest_amd64_toIR.c
-===================================================================
---- priv/guest_amd64_toIR.c	(revision 3206)
-+++ priv/guest_amd64_toIR.c	(working copy)
-@@ -8231,16 +8231,16 @@
- 
-    /* The main computation, guarding against zero. */
-    assign( dst64,
--           IRExpr_ITE( 
--              mkexpr(srcB),
-+           //IRExpr_ITE( 
-+	   //mkexpr(srcB),
-               /* src != 0 */
-               fwds ? unop(Iop_Ctz64, mkexpr(src64))
-                    : binop(Iop_Sub64, 
-                            mkU64(63), 
--                           unop(Iop_Clz64, mkexpr(src64))),
-+                           unop(Iop_Clz64, mkexpr(src64)))//,
-               /* src == 0 -- leave dst unchanged */
--              widenUto64( getIRegG( sz, pfx, modrm ) )
--           )
-+              //widenUto64( getIRegG( sz, pfx, modrm ) )
-+           //)
-          );
- 
-    if (sz == 2)
